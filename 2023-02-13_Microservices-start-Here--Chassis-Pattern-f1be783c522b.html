<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Microservices start Here: Chassis Pattern</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Microservices start Here: Chassis Pattern</h1>
</header>
<section data-field="subtitle" class="p-summary">
A good service template is the top priority
</section>
<section data-field="body" class="e-content">
<section name="f741" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0d43" id="0d43" class="graf graf--h3 graf--leading graf--title">Microservices start Here: Chassis Pattern</h3><h4 name="ab78" id="ab78" class="graf graf--h4 graf-after--h3 graf--subtitle">A good service template is the top priority</h4><figure name="9f3d" id="9f3d" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*2tInONkKydGYHRSg" data-width="1000" data-height="665" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*2tInONkKydGYHRSg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@glenncarstenspeters" data-href="https://unsplash.com/@glenncarstenspeters" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Glenn Carstens-Peters</a> on <a href="https://unsplash.com/photos/RLw-UC03Gwc" data-href="https://unsplash.com/photos/RLw-UC03Gwc" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="1279" id="1279" class="graf graf--p graf-after--figure">When we talk about microservices, we have to understand that <strong class="markup--strong markup--p-strong">the number of services within the microservices architecture is significant</strong>; in some large organizations where the number of microservices is even in the tens of thousands.</p><p name="5bdc" id="5bdc" class="graf graf--p graf-after--p">If each service setup has to go through a complicated programming process, then it will be a huge overhead to develop a large number of microservices just to build them. Therefore, we would like to have a service template that can be applied across the organization, so that <strong class="markup--strong markup--p-strong">we can develop a new service without the complicated “first step” and start directly from the functionality.</strong></p><p name="6399" id="6399" class="graf graf--p graf-after--p">Such a design pattern is called a microservice chassis.</p><p name="9ee9" id="9ee9" class="graf graf--p graf-after--p">Nevertheless, there is no standard definition of what should be included in the chassis, but a few essential items are listed in <a href="https://microservices.io/book" data-href="https://microservices.io/book" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">some books</a>.</p><figure name="78ae" id="78ae" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*ConOfNBBR1LGJ7VG.png" data-width="720" data-height="903" src="https://cdn-images-1.medium.com/max/800/0*ConOfNBBR1LGJ7VG.png"></figure><ul class="postList"><li name="d17f" id="d17f" class="graf graf--li graf-after--figure">Security</li><li name="728d" id="728d" class="graf graf--li graf-after--li">Externalized configuration</li><li name="ccc9" id="ccc9" class="graf graf--li graf-after--li">Logging</li><li name="82f4" id="82f4" class="graf graf--li graf-after--li">Health check</li><li name="6a9d" id="6a9d" class="graf graf--li graf-after--li">Metrics</li><li name="fd5c" id="fd5c" class="graf graf--li graf-after--li">Distributed tracing</li></ul><p name="7604" id="7604" class="graf graf--p graf-after--li">Indeed, these are the keys to running a microservice, but from my point of view, they are far from enough. Because, in an organization, there is a lot of additional works must be handled when setting up a service.</p><p name="6409" id="6409" class="graf graf--p graf-after--p">So, this article will describe what my ideal chassis should contain. I will divide these items into three parts: <strong class="markup--strong markup--p-strong">must-have</strong>, <strong class="markup--strong markup--p-strong">nice-to-have</strong>, and <strong class="markup--strong markup--p-strong">best-effort</strong>, and explain the meaning of each item.</p><h3 name="a4d2" id="a4d2" class="graf graf--h3 graf-after--p"><code class="markup--code markup--h3-code">Must-have</code></h3><p name="c4de" id="c4de" class="graf graf--p graf-after--h3">Let’s start with the must-have items, which can be divided into several categories within the must-have items.</p><ul class="postList"><li name="93d8" id="93d8" class="graf graf--li graf-after--p">CI/CD related</li><li name="a99f" id="a99f" class="graf graf--li graf-after--li">Function related</li><li name="8f46" id="8f46" class="graf graf--li graf-after--li">Troubleshooting related</li></ul><p name="b10b" id="b10b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">CI/CD related</em></strong></p><p name="66f7" id="66f7" class="graf graf--p graf-after--p">Items under this category are when a new source code repository is created and there are established rules based on organizational specifications or team practices, so whether it is a microservice or not, these items should be available as long as the code is managed.</p><ol class="postList"><li name="07b2" id="07b2" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Linter</strong>: Whatever the programming language is, there are actually corresponding development specifications, for example, Python has PEP8, Javascript has ESLint’s Airbnb rules, etc.</li><li name="e63a" id="e63a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Formatter</strong>: In addition to code writing conventions, there are also conventions for code layout, such as Golang’s built-in gofmt.</li><li name="c514" id="c514" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Folder structure</strong>: The structure of folders has some fixed conventions in various programming languages or frameworks, for example, Golang has <a href="https://github.com/golang-standards/project-layout" data-href="https://github.com/golang-standards/project-layout" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">standard project layout</a>.</li><li name="ad04" id="ad04" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Unit testing</strong>: Of course, as long as the software is developed, it should be tested, so each source code repository needs to have a well-defined test framework. In addition to the test suite that must be installed, it is also necessary to define where the test files should be placed, such as in the <code class="markup--code markup--li-code">src/tests</code> directory or on the same level as the source code.</li><li name="cc11" id="cc11" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Integration testing</strong>: With unit testing, integration testing is also important. If you are not sure how to distinguish between the two, please refer to <a href="https://medium.com/interviewnoodle/whats-difference-between-unit-test-and-integration-test-aae6ef13220" data-href="https://medium.com/interviewnoodle/whats-difference-between-unit-test-and-integration-test-aae6ef13220" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">my previous article</a>. Integration testing will need to prepare application dependencies, such as databases, etc. A common practice is to define the entire test environment through <code class="markup--code markup--li-code">docker-compose.yml</code>.</li><li name="06ad" id="06ad" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Package management</strong>: Each language has a corresponding package management tool, such as <code class="markup--code markup--li-code">pip</code> or <code class="markup--code markup--li-code">poetry</code> for Python, <code class="markup--code markup--li-code">npm</code> or <code class="markup--code markup--li-code">yarn</code> for Javascript, etc. In addition to the package management tool, it is also necessary to prepare a lock file to fix the versions of the dependent packages.</li><li name="50be" id="50be" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Dockerfile</strong>: In the microservices architecture now mostly exists in the container system, so it is important to prepare a <code class="markup--code markup--li-code">Dockerfile</code> developed based on best practices, in order to make containers more secure and efficient. <a href="https://pythonspeed.com/docker/#articles-best-practices-for-production" data-href="https://pythonspeed.com/docker/#articles-best-practices-for-production" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Here are</a> some best practices for building Python containers.</li><li name="05a0" id="05a0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Pipeline template</strong>: When the Dockerfile is available, I believe it should be possible to publish at least one of the simplest applications. Then, depending on the version control system or release system used by the organization and the organization’s defined release specifications, a basic CI/CD release pipeline can be written. Because each organization uses a different system, it should be prepared to meet the needs of the moment, such as Bitbucket pipeline, Gitlab CI, Github Action, etc. They all use different formats.</li><li name="ab75" id="ab75" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Static application analysis</strong>: The last item is static analysis, which is divided into code level analysis and application level analysis. Common code analysis includes test coverage, memory leaks, package dependencies, etc. Application-level analysis is for possible vulnerabilities, such as the use of <a href="https://snyk.io/" data-href="https://snyk.io/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Synk</a>.</li></ol><p name="d497" id="d497" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Function related</em></strong></p><p name="1889" id="1889" class="graf graf--p graf-after--p">There are many items listed above, but they are not finished yet.</p><p name="50e1" id="50e1" class="graf graf--p graf-after--p">Those items focus on CI/CD, but application development is the core, so there will be some preconditions in the software development.</p><ol class="postList"><li name="cb57" id="cb57" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Config loader</strong>: An application’s configuration may come from many different sources, for example, the default configuration file can be overwritten by environment variables, and even specify the path to a new configuration file. Take the Postgres container as an example, it is possible to create a database through <code class="markup--code markup--li-code">POSTGRES_DB</code>, and if we want to create multiple databases, then we can mount the sql files under <code class="markup--code markup--li-code">docker-entrypoint-initdb.d</code>. These rules should be part of the template when setting up a new application, so we don’t need to write each once again.</li><li name="d9de" id="d9de" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Feature toggle loader</strong>: The feature toggle and its use are described in <a href="https://medium.com/better-programming/feature-toggle-introduction-68d58f5c709" data-href="https://medium.com/better-programming/feature-toggle-introduction-68d58f5c709" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">my previous article</a>. Feature toggles are already a common strategy in software development, so they should be pre-defined in the similar way as the config loader.</li><li name="23a8" id="23a8" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Web framework</strong>: The most important thing in a microservice chassis is of course to choose the front/back end framework. I believe that the same framework should be used cross the same organization, then the framework should be from the template.</li></ol><p name="4871" id="4871" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Troubleshooting related</em></strong></p><p name="d1cd" id="d1cd" class="graf graf--p graf-after--p">When there is a function that can be published, what happens when there is a problem in the production environment? Especially when there are a large number of microservices under the microservice architecture, it is necessary to provide sufficient observability to identify the root cause of the problem.</p><ol class="postList"><li name="ed8e" id="ed8e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Distributed tracing</strong>: It is a common requirement for microservice architectures to be able to trace the processing rate between each service, and even the time share of database calls within each service, so that the entire service mesh can be mapped. There are many common tools, such as the open sourced Open Telemetry or the commercial New Relic, Elastic APM, etc. These tools require an agent to be installed in the application, and therefore the package and initialization need to be defined.</li><li name="70b3" id="70b3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Logger</strong>: In order to analyze the behavior of applications, logging plays a significant role. How to record logs, how logs are collected and the format of logs are all related to the team practice, so how logger should be implemented will also be a standard process.</li><li name="9861" id="9861" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Health check</strong>: Among the tens of thousands of microservices, how to know each service is still alive? The most common practice is to define a fixed REST API for monitoring, so this fixed API will be defined by the template, but the implementation still has to be developed based on each service’s characteristics.</li><li name="dac1" id="dac1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Metric exporter</strong>: Although distributed tracing is already available to collect general metrics, some application-related behaviors cannot be collected, and some distributed tracing frameworks provide the ability to customize metrics, so how the application’s custom metrics are exported also needs to be defined.</li><li name="3005" id="3005" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Local development environment</strong>: In the VM era or earlier machine era, we used to debug directly on the production environment and even reproduce the problems on it, but in the microservice era, we should develop and debug locally. After all, with thousands of microservices and many instances of each service, it is impractical to run them in the production environment, so how to develop and debug locally? I believe templates also need to provide the corresponding capabilities.</li></ol><p name="3be1" id="3be1" class="graf graf--p graf-after--li">In fact, all these items are closely related to organizational specifications or team practices, so each different organization should have a service template of its own, and there may be a corresponding template for each programming language.</p><p name="5fbe" id="5fbe" class="graf graf--p graf-after--p">But the above list is the basic requirements of microservice development, and I will list some more advanced items. However, whether these advanced items are needed depends on the size of the organization and the nature of the service.</p><h3 name="ec65" id="ec65" class="graf graf--h3 graf-after--p"><code class="markup--code markup--h3-code">Nice-to-have</code></h3><p name="9104" id="9104" class="graf graf--p graf-after--h3">In order to build a stable, robust and secure service, there are many items to consider.</p><p name="e52a" id="e52a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Robustness related</em></strong></p><ol class="postList"><li name="8e64" id="8e64" class="graf graf--li graf-after--p"><a href="https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589784%28v=pandp.10%29" data-href="https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589784(v=pandp.10)" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">Circuit breaker</strong></a>: One of the issues we need to consider in a microservice architecture is that when a downstream service fails, it will not cause an avalanche, i.e., a cascade failure. Circuit breaker is a common strategy we use to ensure the system will not crash even if the downstream service fails, please refer to the link for more details.</li><li name="c224" id="c224" class="graf graf--li graf-after--li"><a href="https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589798%28v=pandp.10%29" data-href="https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589798(v=pandp.10)" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">Rate limiter</strong></a>: On the other hand, when our service is faced with a large number of requests, can the service handle it? Some services may rely on external gateways to block excess traffic, but I believe that every service should know its capacity and act on excess traffic, so a rate limiter is a worthy option.</li><li name="84b7" id="84b7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Authenticator</strong>: External communication sessions or JWT tokens, which require specific packages to be installed, and access control for each interface is also a topic that usually requires middlewares or decorators to be added to the API development, which should also be included in the templates. Furthermore, APIs often need to have Role-based access control, which requires domain experts to participate during development.</li></ol><p name="a5fa" id="a5fa" class="graf graf--p graf-after--li">I believe there are many organizations that have a practice of cutting internal and external services over a physical network, so internal services use a full trust model without any authentication or even using unencrypted channels to communicate, which is not really appropriate.</p><p name="6b6b" id="6b6b" class="graf graf--p graf-after--p">In recent years, the concept of <a href="https://www.microsoft.com/en/security/business/zero-trust" data-href="https://www.microsoft.com/en/security/business/zero-trust" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Zero Trust</a> has emerged that any service should have basic authentication capabilities to avoid unexpected access.</p><p name="ac52" id="ac52" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Security related</em></strong></p><p name="61f8" id="61f8" class="graf graf--p graf-after--p">If the service is for external users also need security mechanisms other than authentication, including CSRF and CORS, the details and principles are not the focus of this article, but all these security features should be provided by the service template.</p><ol class="postList"><li name="6a7d" id="6a7d" class="graf graf--li graf-after--p">CSRF</li><li name="9233" id="9233" class="graf graf--li graf-after--li">CORS</li></ol><h3 name="0dd2" id="0dd2" class="graf graf--h3 graf-after--li"><code class="markup--code markup--h3-code">Best-effort</code></h3><p name="7306" id="7306" class="graf graf--p graf-after--h3">In addition to the items listed above, a service usually requires many external dependencies, such as various databases, message queues, and so on. For example, Python with Postgres may be SQLAlchemy and nothing else, and the version number will be fixed.</p><p name="eec6" id="eec6" class="graf graf--p graf-after--p">A complete service template should also include the various drivers used within the organization, although not every service will need to use the full toolset.</p><p name="a879" id="a879" class="graf graf--p graf-after--p">Therefore, some large organizations use scaffolding to allow developers to set options when applying templates, such as whether they need databases, message queues, programming languages, etc.</p><figure name="5617" id="5617" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*Tj9GeemUHzl9Xx8X.png" data-width="942" data-height="884" src="https://cdn-images-1.medium.com/max/800/0*Tj9GeemUHzl9Xx8X.png"><figcaption class="imageCaption"><a href="https://netflixtechblog.com/keystone-real-time-stream-processing-platform-a3ee651812a" data-href="https://netflixtechblog.com/keystone-real-time-stream-processing-platform-a3ee651812a" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://netflixtechblog.com/keystone-real-time-stream-processing-platform-a3ee651812a</a></figcaption></figure><p name="9430" id="9430" class="graf graf--p graf-after--figure">The example above is Netflix’s job generator, NEWT.</p><p name="848e" id="848e" class="graf graf--p graf-after--p">A complete project can be generated with simple commands and interactive options. This is the ultimate in service templates.</p><h3 name="ad88" id="ad88" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="f0d8" id="f0d8" class="graf graf--p graf-after--h3">In this article we have introduced the items needed to build a microservice, which <strong class="markup--strong markup--p-strong">should not be built manually by the developer</strong>, but rather as a turnkey solution. Ideally, the developer should be able to interactively build the entire project in one shot, depending on the requirements.</p><p name="bc3e" id="bc3e" class="graf graf--p graf-after--p">Although we have listed many items, these are actually a checklist of production-ready microservices, compiled from my past experience. If there are items that you are not entirely sure what they mean, I suggest looking at the links in the article or the information in the relevant books. After all, the items listed in this article are not super tricky concepts, but rather design patterns for general purposes.</p><p name="c54a" id="c54a" class="graf graf--p graf-after--p graf--trailing">Of course, if you or your organization has other items in the service templates, feel free to share them with me. I’d be glad to know more about design patterns.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/f1be783c522b"><time class="dt-published" datetime="2023-02-13T01:58:09.764Z">February 13, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/microservices-start-here-chassis-pattern-f1be783c522b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>