<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Message Queue in Redis, Part 2</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Message Queue in Redis, Part 2</h1>
</header>
<section data-field="subtitle" class="p-summary">
Leverage Bull.js to achieve at-least-once guarantee
</section>
<section data-field="body" class="e-content">
<section name="2f7b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6640" id="6640" class="graf graf--h3 graf--leading graf--title">Message Queue in Redis, Part 2</h3><figure name="ca5f" id="ca5f" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*wzEJNGsUN1hOnCvp.jpg" data-width="1774" data-height="1178" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*wzEJNGsUN1hOnCvp.jpg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@davideragusa" data-href="https://unsplash.com/@davideragusa" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Davide Ragusa</a> on <a href="https://unsplash.com/photos/cDwZ40Lj9eo" data-href="https://unsplash.com/photos/cDwZ40Lj9eo" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="c235" id="c235" class="graf graf--p graf-after--figure">A while ago, I mentioned that I’m in a budget-constrained organization, so we can’t afford to use a true message queue. Instead, we have chosen to use a second-best approach to meet our immediate needs and a simple solution to implement, using Redis.</p><p name="3239" id="3239" class="graf graf--p graf-after--p">Nevertheless, there are still <a href="https://selectfrom.dev/message-queue-in-redis-9efe0de2c39c" data-href="https://selectfrom.dev/message-queue-in-redis-9efe0de2c39c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">many different ways to implement</a> Redis as a message broker. At that time, we chose the option which was the fastest to get up and running with the least implementation effort: lists. However, as the system evolved and new feature requests were made, the original solution no longer worked.</p><p name="ffed" id="ffed" class="graf graf--p graf-after--p">The advantages of the list are</p><ol class="postList"><li name="c3a9" id="c3a9" class="graf graf--li graf-after--p">easy to implement</li><li name="7e07" id="7e07" class="graf graf--li graf-after--li">support for consumer groups</li><li name="bab7" id="bab7" class="graf graf--li graf-after--li">the ability to decouple producers and consumers</li></ol><p name="b613" id="b613" class="graf graf--p graf-after--li">The disadvantages are also obvious.</p><ul class="postList"><li name="d113" id="d113" class="graf graf--li graf-after--p">At-most-once guarantee</li></ul><p name="8667" id="8667" class="graf graf--p graf-after--li">Now, we need <em class="markup--em markup--p-em">at-least-once guarantee</em>, and lists don’t cover this need. The <em class="markup--em markup--p-em">Redis Stream</em> mentioned in the previous article was not adopted because of the large implementation effort. So we started looking for a new alternative.</p><h3 name="40b1" id="40b1" class="graf graf--h3 graf-after--p"><a href="https://github.com/OptimalBits/bull" data-href="https://github.com/OptimalBits/bull" class="markup--anchor markup--h3-anchor" rel="noopener" target="_blank">Bull.js</a></h3><p name="7d2d" id="7d2d" class="graf graf--p graf-after--h3">After some comparisons, we finally chose <em class="markup--em markup--p-em">Bull.js</em>.</p><p name="bd59" id="bd59" class="graf graf--p graf-after--p">The reasons are as follows.</p><ol class="postList"><li name="315b" id="315b" class="graf graf--li graf-after--p">support <em class="markup--em markup--li-em">at-least-once guarantee</em>.</li><li name="8c8c" id="8c8c" class="graf graf--li graf-after--li">it has a lower implementation effort and provides many monitoring tools, e.g., <a href="https://github.com/UpHabit/bull_exporter" data-href="https://github.com/UpHabit/bull_exporter" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Bull Exporter</a>.</li><li name="7122" id="7122" class="graf graf--li graf-after--li">full-featured, including retry, time delay, etc.</li><li name="7ffc" id="7ffc" class="graf graf--li graf-after--li">even support rate limit.</li></ol><p name="09db" id="09db" class="graf graf--p graf-after--li">However, in the working process, I have to say that the official document is not detailed enough and it took us some time to try it successfully. In this article I will show the two most important issues we encountered and explain the solutions.</p><h3 name="6e0e" id="6e0e" class="graf graf--h3 graf-after--p">Redis Cluster</h3><p name="a2e0" id="a2e0" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Bull</em> is supported for Redis clusters. Unfortunately, the description is scattered in several places in the document.</p><ul class="postList"><li name="dcba" id="dcba" class="graf graf--li graf-after--p"><a href="https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#queue" data-href="https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#queue" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Queue Constructor</a></li><li name="9f55" id="9f55" class="graf graf--li graf-after--li"><a href="https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#redis-cluster" data-href="https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#redis-cluster" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Redis Cluster Config</a></li></ul><p name="5a56" id="5a56" class="graf graf--p graf-after--li">First, the description from the constructor’s document needs to provide the parameter <code class="markup--code markup--p-code">createClient</code>, and the rule is</p><blockquote name="8323" id="8323" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">(type: ‘client’ | ‘subscriber’ | ‘bclient’, config?: Redis.RedisOptions): Redis.Redis | Redis.Cluster;</em></blockquote><p name="a184" id="a184" class="graf graf--p graf-after--blockquote"><code class="markup--code markup--p-code">Redis.Redis</code> and <code class="markup--code markup--p-code">Redis.Cluster</code> at the end of the rule actually refer to the <a href="https://github.com/luin/ioredis" data-href="https://github.com/luin/ioredis" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ioredis</a> constructors, so to set them up, we must use the ioredis constructors.</p><pre name="da2d" id="da2d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const Redis = require(&quot;ioredis&quot;);<br>Redis.Redis<br>Redis.Cluster</code></pre><p name="441a" id="441a" class="graf graf--p graf-after--pre">Even so, I don’t understand what kind of format <code class="markup--code markup--p-code">createClient</code> needs to provide, is it an object? What are the keys to <code class="markup--code markup--p-code">Redis.Redis</code> and <code class="markup--code markup--p-code">Redis.Cluster</code>?</p><p name="04ee" id="04ee" class="graf graf--p graf-after--p">Finally, I found out from another section of the document, <a href="https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#reusing-redis-connections" data-href="https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#reusing-redis-connections" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Reusing Redis Connections</a> I realized that it was a function. Anyway, put the pieces together.</p><pre name="9706" id="9706" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const Redis = require(&#39;ioredis&#39;);<br>let client;<br>let subscriber;</code></pre><pre name="b440" id="b440" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const opts = {<br>  // redisOpts here will contain at least a property of connectionName which will identify the queue based on its name<br>  createClient: function (type, redisOpts) {<br>    switch (type) {<br>      case &#39;client&#39;:<br>        if (!client) {<br>          client = new Redis.Cluster(REDIS_URL, redisOpts);<br>        }<br>        return client;<br>      case &#39;subscriber&#39;:<br>        if (!subscriber) {<br>          subscriber = new Redis.Cluster(REDIS_URL, redisOpts);<br>        }<br>        return subscriber;<br>      case &#39;bclient&#39;:<br>        return new Redis.Cluster(REDIS_URL, redisOpts);<br>      default:<br>        throw new Error(&#39;Unexpected connection type: &#39;, type);<br>    }<br>  },<br>  prefix: &#39;{myprefix}&#39;<br>}</code></pre><pre name="2c22" id="2c22" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const queueFoo = new Queue(&#39;foobar&#39;, opts);</code></pre><p name="8484" id="8484" class="graf graf--p graf-after--pre">In this way, Redis clusters can be used as brokers.</p><h3 name="d96b" id="d96b" class="graf graf--h3 graf-after--p">Memory Leakage</h3><p name="fa4a" id="fa4a" class="graf graf--p graf-after--h3">Once we got over the cluster issue, we pulled <em class="markup--em markup--p-em">Bull</em> online and started testing. Then we ran into a serious problem where the underlying Redis started leaking memory.</p><figure name="5425" id="5425" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*R2ImsAsRSRFm0ixO.png" data-width="2528" data-height="856" src="https://cdn-images-1.medium.com/max/800/0*R2ImsAsRSRFm0ixO.png"><figcaption class="imageCaption">Fig 1. Memory Usage</figcaption></figure><p name="3937" id="3937" class="graf graf--p graf-after--figure">As you can see from the figure, Redis memory usage has been skyrocketing since it was enabled.</p><p name="5111" id="5111" class="graf graf--p graf-after--p">So we took a closer look at the document to find out what we missed, and finally found a hint in the <a href="https://optimalbits.github.io/bull/" data-href="https://optimalbits.github.io/bull/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">tutorial</a>.</p><figure name="8a02" id="8a02" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*yauK1vgMO0y-BLRU.png" data-width="602" data-height="182" src="https://cdn-images-1.medium.com/max/800/0*yauK1vgMO0y-BLRU.png"><figcaption class="imageCaption">A Job’s Lifecycle</figcaption></figure><p name="fbc5" id="fbc5" class="graf graf--p graf-after--figure">A job begins as <code class="markup--code markup--p-code">Job Added</code> and ends up as <code class="markup--code markup--p-code">Job Finished</code>, regardless of whether it succeeds or fails. In other words, as soon as the job enters Redis, it stays there, regardless of whether it succeeds or fails. How do we solve this?</p><p name="377d" id="377d" class="graf graf--p graf-after--p">Specify the parameters <code class="markup--code markup--p-code">removeOnComplete</code> and <code class="markup--code markup--p-code">removeOnFail</code> in <a href="https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#queueadd" data-href="https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#queueadd" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">add</a> to ensure jobs do not stay in the last finish state. I believe that <code class="markup--code markup--p-code">removeOnComplete</code> can definitely be set, but <code class="markup--code markup--p-code">removeOnFail</code> depends on the needs of each user, e.g., whether they want a failure count, whether they want a manual recovery from failure, etc. In our case, we don’t need to keep the job even if it fails, so both parameters are <code class="markup--code markup--p-code">true</code>.</p><p name="a61a" id="a61a" class="graf graf--p graf-after--p">What about the jobs left online? <em class="markup--em markup--p-em">Bull</em> also provides a way to <a href="https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#queueclean" data-href="https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#queueclean" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">clean jobs</a>.</p><pre name="fa33" id="fa33" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">//cleans all jobs that completed over 5 seconds ago.<br>await queue.clean(5000);<br>//clean all jobs that failed over 10 seconds ago.<br>await queue.clean(10000, &#39;failed&#39;);</code></pre><p name="00a0" id="00a0" class="graf graf--p graf-after--pre">After running online, you will see an extremely significant drop in usage.</p><figure name="fe47" id="fe47" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*6AmYB1IKIkF7zya0.png" data-width="1897" data-height="858" src="https://cdn-images-1.medium.com/max/800/0*6AmYB1IKIkF7zya0.png"><figcaption class="imageCaption">Fig 2. Memory Usage after Resolution</figcaption></figure><p name="7952" id="7952" class="graf graf--p graf-after--figure">The first half remains horizontal because we have already added <code class="markup--code markup--p-code">removeOnComplete</code> and <code class="markup--code markup--p-code">removeOnFail</code>, so no more increases are made. The vertical line in the middle is the process of <code class="markup--code markup--p-code">clean</code>.</p><p name="0c44" id="0c44" class="graf graf--p graf-after--p">It is worth mentioned that the <code class="markup--code markup--p-code">clean</code> process locks the entire message queue, so it may affect the online functions and is not recommended to perform it under production environment. The duration of the lock depends on the number of jobs to be cleaned.</p><h3 name="b195" id="b195" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="89a0" id="89a0" class="graf graf--p graf-after--h3">I always talked about the evolution of systems. As you should have noticed from my previous articles, in a limited organization, we do not always have enough manpower, budget or even knowledge to build the perfect system, or to be more precise, no system is perfect.</p><p name="88c9" id="88c9" class="graf graf--p graf-after--p">Every time we design a system, we choose the relatively acceptable solution among many factors, which means we have to face the potential problems. For me, I always take the most achievable implementation, but with the understanding that such choices are not static and retain the flexibility to meet future requirements.</p><p name="83f6" id="83f6" class="graf graf--p graf-after--p">For many people, the replacement of the message queue is a very huge exercise. But for my organization, it’s a simple implementation by a few people, and then it’s done. The reason why I always mention domain-driven design and decoupling is to make it easier to do system evolution when needed.</p><p name="7ecd" id="7ecd" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Bull</em> currently meets all of our needs, is reliable enough, and even offers a monitoring solution. I believe we will probably be able to stop worrying about message queues for a long time.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/61c0d22735fe"><time class="dt-published" datetime="2022-06-20T01:26:55.733Z">June 20, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/message-queue-in-redis-part-2-61c0d22735fe" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>