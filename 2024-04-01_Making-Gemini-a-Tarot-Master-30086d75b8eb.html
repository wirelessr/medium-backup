<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Making Gemini a Tarot Master</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Making Gemini a Tarot Master</h1>
</header>
<section data-field="subtitle" class="p-summary">
Quickly build a RAG application with Streamlit and LangChain
</section>
<section data-field="body" class="e-content">
<section name="1516" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e303" id="e303" class="graf graf--h3 graf--leading graf--title">Making Gemini a Tarot Master</h3><h4 name="84d0" id="84d0" class="graf graf--h4 graf-after--h3 graf--subtitle">Quickly build a RAG application with Streamlit and LangChain</h4><figure name="a539" id="a539" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*DWgc5anGVJRcVN4k" data-width="1000" data-height="667" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*DWgc5anGVJRcVN4k"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@vivalunastudios" data-href="https://unsplash.com/@vivalunastudios" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Viva Luna Studios</a> on <a href="https://unsplash.com/photos/yellow-green-and-red-floral-print-cards-y3qrbAgm7q8" data-href="https://unsplash.com/photos/yellow-green-and-red-floral-print-cards-y3qrbAgm7q8" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="3216" id="3216" class="graf graf--p graf-after--figure">Nowadays, AI resources are quite available, which makes it much easier to implement RAG (retrieval-augmented generation) applications.</p><p name="5f8b" id="5f8b" class="graf graf--p graf-after--p">In order for me to keep writing programs and not to be out of sync with the technology for too long, I’m going to use <code class="markup--code markup--p-code">LangChain</code> to implement a Tarot bot.</p><p name="2615" id="2615" class="graf graf--p graf-after--p">I chose <code class="markup--code markup--p-code">LangChain</code> because it has an active ecosystem and supports multi-model design, so it&#39;s easy to modify it according to the needs. For example, I&#39;ll be using <code class="markup--code markup--p-code">Gemini Pro</code> as my LLM this time, but it&#39;s easy to switch to <code class="markup--code markup--p-code">ChatGPT</code> or even the free <code class="markup--code markup--p-code">Ollama</code>.</p><p name="5503" id="5503" class="graf graf--p graf-after--p">The whole process is simple.</p><ol class="postList"><li name="a1d1" id="a1d1" class="graf graf--li graf-after--p">Crawl through the web to retrieve a lot of Tarot knowledge and examples.</li><li name="b05e" id="b05e" class="graf graf--li graf-after--li">Convert these data into vectors and write them to vector storage.</li><li name="fa64" id="fa64" class="graf graf--li graf-after--li">Build a Web App that can draw cards and present them.</li><li name="282c" id="282c" class="graf graf--li graf-after--li">Feed the drawn cards to AI for interpretation based on the big data.</li></ol><p name="fa9a" id="fa9a" class="graf graf--p graf-after--li">The <a href="https://rider-waite-tarot.streamlit.app/" data-href="https://rider-waite-tarot.streamlit.app/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">final result</a> will be as follows.</p><figure name="46d1" id="46d1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*8oxm1JCCLCMBOfLA.png" data-width="742" data-height="1336" src="https://cdn-images-1.medium.com/max/800/0*8oxm1JCCLCMBOfLA.png"><figcaption class="imageCaption"><a href="https://rider-waite-tarot.streamlit.app/" data-href="https://rider-waite-tarot.streamlit.app/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://rider-waite-tarot.streamlit.app/</a></figcaption></figure><blockquote name="74bb" id="74bb" class="graf graf--blockquote graf-after--figure"><em class="markup--em markup--blockquote-em">Apologies for the Chinese. I’ve been studying Tarot lately, so I’m more likely to get the meaning right if it is in Chinese.</em></blockquote><p name="c637" id="c637" class="graf graf--p graf-after--blockquote">This layout has a button to draw cards. When the button is pressed, three cards are turned over, each with an upright meaning and a reversed meaning. Finally Gemini will try to give a full explanation of the meaning of each card in context.</p><p name="8357" id="8357" class="graf graf--p graf-after--p">Let’s get our hands dirty.</p><h3 name="16e9" id="16e9" class="graf graf--h3 graf-after--p">Preconditions</h3><p name="2987" id="2987" class="graf graf--p graf-after--h3">Let’s start by installing the packages that will be used.</p><blockquote name="e46c" id="e46c" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">pip install langchain-google-genai langchain pymongo</em></blockquote><h3 name="2a1f" id="2a1f" class="graf graf--h3 graf-after--blockquote">Implementing a web crawler</h3><p name="0f13" id="0f13" class="graf graf--p graf-after--h3">Since web crawlers are not the focus of this article, and web crawlers involve finding targets and parsing web content, let me get directly to the heart of the RAG problem.</p><blockquote name="f0a8" id="f0a8" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">How to put the material into vector storage?</em></blockquote><p name="afe3" id="afe3" class="graf graf--p graf-after--blockquote">First, we make a basic declaration about which data store we want to use and what kind of embedding we want to use to convert the text into vectors.</p><p name="9364" id="9364" class="graf graf--p graf-after--p">In this example, I’ve chosen to use <a href="https://www.mongodb.com/" data-href="https://www.mongodb.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">MongoDB Atlas</a>, so let’s get the settings right.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="ad07" id="ad07" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">from</span> pymongo <span class="hljs-keyword">import</span> MongoClient<br /><br /><span class="hljs-comment"># MONGODB_ATLAS_CLUSTER_URI will contain credentials, please modify it accordingly.</span><br />client = MongoClient(MONGODB_ATLAS_CLUSTER_URI)<br />DB_NAME = <span class="hljs-string">&quot;langchain_db&quot;</span><br />COLLECTION_NAME = <span class="hljs-string">&quot;test&quot;</span><br />ATLAS_VECTOR_SEARCH_INDEX_NAME = <span class="hljs-string">&quot;index_name&quot;</span><br />MONGODB_COLLECTION = client[DB_NAME][COLLECTION_NAME]</span></pre><p name="7a45" id="7a45" class="graf graf--p graf-after--pre">Next is Gemini’s own embedding.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="bbb5" id="bbb5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> os<br /><span class="hljs-keyword">from</span> langchain_google_genai <span class="hljs-keyword">import</span> GoogleGenerativeAIEmbeddings<br /><br /><span class="hljs-comment"># GEMINI_PRO_API_TOKEN is a credential, please modify it accordingly.</span><br />os.environ[<span class="hljs-string">&quot;GOOGLE_API_KEY&quot;</span>] = GEMINI_PRO_API_TOKEN<br />embeddings = GoogleGenerativeAIEmbeddings(model=<span class="hljs-string">&quot;models/embedding-001&quot;</span>)</span></pre><p name="584c" id="584c" class="graf graf--p graf-after--pre">Before writing to storage, the data needs to be pre-processed. Assuming all the data is in JSON format, we need to split the JSON into smaller chunks to make it easier to use.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="ddf6" id="ddf6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> RecursiveJsonSplitter<br /><br />splitter = RecursiveJsonSplitter(max_chunk_size=<span class="hljs-number">300</span>)<br /><span class="hljs-comment"># json_data is the data source in JSON format</span><br />json_chunks = splitter.split_json(json_data=json_data)<br /><span class="hljs-comment"># docs will be stored</span><br />docs = splitter.create_documents(texts=[json_data])</span></pre><p name="d306" id="d306" class="graf graf--p graf-after--pre">Once everything is ready, it’s just time to convert the data into vectors and write them to MongoDB.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="9aa4" id="9aa4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">from</span> langchain_community.vectorstores <span class="hljs-keyword">import</span> MongoDBAtlasVectorSearch<br /><br /><span class="hljs-comment"># insert the documents in MongoDB Atlas with their embedding</span><br />vector_orig = MongoDBAtlasVectorSearch.from_documents(<br />    documents=docs,<br />    embedding=embeddings,<br />    collection=MONGODB_COLLECTION,<br />    index_name=ATLAS_VECTOR_SEARCH_INDEX_NAME,<br />)</span></pre><p name="dff3" id="dff3" class="graf graf--p graf-after--pre">Depending on the state of the crawler and the results, this stage can take a lot of time, both for retrieving data and for writing to storage.</p><h3 name="017a" id="017a" class="graf graf--h3 graf-after--p">Web App implementation</h3><p name="9953" id="9953" class="graf graf--p graf-after--h3">It’s not difficult to build a Web App quickly, as I’ve introduced in my <a href="https://medium.com/stackademic/simplify-web-app-development-code-lite-create-big-6f87e21ea71c" data-href="https://medium.com/stackademic/simplify-web-app-development-code-lite-create-big-6f87e21ea71c" class="markup--anchor markup--p-anchor" target="_blank">previous article</a> about Streamlit.</p><p name="03b7" id="03b7" class="graf graf--p graf-after--p">Therefore, I will only talk about two key points this time.</p><p name="db03" id="db03" class="graf graf--p graf-after--p">There are many spreads in Tarot, each spread has different layouts and corresponding Gemini prompts, so we need to prepare a detailed explanation of the spreads for Gemini to know how to interpret them.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="8e81" id="8e81" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span> spread_type == <span class="hljs-string">&#x27;Time Flow&#x27;</span>:<br />    spread = init_time_flow_spread()<br />    sys_prompt = <span class="hljs-string">&#x27;&#x27;&#x27;<br />This is a Time Flow Tarot spread where three cards are drawn to represent the past, present and future.<br /><br />Based on the user&#x27;s question, the meaning of the three cards drawn by the user, and the following {context}, a reasonable explanation is given.<br />    &#x27;&#x27;&#x27;</span></span></pre><p name="9b0a" id="9b0a" class="graf graf--p graf-after--pre">The tarot cards are drawn in upright and reversed positions, so we can’t just use the file paths in <code class="markup--code markup--p-code">st.image</code>, we need to read out the files and process them and use <code class="markup--code markup--p-code">numpy.ndarray</code> as the parameter.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="9ca5" id="9ca5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">open_image</span>(<span class="hljs-params">fp</span>):<br />    <span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br />    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br /><br />    image = Image.<span class="hljs-built_in">open</span>(fp)<br />    image_array = np.array(image)<br />    flipped_image = image.transpose(Image.ROTATE_180)<br />    flipped_image_array = np.array(flipped_image)<br />    <span class="hljs-keyword">return</span> image_array, flipped_image_array</span></pre><h3 name="b601" id="b601" class="graf graf--h3 graf-after--pre">Integrate with Gemini Pro</h3><p name="da70" id="da70" class="graf graf--p graf-after--h3">For Gemini to learn about Tarot, the results of the previous crawler are required, so the first step is to make Gemini able to retrieve the vectors we have stored, i.e. the R of the RAG.</p><p name="139c" id="139c" class="graf graf--p graf-after--p">We’ll use the mentioned embedding and the MongoDB settings.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="795f" id="795f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">vector_search = MongoDBAtlasVectorSearch.from_connection_string(<br />    MONGODB_ATLAS_CLUSTER_URI,<br />    DB_NAME + <span class="hljs-string">&quot;.&quot;</span> + COLLECTION_NAME,<br />    embeddings,<br />    index_name=ATLAS_VECTOR_SEARCH_INDEX_NAME,<br />)<br />retriever = vector_search.as_retriever()</span></pre><p name="14b0" id="14b0" class="graf graf--p graf-after--pre">Next we need to build the LLM using Gemini Pro.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="af7e" id="af7e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">from</span> langchain_google_genai <span class="hljs-keyword">import</span> ChatGoogleGenerativeAI<br /><br />llm = ChatGoogleGenerativeAI(model=<span class="hljs-string">&quot;gemini-pro&quot;</span>, convert_system_message_to_human=<span class="hljs-literal">True</span>)</span></pre><p name="748c" id="748c" class="graf graf--p graf-after--pre">Finally, the whole chain is connected.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="9547" id="9547" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">from</span> langchain.chains.combine_documents <span class="hljs-keyword">import</span> create_stuff_documents_chain<br /><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> create_retrieval_chain<br /><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br /><br /><span class="hljs-comment"># sys_promopt is based on Tarot&#x27;s Spreads.</span><br />prompt = ChatPromptTemplate.from_messages([<br />    (<span class="hljs-string">&#x27;system&#x27;</span>, sys_prompt),<br />    (<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;Question: {input}&#x27;</span>),<br />])<br />document_chain = create_stuff_documents_chain(llm, prompt)<br />retrieval_chain = create_retrieval_chain(retriever, document_chain)</span></pre><p name="74cb" id="74cb" class="graf graf--p graf-after--pre">With the whole chain, we can ask Gemini to start his show.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="d0eb" id="d0eb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># input_text is the three cards drawn by the user.</span><br />response = retrieval_chain.invoke({<br />    <span class="hljs-string">&#x27;input&#x27;</span>: input_text,<br />    <span class="hljs-string">&#x27;context&#x27;</span>: []<br />})</span></pre><h3 name="c8da" id="c8da" class="graf graf--h3 graf-after--pre">Conclusion</h3><p name="8e3e" id="8e3e" class="graf graf--p graf-after--h3">This is the simplest example of a RAG implementation, applying all RAG elements, and each piece can actually be modified as needed. The domain knowledge of application is the results from crawlers, and this application just uses the information to answer questions.</p><p name="97ea" id="97ea" class="graf graf--p graf-after--p">At the moment, I don’t intend Gemini to act like a real soothsayer with the user. Instead, Gemini will provide a one-time recommendation. For me, Tarot is a tool for inner dialogue, not for seeking magic.</p><p name="655d" id="655d" class="graf graf--p graf-after--p">The whole project is on Github.</p><div name="463b" id="463b" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/wirelessr/streamlit-tarot/blob/master/streamlit_app.py" data-href="https://github.com/wirelessr/streamlit-tarot/blob/master/streamlit_app.py" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/wirelessr/streamlit-tarot/blob/master/streamlit_app.py"><strong class="markup--strong markup--mixtapeEmbed-strong">streamlit-tarot/streamlit_app.py at master · wirelessr/streamlit-tarot</strong><br><em class="markup--em markup--mixtapeEmbed-em">The Rider-Waite Tarot Deck. Contribute to wirelessr/streamlit-tarot development by creating an account on GitHub.</em>github.com</a><a href="https://github.com/wirelessr/streamlit-tarot/blob/master/streamlit_app.py" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="297565e3261305e198ac7cce5c9cd01e" data-thumbnail-img-id="0*n29AT4XU2A6A4kQj" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*n29AT4XU2A6A4kQj);"></a></div><p name="d1bb" id="d1bb" class="graf graf--p graf-after--mixtapeEmbed">Although this application has both UI and AI integration, the total number of code lines is only 150. I have to say, both Streamlit and LangChain are really great at packaging complex implementations in abstract and sophisticated interfaces, so that users can easily write functionality instead of dealing with miscellaneous things.</p><p name="d2e7" id="d2e7" class="graf graf--p graf-after--p">Here are some of the LangChain materials I have references to.</p><ul class="postList"><li name="5d13" id="5d13" class="graf graf--li graf-after--p">gemini-pro: <a href="https://python.langchain.com/docs/integrations/chat/google_generative_ai" data-href="https://python.langchain.com/docs/integrations/chat/google_generative_ai" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://python.langchain.com/docs/integrations/chat/google_generative_ai</a></li><li name="6da6" id="6da6" class="graf graf--li graf-after--li">gemini-embedding: <a href="https://python.langchain.com/docs/integrations/text_embedding/google_generative_ai" data-href="https://python.langchain.com/docs/integrations/text_embedding/google_generative_ai" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://python.langchain.com/docs/integrations/text_embedding/google_generative_ai</a></li><li name="0a57" id="0a57" class="graf graf--li graf-after--li">mongo-atlas-vector: <a href="https://python.langchain.com/docs/integrations/vectorstores/mongodb_atlas" data-href="https://python.langchain.com/docs/integrations/vectorstores/mongodb_atlas" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://python.langchain.com/docs/integrations/vectorstores/mongodb_atlas</a></li><li name="d4a9" id="d4a9" class="graf graf--li graf-after--li graf--trailing">json-splitter: <a href="https://python.langchain.com/docs/modules/data_connection/document_transformers/recursive_json_splitter" data-href="https://python.langchain.com/docs/modules/data_connection/document_transformers/recursive_json_splitter" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://python.langchain.com/docs/modules/data_connection/document_transformers/recursive_json_splitter</a></li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/30086d75b8eb"><time class="dt-published" datetime="2024-04-01T01:23:09.726Z">April 1, 2024</time></a>.</p><p><a href="https://medium.com/@lazypro/making-gemini-a-tarot-master-30086d75b8eb" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>