<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Playing PyFlink in a Nutshell</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Playing PyFlink in a Nutshell</h1>
</header>
<section data-field="subtitle" class="p-summary">
Understanding the power of PyFlink
</section>
<section data-field="body" class="e-content">
<section name="1344" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3926" id="3926" class="graf graf--h3 graf--leading graf--title">Playing PyFlink in a Nutshell</h3><h4 name="8406" id="8406" class="graf graf--h4 graf-after--h3 graf--subtitle">Understanding the power of PyFlink</h4><figure name="91c2" id="91c2" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*93z652Elyzx7s7Or" data-width="1000" data-height="750" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*93z652Elyzx7s7Or"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@artturijalli" data-href="https://unsplash.com/@artturijalli" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Artturi Jalli</a> on <a href="https://unsplash.com/photos/g5_rxRjvKmg" data-href="https://unsplash.com/photos/g5_rxRjvKmg" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="2992" id="2992" class="graf graf--p graf-after--figure">Last week, we introduced <a href="https://blog.devgenius.io/playing-pyflink-from-scratch-65c18908c366" data-href="https://blog.devgenius.io/playing-pyflink-from-scratch-65c18908c366" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">how to build a PyFlink experiment environment</a>, and today we will use that experimental environment to explore the possibilities of PyFlink.</p><p name="0274" id="0274" class="graf graf--p graf-after--p">PyFlink is a general purpose streaming framework and abstracts streaming processing into four levels.</p><ol class="postList"><li name="dfa9" id="dfa9" class="graf graf--li graf-after--p">SQL</li><li name="225b" id="225b" class="graf graf--li graf-after--li">Table API</li><li name="d135" id="d135" class="graf graf--li graf-after--li">DataStream</li><li name="e294" id="e294" class="graf graf--li graf-after--li">Stateful Stream Processing</li></ol><p name="131b" id="131b" class="graf graf--p graf-after--li">The closer to the bottom the more flexibility is available, but also requiring writing more code. I would like to be able to do almost everything with PyFlink, so let’s get started with the basic concepts of PyFlink development from a DataStream perspective.</p><p name="ba99" id="ba99" class="graf graf--p graf-after--p">This article will introduce a few key points of PyFlink development with simple descriptions and examples, but will not mention the implementation details of Flink.</p><h3 name="15e0" id="15e0" class="graf graf--h3 graf-after--p">DataStream Concept</h3><p name="8de6" id="8de6" class="graf graf--p graf-after--h3">The development of DataStream will follow the following process.</p><figure name="b822" id="b822" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*scE7_-sNF8-KvDa3x6WXOA.png" data-width="792" data-height="124" src="https://cdn-images-1.medium.com/max/800/1*scE7_-sNF8-KvDa3x6WXOA.png"></figure><p name="8348" id="8348" class="graf graf--p graf-after--figure">Basically, we get streaming data from a source, process it, and output it to somewhere.</p><p name="2edc" id="2edc" class="graf graf--p graf-after--p">This is expressed in PyFlink as follows.</p><pre name="3300" id="3300" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">ds = env.add_source(kafka_consumer)<br>ds = ds.map(transform, output_type=output_type_info)<br>ds.add_sink(kafka_producer)</code></pre><p name="77e0" id="77e0" class="graf graf--p graf-after--pre">Source and sink are easy to understand, but the key is what processing can be used?</p><p name="7038" id="7038" class="graf graf--p graf-after--p">In the official document there is a list of all available operations.<br><a href="https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/operators/overview/" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/operators/overview/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/operators/overview/</a></p><p name="a013" id="a013" class="graf graf--p graf-after--p">For the above example, we used <code class="markup--code markup--p-code">map</code>.</p><p name="3f0a" id="3f0a" class="graf graf--p graf-after--p">There is also an example of the operation in the Flink artifact, the code is placed at <code class="markup--code markup--p-code">./examples/python/datastream/basic_operations.py</code>。</p><h3 name="afc8" id="afc8" class="graf graf--h3 graf-after--p">What is the difference between <code class="markup--code markup--h3-code">map</code> and <code class="markup--code markup--h3-code">flat_map</code>?</h3><p name="841b" id="841b" class="graf graf--p graf-after--h3">There are two similar operations in the operation list, <code class="markup--code markup--p-code">map</code> and <code class="markup--code markup--p-code">flat_map</code>, what is the difference between these two operations?</p><p name="0269" id="0269" class="graf graf--p graf-after--p">The difference is in the number of generated outputs.</p><p name="8785" id="8785" class="graf graf--p graf-after--p">In the case of <code class="markup--code markup--p-code">map</code>, an input event generates one and only one output event; on the other hand, <code class="markup--code markup--p-code">flat_map</code> can generate zero to many output events.</p><p name="80b6" id="80b6" class="graf graf--p graf-after--p">Let’s use the actual code as an example.</p><pre name="75c8" id="75c8" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">def map_transform(i: int):<br>  return i * i<br>  <br>def flat_map_transform(i: int):<br>  for idx in range(i):<br>    yield idx<br>    <br>ds.map(map_transform, output_type=Types.INT())<br>ds.flat_map(flat_map_transform, output_type=Types.INT())</code></pre><p name="da30" id="da30" class="graf graf--p graf-after--pre">In this example, <code class="markup--code markup--p-code">map</code> squares all the input integers and passes them out, one input corresponds to one output. However, <code class="markup--code markup--p-code">flat_map</code> outputs a series of events, and the number of output events is determined by the input events.</p><p name="bf93" id="bf93" class="graf graf--p graf-after--p">If the input is <code class="markup--code markup--p-code">0</code>, then <code class="markup--code markup--p-code">yield</code> of <code class="markup--code markup--p-code">flat_map</code> will not be triggered, and nothing will be generated.</p><h3 name="4ccc" id="4ccc" class="graf graf--h3 graf-after--p">State</h3><p name="52e7" id="52e7" class="graf graf--p graf-after--h3">State is the best feature of Flink.</p><p name="cbd9" id="cbd9" class="graf graf--p graf-after--p">Although we have various operations available, many of them actually produce results based on previous events. How do we keep the previous events? This is where <code class="markup--code markup--p-code">State</code> comes in.</p><p name="cbbc" id="cbbc" class="graf graf--p graf-after--p">State can be considered as an internal storage in order to persist data, and the size of State is the summary of every node’s memory.</p><p name="d7ad" id="d7ad" class="graf graf--p graf-after--p">Nevertheless, State can be persisted in a durable storage like <code class="markup--code markup--p-code">RocksDB</code> to gain more scalability.</p><pre name="d92d" id="d92d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">from pyflink.datastream import StreamExecutionEnvironment, EmbeddedRocksDBStateBackend</code></pre><pre name="081d" id="081d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">env = StreamExecutionEnvironment.get_execution_environment()<br>env.set_state_backend(EmbeddedRocksDBStateBackend())</code></pre><p name="b980" id="b980" class="graf graf--p graf-after--pre">To use State in Flink framework, there are two key points worth noting.</p><ol class="postList"><li name="e8cb" id="e8cb" class="graf graf--li graf-after--p">State can only be used in “Keyed Data Stream”.</li><li name="bfe1" id="bfe1" class="graf graf--li graf-after--li">State is based on operations and not able to share with others.</li></ol><p name="fb50" id="fb50" class="graf graf--p graf-after--li">All available States and the reference are listing below.<br><a href="https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/fault-tolerance/state/" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/fault-tolerance/state/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/fault-tolerance/state/</a></p><p name="bd76" id="bd76" class="graf graf--p graf-after--p">In fact, an example at <code class="markup--code markup--p-code">./examples/python/datastream/state_access.py</code> also provides a good demonstration.</p><h3 name="c7bc" id="c7bc" class="graf graf--h3 graf-after--p">Connect (Shared State)</h3><p name="493b" id="493b" class="graf graf--p graf-after--h3">As mentioned in the previous section, states are operation-based and cannot be shared, but sometimes we indeed need to combine two different streaming states, so what should we do?</p><p name="6e8c" id="6e8c" class="graf graf--p graf-after--p">Fortunately, Flink provides <code class="markup--code markup--p-code">connect</code> to enable us to share the states of different streams within the same job.</p><p name="4784" id="4784" class="graf graf--p graf-after--p">By using <code class="markup--code markup--p-code">connect</code>, we can combine different streams and use the same operation, so that we can share the same operation state.</p><p name="b805" id="b805" class="graf graf--p graf-after--p">To be more concrete, let me provide a practical example. There are two streams.</p><ul class="postList"><li name="3e98" id="3e98" class="graf graf--li graf-after--p">Stream 1 provides a mapping between the item identifiers and the item names. When the item name changes, an event <code class="markup--code markup--li-code">(item_id, item_name)</code> is sent into the stream, so we just need to save the latest status.</li><li name="8de4" id="8de4" class="graf graf--li graf-after--li">Stream 2 is the transaction history, including which item was sold and the number of items ordered.</li></ul><p name="4d45" id="4d45" class="graf graf--p graf-after--li">What we want to do is, when any purchase is entered, then we have to sum it up and append the latest item name to it.</p><p name="e433" id="e433" class="graf graf--p graf-after--p">This is the classic streaming enrichment pattern, and I explained the enrichment design pattern in detail in <a href="https://betterprogramming.pub/design-pattern-of-streaming-enrichment-17a9eb065eca" data-href="https://betterprogramming.pub/design-pattern-of-streaming-enrichment-17a9eb065eca" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">my previous article</a>.</p><p name="ef34" id="ef34" class="graf graf--p graf-after--p">Here is the full program example.</p><figure name="899c" id="899c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/wirelessr/f1f87e1164b9d8e07507bfbcaaa89c33.js"></script></figure><p name="875b" id="875b" class="graf graf--p graf-after--figure">In <code class="markup--code markup--p-code">flat_map1</code> the stream 1 is handled, that is to say, the mapping of item number and item name is maintained, so this stream does not need to generate output events.</p><p name="cdc9" id="cdc9" class="graf graf--p graf-after--p">The core of the whole application is in <code class="markup--code markup--p-code">flat_map2</code>. We take the accumulated quantity from <code class="markup--code markup--p-code">self.cnt_state</code> and not only add the new quantity but also update it back to the state. Then, in the output process, we take the corresponding name from <code class="markup--code markup--p-code">self.state</code> and finally we output the enriched events.</p><h3 name="5dcf" id="5dcf" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="eb25" id="eb25" class="graf graf--p graf-after--h3">In the last example, we demonstrate the operation, state, and merging of streams.</p><p name="0dd8" id="0dd8" class="graf graf--p graf-after--p">From this example, we can easily understand that Flink can do anything we want as long as we write the program correctly.</p><p name="f780" id="f780" class="graf graf--p graf-after--p graf--trailing">We will continue to do some experiments on stream processing and will continue to publish any further updates if there are any.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/3abd16467677"><time class="dt-published" datetime="2022-10-24T01:52:55.231Z">October 24, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/playing-pyflink-in-a-nutshell-3abd16467677" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>