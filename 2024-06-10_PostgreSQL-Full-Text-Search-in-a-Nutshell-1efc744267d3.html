<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>PostgreSQL Full-Text Search in a Nutshell</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">PostgreSQL Full-Text Search in a Nutshell</h1>
</header>
<section data-field="subtitle" class="p-summary">
Discover how to implement efficient and powerful text search capabilities in your PostgreSQL database
</section>
<section data-field="body" class="e-content">
<section name="9fff" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="57fe" id="57fe" class="graf graf--h3 graf--leading graf--title">PostgreSQL Full-Text Search in a Nutshell</h3><h4 name="7b0e" id="7b0e" class="graf graf--h4 graf-after--h3 graf--subtitle">Discover how to implement efficient and powerful text search capabilities in your PostgreSQL database</h4><figure name="1b5f" id="1b5f" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*2bKENg_xASuLmKBp" data-width="1000" data-height="667" src="https://cdn-images-1.medium.com/max/800/0*2bKENg_xASuLmKBp"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@markuswinkler" data-href="https://unsplash.com/@markuswinkler" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Markus Winkler</a> on <a href="https://unsplash.com/photos/magnifying-glass-on-white-table-afW1hht0NSs" data-href="https://unsplash.com/photos/magnifying-glass-on-white-table-afW1hht0NSs" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="3fd3" id="3fd3" class="graf graf--p graf-after--figure">If you ask me to choose a database for microservices, I would probably say PostgreSQL.</p><p name="bf8a" id="bf8a" class="graf graf--p graf-after--p">On one hand, PostgreSQL is a popular open source database with many mature practices, both on the server side and the client side. On the other hand, PostgreSQL is very “scalable”. Scalability of course includes non-functional requirements such as traffic and data volume, as well as functional requirements such as full-text search.</p><p name="b545" id="b545" class="graf graf--p graf-after--p">In the early stages of planning a microservice, we may not be sure what features it needs to have. I have to say those tutorials always telling us microservices need to have clear boundaries early in design are nonsense.</p><p name="ddc4" id="ddc4" class="graf graf--p graf-after--p">Most of the time, as a microservice goes live, there are more requirements and more iterations, and those requirements don’t care about the boundaries you define at the beginning.</p><p name="d486" id="d486" class="graf graf--p graf-after--p">Full-text search is a good example. In the early days of a service, we might be able to work just fine with a exact match or prefix match of text. Until one day, you get a request. “Hey, let’s add a search feature!”</p><p name="63ed" id="63ed" class="graf graf--p graf-after--p">If the database you chose in the beginning doesn’t have a search function, then that’s a big problem.</p><p name="25a0" id="25a0" class="graf graf--p graf-after--p">I’m sure you wouldn’t introduce a database like Elasticsearch, which specializes in full-text search, for this sudden need. So what to do?</p><p name="eec7" id="eec7" class="graf graf--p graf-after--p">Fortunately, PostgreSQL has a solution.</p><h3 name="9ac0" id="9ac0" class="graf graf--h3 graf-after--p">PostgreSQL Built-In Features</h3><p name="0cf5" id="0cf5" class="graf graf--p graf-after--h3">In the <a href="https://www.postgresql.org/docs/current/textsearch.html" data-href="https://www.postgresql.org/docs/current/textsearch.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">official document</a> there is a large chapter on how to do full-text searching with PostgreSQL.</p><p name="af78" id="af78" class="graf graf--p graf-after--p">Let’s skip all the technical details and go straight to the how-to.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="af9f" id="af9f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> id, title, body, author, created_at, updated_at, published,<br />       ts_rank(tsv, to_tsquery(<span class="hljs-string">&#x27;english&#x27;</span>, <span class="hljs-string">&#x27;excited | trends&#x27;</span>)) <span class="hljs-keyword">AS</span> rank<br /><span class="hljs-keyword">FROM</span> blog_posts<br /><span class="hljs-keyword">WHERE</span> tsv @@ to_tsquery(<span class="hljs-string">&#x27;english&#x27;</span>, <span class="hljs-string">&#x27;excited | trends&#x27;</span>)<br /><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> rank <span class="hljs-keyword">DESC</span>;</span></pre><p name="24a0" id="24a0" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">blog_posts</code> is a table of stored blog posts, where <code class="markup--code markup--p-code">tsv</code> is a special column. It is not a metadata that a blog needs, it is a column that we create for searching purposes.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="7d2d" id="7d2d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> blog_posts <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> tsv tsvector;<br /><span class="hljs-keyword">UPDATE</span> blog_posts <span class="hljs-keyword">SET</span> tsv <span class="hljs-operator">=</span> to_tsvector(<span class="hljs-string">&#x27;english&#x27;</span>, title <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-operator">||</span> body);</span></pre><p name="7b40" id="7b40" class="graf graf--p graf-after--pre">As we can see, <code class="markup--code markup--p-code">tsv</code> is the result set when we join <code class="markup--code markup--p-code">title</code> and <code class="markup--code markup--p-code">body</code> and do the English stemming.</p><p name="cf25" id="cf25" class="graf graf--p graf-after--p">The methods <code class="markup--code markup--p-code">to_tsvector</code> and <code class="markup--code markup--p-code">to_tsquery</code> are the core of this query. It is through these two methods that you can efficiently create the synonyms from the built-in dictionary. If you&#39;re familiar with Elasticsearch, then what these two methods are doing corresponds to <code class="markup--code markup--p-code">analyzer</code>.</p><p name="dd6a" id="dd6a" class="graf graf--p graf-after--p">Let’s explain this with a flowchart.</p><figure name="e360" id="e360" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IQc7nr5dIqQuMjQY982e8A.png" data-width="450" data-height="904" src="https://cdn-images-1.medium.com/max/800/1*IQc7nr5dIqQuMjQY982e8A.png"></figure><p name="e873" id="e873" class="graf graf--p graf-after--figure">The <code class="markup--code markup--p-code">tsvector</code> is the result that we store in advance through tokenizer and token filter operations. The same is applied to <code class="markup--code markup--p-code">tsquery</code>, but it is lighter. Then we compare <code class="markup--code markup--p-code">tsquery</code> and <code class="markup--code markup--p-code">tsvector</code> by using the matching operator <code class="markup--code markup--p-code">@@</code>, which produces a dataset containing the query results. Finally, the score is calculated and sorted by <code class="markup--code markup--p-code">ts_rank</code>.</p><p name="c831" id="c831" class="graf graf--p graf-after--p">In fact, the whole process is the same as what Elasticsearch does, except that PostgreSQL takes away the ability to customize and relies on the built-in dictionary.</p><p name="ba75" id="ba75" class="graf graf--p graf-after--p">It’s worth mentioning that the <code class="markup--code markup--p-code">tsv</code> column needs to be indexed with a <code class="markup--code markup--p-code">GIN</code> type index, otherwise the performance will be poor.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="79c0" id="79c0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CREATE</span> INDEX idx_fts <span class="hljs-keyword">ON</span> blog_posts <span class="hljs-keyword">USING</span> gin(tsv);</span></pre><p name="ce73" id="ce73" class="graf graf--p graf-after--pre">Elasticsearch is efficient not because it has a powerful <code class="markup--code markup--p-code">analyzer</code>, but because it uses inverted indexes at the backend. In PostgreSQL&#39;s case, it&#39;s GIN, Generalized Inverted Index.</p><p name="71f0" id="71f0" class="graf graf--p graf-after--p">Again, the technical detail is not the focus of this article, so I’ll skip it.</p><h3 name="0716" id="0716" class="graf graf--h3 graf-after--p">Non-built-in PostgreSQL catalogs</h3><p name="1f47" id="1f47" class="graf graf--p graf-after--h3">It is not difficult to list all currently supported languages for PostgreSQL.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="cd07" id="cd07" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> cfgname <span class="hljs-keyword">FROM</span> pg_ts_config;</span></pre><p name="f393" id="f393" class="graf graf--p graf-after--pre">As of today (PostgreSQL 16), there are only 29 in total.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="0938" id="0938" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> cfgname <span class="hljs-keyword">FROM</span> pg_ts_config;<br />  cfgname<br /><span class="hljs-comment">------------</span><br /> simple<br /> arabic<br /> armenian<br /> basque<br /> catalan<br /> danish<br /> dutch<br /> english<br /> finnish<br /> french<br /> german<br /> greek<br /> hindi<br /> hungarian<br /> indonesian<br /> irish<br /> italian<br /> lithuanian<br /> nepali<br /> norwegian<br /> portuguese<br /> romanian<br /> russian<br /> serbian<br /> spanish<br /> swedish<br /> tamil<br /> turkish<br /> yiddish<br />(<span class="hljs-number">29</span> <span class="hljs-keyword">rows</span>)</span></pre><p name="6137" id="6137" class="graf graf--p graf-after--pre">As seen, there is no CJK language at all, i.e. there is no ability to handle double-byte characters.</p><p name="31c5" id="31c5" class="graf graf--p graf-after--p">For languages without built-in support, they can be handled by extensions. Take Chinese as an example, <code class="markup--code markup--p-code"><a href="https://github.com/jaiminpan/pg_jieba" data-href="https://github.com/jaiminpan/pg_jieba" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">pg_jieba</a></code> is a widely used extension.</p><p name="bd21" id="bd21" class="graf graf--p graf-after--p">After installing the extension, we just need to modify the catalog in PostgreSQL.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="328d" id="328d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CREATE</span> EXTENSION pg_jieba;<br /><span class="hljs-keyword">UPDATE</span> blog_posts <span class="hljs-keyword">SET</span> tsv <span class="hljs-operator">=</span> to_tsvector(<span class="hljs-string">&#x27;jieba&#x27;</span>, title <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-operator">||</span> body);</span></pre><p name="4374" id="4374" class="graf graf--p graf-after--pre">The above is an example of <code class="markup--code markup--p-code">to_tsvector</code>, and of course, <code class="markup--code markup--p-code">to_tsquery</code> is the same.</p><p name="4baf" id="4baf" class="graf graf--p graf-after--p">So languages without built-in support can find language extensions to enhance PostgreSQL’s capabilities. This is one of the great things about PostgreSQL, it has a rich ecosystem of additional features.</p><h3 name="2b42" id="2b42" class="graf graf--h3 graf-after--p">What about AWS RDS?</h3><p name="d4c3" id="d4c3" class="graf graf--p graf-after--h3">In the previous section we mentioned that we can install additional extensions to support more languages, however, AWS RDS cannot customize extensions.</p><p name="6f52" id="6f52" class="graf graf--p graf-after--p">In this case, we have to transfer the server-side effort to the client-side.</p><p name="8768" id="8768" class="graf graf--p graf-after--p">In other words, we need to implement the language-specific stems on the client side and write <code class="markup--code markup--p-code">tsv</code> on the client side.</p><p name="81fd" id="81fd" class="graf graf--p graf-after--p">Let’s continue with <code class="markup--code markup--p-code"><a href="https://github.com/fxsjy/jieba" data-href="https://github.com/fxsjy/jieba" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">jieba</a></code> as an example. This is the main program logic for <code class="markup--code markup--p-code">pg_jieba</code>, which is also a Python package, so let&#39;s use Python for the example.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="7070" id="7070" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> jieba<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize</span>(<span class="hljs-params">text</span>):<br />    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(jieba.cut(text))<br /><br />cur.execute(<span class="hljs-string">&quot;&quot;&quot;<br />    INSERT INTO blog_posts (title, body, author, tsv)<br />    VALUES (%s, %s, %s, to_tsvector(&#x27;english&#x27;, %s))<br />&quot;&quot;&quot;</span>, (title, body, author, tokenize(title + <span class="hljs-string">&#x27; &#x27;</span> + body)))</span></pre><p name="1436" id="1436" class="graf graf--p graf-after--pre">Similarly, the query is also done by <code class="markup--code markup--p-code">jieba.cut</code> and then <code class="markup--code markup--p-code">to_tsquery</code>. One interesting thing is we still use <code class="markup--code markup--p-code">english</code> as the catalog in this example, but it doesn&#39;t really matter what we use. I just need the ability to split text with whitespace.</p><h3 name="9022" id="9022" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="d002" id="d002" class="graf graf--p graf-after--h3">In this article, we can see the power of PostgreSQL.</p><p name="bd5c" id="bd5c" class="graf graf--p graf-after--p">It has many useful features and a rich ecosystem. Even if these readymade implementations are not enough, we can still implement on our own through its stable and flexible design.</p><p name="caf8" id="caf8" class="graf graf--p graf-after--p">That’s why I prefer PostgreSQL.</p><p name="26ca" id="26ca" class="graf graf--p graf-after--p">If we don’t think about something clearly in the beginning, there are many chances that we can fix it without getting stuck in a mess.</p><p name="6350" id="6350" class="graf graf--p graf-after--p">This article provided an example of full-text searching, and I’ll provide an additional interesting example. At one time, I was using PostgreSQL for a microservice and focused on its ACID capabilities. However, the requirements changed so drastically that ACID was no longer a priority, but rather the ability to flexibly support a variety of data types.</p><p name="f5f6" id="f5f6" class="graf graf--p graf-after--p">Suddenly, PostgreSQL can be transformed into a document database, storing all kinds of nested JSON through <code class="markup--code markup--p-code">JSONB</code>.</p><p name="64d8" id="64d8" class="graf graf--p graf-after--p graf--trailing">Thanks to the flexibility of PostgreSQL, it has saved my life many times, and I would like to provide a reference for you.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/1efc744267d3"><time class="dt-published" datetime="2024-06-10T10:32:47.238Z">June 10, 2024</time></a>.</p><p><a href="https://medium.com/@lazypro/postgresql-full-text-search-in-a-nutshell-1efc744267d3" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>