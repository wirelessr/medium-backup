<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Optimizing Elasticsearch Reindex without Downtime</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Optimizing Elasticsearch Reindex without Downtime</h1>
</header>
<section data-field="subtitle" class="p-summary">
A Guide to achieving zero downtime, high efficiency, and successful migration updates
</section>
<section data-field="body" class="e-content">
<section name="5abd" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7cc8" id="7cc8" class="graf graf--h3 graf--leading graf--title">Optimizing Elasticsearch Reindex without Downtime</h3><h4 name="342b" id="342b" class="graf graf--h4 graf-after--h3 graf--subtitle">A Guide to achieving zero downtime, high efficiency, and successful migration updates</h4><figure name="dd99" id="dd99" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*gxwIDp8PlQ1rtRIz" data-width="1000" data-height="667" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*gxwIDp8PlQ1rtRIz"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@jcraice" data-href="https://unsplash.com/@jcraice" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Julia Craice</a> on <a href="https://unsplash.com/photos/white-bird-faCwTallTC0" data-href="https://unsplash.com/photos/white-bird-faCwTallTC0" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="1e1d" id="1e1d" class="graf graf--p graf-after--figure">When using Elasticsearch, there are always times we need to modify the index mapping, and when it happens, we can only do <code class="markup--code markup--p-code">_reindex</code>. In fact, it is a pretty expensive operation because it can take up to several hours to make a complete replication of an index, depending on the amount of data and the amount of shards.</p><p name="e967" id="e967" class="graf graf--p graf-after--p">The time spent is not a big problem, but more seriously, it can affect the performance and even the functionality of the production environment.</p><p name="48fd" id="48fd" class="graf graf--p graf-after--p">I believe we all understand that data migration consumes a lot of hard drive resources, it definitely affects performance, but what about functionality?</p><p name="dd8e" id="dd8e" class="graf graf--p graf-after--p">Let’s take a regular <code class="markup--code markup--p-code">_reindex</code> as an example. Suppose we have created an alias on the index. If we don’t have an alias, we’re in big trouble.</p><figure name="6299" id="6299" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3acOcjSOnkYeio6x4cQvPw.png" data-width="994" data-height="988" src="https://cdn-images-1.medium.com/max/800/1*3acOcjSOnkYeio6x4cQvPw.png"></figure><p name="1d98" id="1d98" class="graf graf--p graf-after--figure">A regular <code class="markup--code markup--p-code">_reindex</code> procedure is divided into two steps.</p><ol class="postList"><li name="cdfb" id="cdfb" class="graf graf--li graf-after--p">Call the <code class="markup--code markup--li-code">_reindex</code> command to start data migration.</li><li name="1957" id="1957" class="graf graf--li graf-after--li">When the data migration is complete, call the <code class="markup--code markup--li-code">_aliases</code> command to switch between the old and new indexes.</li></ol><p name="c84a" id="c84a" class="graf graf--p graf-after--li">After step 2, the new index is officially operational, and will be responsible for all read and write requests. However, this is a perfect ideal scenario, in reality, things won’t work out that way.</p><p name="2f9f" id="2f9f" class="graf graf--p graf-after--p">Here is a normal scenario.</p><figure name="b840" id="b840" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FB8pFsZPCb3dy3Tjw8Da4g.png" data-width="1030" data-height="830" src="https://cdn-images-1.medium.com/max/800/1*FB8pFsZPCb3dy3Tjw8Da4g.png"></figure><p name="fb3e" id="fb3e" class="graf graf--p graf-after--figure">Actually, during the data migration period or before switching aliases, the client will continue to write data to the original index, and these new changes will not be migrated to the new index, which leads to data inconsistency.</p><p name="a088" id="a088" class="graf graf--p graf-after--p">For the client, the feeling is that after changing the alias, all the changes just made will disappear. Furthermore, as I just mentioned, a big index migration can take hours, so the client’s feeling must be obvious.</p><p name="d30e" id="d30e" class="graf graf--p graf-after--p">So what to do?</p><h3 name="9aac" id="9aac" class="graf graf--h3 graf-after--p">The correct flow of Reindex</h3><figure name="6c57" id="6c57" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*B_mmpCbY7HoGvOo8Q9GavQ.png" data-width="1032" data-height="1052" src="https://cdn-images-1.medium.com/max/800/1*B_mmpCbY7HoGvOo8Q9GavQ.png"></figure><p name="bd71" id="bd71" class="graf graf--p graf-after--figure">The above flow makes two changes to the original flow.</p><ol class="postList"><li name="165c" id="165c" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">_reindex</code> must use <strong class="markup--strong markup--li-strong">external</strong> type.</li><li name="616c" id="616c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">_reindex</code> is needed again after switching aliases.</li></ol><p name="327e" id="327e" class="graf graf--p graf-after--li">Let’s explain the concept of the external type.</p><p name="6a24" id="6a24" class="graf graf--p graf-after--p">By default, <code class="markup--code markup--p-code">_reindex</code> is internal, and such data migration is done by using the original index to overwrite the new index anyway, and dropping the <code class="markup--code markup--p-code">_version</code> of the documents, so all documents in the new index start over.</p><p name="30f3" id="30f3" class="graf graf--p graf-after--p">If using the external type, the <code class="markup--code markup--p-code">_version</code> of the documents will be carried over to the new index during data migration, then the <code class="markup--code markup--p-code">_version</code> will be compared if there is a conflict between the <code class="markup--code markup--p-code">_id</code> of the old and new indexes. Only if the version of the original document is greater than the destination document will be overwritten.</p><p name="3ed5" id="3ed5" class="graf graf--p graf-after--p">A bit abstract? Let’s take an example.</p><p name="7cfa" id="7cfa" class="graf graf--p graf-after--p">Let’s say the original index has a document like the following, with Elasticsearch metadata at the beginning of the underscore.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="json" name="6473" id="6473" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-punctuation">{</span><br />    <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br />    <span class="hljs-attr">&quot;_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br />    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hello Elastic&quot;</span><br /><span class="hljs-punctuation">}</span></span></pre><p name="3f4e" id="3f4e" class="graf graf--p graf-after--pre">When we do external data migration, <code class="markup--code markup--p-code">_version: 1</code> is also written to the new index. if someone changes the original document to <code class="markup--code markup--p-code">Hello Search</code> during the data migration period, then the complete document will look like the following.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="json" name="471c" id="471c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-punctuation">{</span><br />    <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br />    <span class="hljs-attr">&quot;_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br />    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hello Search&quot;</span><br /><span class="hljs-punctuation">}</span></span></pre><p name="aa81" id="aa81" class="graf graf--p graf-after--pre">A redo of <code class="markup--code markup--p-code">_reindex</code> will find <code class="markup--code markup--p-code">2 &gt; 1</code>, so it will be overwritten with <code class="markup--code markup--p-code">Hello Search</code>.</p><p name="85da" id="85da" class="graf graf--p graf-after--p">Then, what if the second <code class="markup--code markup--p-code">_reindex</code> has someone modifying the documents in the new index? For example, if someone changes <code class="markup--code markup--p-code">Hello Elatic</code> to <code class="markup--code markup--p-code">Hello Elasticsearch</code> in the new index, will it be overwritten with the old value? The whole process would look like below.</p><figure name="51cb" id="51cb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-na9YWkaUD8Ht6eqxyM4OQ.png" data-width="1032" data-height="1110" src="https://cdn-images-1.medium.com/max/800/1*-na9YWkaUD8Ht6eqxyM4OQ.png"></figure><p name="e085" id="e085" class="graf graf--p graf-after--figure">The answer is no, because the original version has to be greater than the new version to be overwritten, if they are equal (both 2) then they are not affected.</p><h3 name="c55d" id="c55d" class="graf graf--h3 graf-after--p">One more problem.</h3><p name="e3bb" id="e3bb" class="graf graf--p graf-after--h3">Although we will do a second <code class="markup--code markup--p-code">_reindex</code> to patch the data, if the patch time is very long, it will still be inconsistent for the users. There are two ways to shorten the reindexing time.</p><ol class="postList"><li name="ca61" id="ca61" class="graf graf--li graf-after--p">Minimize the time of the first <code class="markup--code markup--li-code">_reindex</code> as much as possible.</li><li name="8731" id="8731" class="graf graf--li graf-after--li">Filter the patch data in advance.</li></ol><p name="932f" id="932f" class="graf graf--p graf-after--li">Regarding the first point, the <code class="markup--code markup--p-code">_reindex</code> process is controlled by Elasticsearch, what else can we do to improve efficiency? Hey, there is.</p><p name="ff35" id="ff35" class="graf graf--p graf-after--p">We can modify the settings of the new index to minimize the IO overhead during data migration.</p><ol class="postList"><li name="c561" id="c561" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">refresh_interval = -1</code></li><li name="bb26" id="bb26" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">number_of_replicas = 0</code></li></ol><p name="a22a" id="a22a" class="graf graf--p graf-after--li">It’s quite straightforward. First of all, the purpose of turning off <code class="markup--code markup--p-code">refresh_interval</code> is to allow the data migration period to just focus on writing to the <code class="markup--code markup--p-code">Trans log</code> and not spend extra disk IO on Lucene.</p><figure name="77e4" id="77e4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*QHksqm1Twzqw8g51yLZF7A.png" data-width="658" data-height="896" src="https://cdn-images-1.medium.com/max/800/1*QHksqm1Twzqw8g51yLZF7A.png"></figure><p name="6614" id="6614" class="graf graf--p graf-after--figure">Secondly, turning off <code class="markup--code markup--p-code">number_of_replicas</code> reduces the additional data replication overhead that the cluster has to deal with.</p><p name="d169" id="d169" class="graf graf--p graf-after--p">On the other hand, in addition to reducing the time of the first <code class="markup--code markup--p-code">_reindex</code>, some data filtering can be used to reduce the amount of data for the second <code class="markup--code markup--p-code">_reindex</code>.</p><p name="a04f" id="a04f" class="graf graf--p graf-after--p">For example, bringing in the last update time of the data during the <code class="markup--code markup--p-code">_reindex</code> is a possible solution. Assuming that each document has an <code class="markup--code markup--p-code">updated_at</code> field, then adding the following condition to the <code class="markup--code markup--p-code">query</code> of the <code class="markup--code markup--p-code">_reindex</code> would be effective.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="json" name="0a8e" id="0a8e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-punctuation">{</span><br />    <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br />        <span class="hljs-attr">&quot;updated_at&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;now-1d&quot;</span><span class="hljs-punctuation">}</span><br />    <span class="hljs-punctuation">}</span><br /><span class="hljs-punctuation">}</span></span></pre><h3 name="22cc" id="22cc" class="graf graf--h3 graf-after--pre">Conclusion</h3><p name="d33a" id="d33a" class="graf graf--p graf-after--h3">Based on the above mentioned details, let’s list out the ideal flow of a reindex.</p><ol class="postList"><li name="e28e" id="e28e" class="graf graf--li graf-after--p">Create the destination index.</li><li name="558a" id="558a" class="graf graf--li graf-after--li">Update the settings of the destination index. (<code class="markup--code markup--li-code">refresh_interval = -1</code> and <code class="markup--code markup--li-code">number_of_replicas = 0</code>)</li><li name="9d65" id="9d65" class="graf graf--li graf-after--li">Use external type for <code class="markup--code markup--li-code">_reindex</code>.</li><li name="8851" id="8851" class="graf graf--li graf-after--li">Switch aliases from original index to destination index.</li><li name="47a2" id="47a2" class="graf graf--li graf-after--li">Do <code class="markup--code markup--li-code">_reindex</code> again using external type, preferably with additional filtering.</li><li name="8d02" id="8d02" class="graf graf--li graf-after--li">Update the destination index setting again. (<code class="markup--code markup--li-code">refresh_interval = null</code> and <code class="markup--code markup--li-code">number_of_replicas = null</code>)</li></ol><blockquote name="13a8" id="13a8" class="graf graf--blockquote graf-after--li"><em class="markup--em markup--blockquote-em">According to the </em><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.11/indices-update-settings.html#reset-index-setting" data-href="https://www.elastic.co/guide/en/elasticsearch/reference/8.11/indices-update-settings.html#reset-index-setting" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank"><em class="markup--em markup--blockquote-em">official document</em></a><em class="markup--em markup--blockquote-em">, setting to </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">null</em></code><em class="markup--em markup--blockquote-em"> allows to restore the original setting.</em></blockquote><p name="ba7e" id="ba7e" class="graf graf--p graf-after--blockquote">Because <code class="markup--code markup--p-code">_reindex</code> is unavoidable, it is important to know how to do <code class="markup--code markup--p-code">_reindex</code> without downtime.</p><p name="0b9b" id="0b9b" class="graf graf--p graf-after--p">In fact, with Elasticsearch’s streaming index, there are more elegant ways to get it done. However, there are a lot of limitations on the use case for a streaming index, so it’s more common to use a regular index in practice.</p><p name="38e8" id="38e8" class="graf graf--p graf-after--p">This article provides a complete procedure to do <code class="markup--code markup--p-code">_reindex</code> as fast as possible and minimize the time of data inconsistency. However, all of this assumes that the alias is properly created, and if it is not, then more extra steps are required. I feel the lack of aliases is already a violation of Elasticsearch’s best practices, so this article doesn’t specifically cover that scenario.</p><h3 name="f355" id="f355" class="graf graf--h3 graf-after--p">Stackademic</h3><p name="4363" id="4363" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Thank you for reading until the end. Before you go:</em></p><ul class="postList"><li name="a50c" id="a50c" class="graf graf--li graf-after--p"><em class="markup--em markup--li-em">Please consider </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">clapping</em></strong><em class="markup--em markup--li-em"> and </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">following</em></strong><em class="markup--em markup--li-em"> the writer! 👏</em></li><li name="9cf2" id="9cf2" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Follow us on </em><a href="https://twitter.com/stackademichq" data-href="https://twitter.com/stackademichq" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Twitter(X)</em></strong></a><em class="markup--em markup--li-em">, </em><a href="https://www.linkedin.com/company/stackademic" data-href="https://www.linkedin.com/company/stackademic" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">LinkedIn</em></strong></a><em class="markup--em markup--li-em">, and </em><a href="https://www.youtube.com/c/stackademic" data-href="https://www.youtube.com/c/stackademic" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">YouTube</em></strong></a><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">.</em></strong></li><li name="67b4" id="67b4" class="graf graf--li graf-after--li graf--trailing"><em class="markup--em markup--li-em">Visit </em><a href="http://stackademic.com/" data-href="http://stackademic.com/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Stackademic.com</em></strong></a><em class="markup--em markup--li-em"> to find out more about how we are democratizing free programming education around the world.</em></li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/0f70cb4949d6"><time class="dt-published" datetime="2023-12-25T00:30:15.518Z">December 25, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/optimizing-elasticsearch-reindex-without-downtime-0f70cb4949d6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>