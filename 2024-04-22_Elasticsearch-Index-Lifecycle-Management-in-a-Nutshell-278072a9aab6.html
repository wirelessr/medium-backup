<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Elasticsearch Index Lifecycle Management in a Nutshell</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Elasticsearch Index Lifecycle Management in a Nutshell</h1>
</header>
<section data-field="subtitle" class="p-summary">
Understanding its Application Scenarios and Limitations
</section>
<section data-field="body" class="e-content">
<section name="338b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3091" id="3091" class="graf graf--h3 graf--leading graf--title">Elasticsearch Index Lifecycle Management in a Nutshell</h3><h4 name="fb27" id="fb27" class="graf graf--h4 graf-after--h3 graf--subtitle">Understanding its Application Scenarios and Limitations</h4><figure name="247d" id="247d" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*LQaJhD9iC8n85_qg" data-width="1000" data-height="667" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*LQaJhD9iC8n85_qg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@davies_designs" data-href="https://unsplash.com/@davies_designs" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Davies Designs Studio</a> on <a href="https://unsplash.com/photos/white-ceramic-mug-on-brown-wooden-round-tray--gqGqlSiyPg" data-href="https://unsplash.com/photos/white-ceramic-mug-on-brown-wooden-round-tray--gqGqlSiyPg" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="90b1" id="90b1" class="graf graf--p graf-after--figure">When we develop data-intensive applications, we usually classify data into frequently used and infrequently used, i.e. hot data and cold data. We have different ways of handling data at different “temperatures”, for example, cold data is stored in lower-cost storage, but with a lower access performance.</p><p name="6e0f" id="6e0f" class="graf graf--p graf-after--p">If the databases we use have this kind of temperature management built in, then the operation effort will be greatly reduced.</p><p name="3911" id="3911" class="graf graf--p graf-after--p">Fortunately, Elasticsearch has such a feature, called <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/ilm-index-lifecycle.html" data-href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/ilm-index-lifecycle.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">index lifecycle management</a> (ILM).</p><p name="a823" id="a823" class="graf graf--p graf-after--p">Before we get into ILM, let’s jump to the conclusion.</p><p name="47bf" id="47bf" class="graf graf--p graf-after--p">There are two common ways to use Elasticsearch, one is to treat Elasticsearch as an OLTP database, just like a regular database where we CRUD each document. The scenario is we need the search capabilities provided by Elasticsearch, so each document will be a corresponding entity.</p><p name="f2de" id="f2de" class="graf graf--p graf-after--p">Take an e-commerce website as an example, in order to be able to search for product titles, content, etc., we will add a product as a document to Elasticsearch, and when there are any changes to the product, we will directly find out the corresponding document and modify the fields in it.</p><p name="6d15" id="6d15" class="graf graf--p graf-after--p">So, the modeling in Elasticsearch will be an index, let’s say <code class="markup--code markup--p-code">products</code>, which contains many documents representing products.</p><figure name="0216" id="0216" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hiPxw1JZY-AKvbkBCVWWRQ.png" data-width="746" data-height="204" src="https://cdn-images-1.medium.com/max/800/1*hiPxw1JZY-AKvbkBCVWWRQ.png"></figure><p name="766a" id="766a" class="graf graf--p graf-after--figure">On the other hand, Elasticsearch can also be used as a time-series database. All data is continuously written to Elasticsearch, and the written documents are rarely modified. A common example of this is logs. We often use Elasticsearch’s powerful search capabilities to find specific patterns in logs. So in Elasticsearch, there may be a time-divided index, such as log-2024–04–01, log-2024–04–02 and so on.</p><p name="1288" id="1288" class="graf graf--p graf-after--p">Elasticsearch’s ILM only benefits from the latter.</p><h3 name="eff1" id="eff1" class="graf graf--h3 graf-after--p">ILM Concepts</h3><p name="3f8e" id="3f8e" class="graf graf--p graf-after--h3">Why ILM can only work on time-series data scenarios and not on OLTP scenarios?</p><p name="ed8f" id="ed8f" class="graf graf--p graf-after--p">Briefly, the unit of ILM is index, as indicated by the first letter I. Therefore, when only one index exists, there is no way for ILM to manage it. Either the whole index is hot, or the whole index is cold, and there is no way to distinguish which documents are hot and which are cold within this index.</p><p name="ee08" id="ee08" class="graf graf--p graf-after--p">The whole concept of ILM in Elasticsearch is to label the index with hot, warm and cold. With different labels, there will be different behaviors, for example, a cold index can only be read but not written. In addition, the nodes in the cluster are labeled so that different temperature indexes belong to specific nodes. In this way, the cold index can be placed in a lower cost machine to save cost.</p><p name="8f92" id="8f92" class="graf graf--p graf-after--p">In addition to ILM, Elasticsearch has another mechanism that is often paired with ILM, which is <code class="markup--code markup--p-code"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/getting-started-index-lifecycle-management.html" data-href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/getting-started-index-lifecycle-management.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Rollover</a></code>. When time-series data is constantly written to an index, the performance of the index will inevitably degrade. Therefore, <code class="markup--code markup--p-code">Rollover</code> allows the index to generate a new index when certain conditions are met, and the original index will no longer accept write requests.</p><p name="dc45" id="dc45" class="graf graf--p graf-after--p">The principle of Rollover is to have a dedicated alias for writing to the underlying index, e.g. index-000001, and when a new index is generated, the alias is automatically switched to the new index, e.g. index-000002.</p><figure name="e735" id="e735" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*HzH7HTT4hAB7wu1YVoFHfg.png" data-width="886" data-height="418" src="https://cdn-images-1.medium.com/max/800/1*HzH7HTT4hAB7wu1YVoFHfg.png"></figure><p name="3250" id="3250" class="graf graf--p graf-after--figure">Based on the configured ILM policy, index-000001 will be converted from a hot index to a warm index, and then to a cold index, achieving a lifecycle.</p><p name="9955" id="9955" class="graf graf--p graf-after--p">This is the whole concept of data tiering in Elasticsearch.</p><h3 name="a030" id="a030" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="af20" id="af20" class="graf graf--p graf-after--h3">Although Elasticsearch has built-in ILM, there are still many people who misunderstand the concept of ILM. The built-in ILM is indeed a very powerful capability, but it is not a silver bullet as there are limitations on the scenarios it can be applied to.</p><p name="d208" id="d208" class="graf graf--p graf-after--p">Therefore, this article mainly explains the concept of ILM and the applicable scenarios. As for the specific operation is not difficult, the official document has a detailed description, I will not dive into it.</p><p name="65b9" id="65b9" class="graf graf--p graf-after--p">If we want to use Elasticsearch in an OLTP scenario and want to benefit from ILM, then I think we may need to change our modeling approach so that each CRUD creates a new entity, which might be simpler in this case.</p><p name="7c4f" id="7c4f" class="graf graf--p graf-after--p">Here’s a possible approach, let’s continue with the <code class="markup--code markup--p-code">products</code> example.</p><p name="5548" id="5548" class="graf graf--p graf-after--p">When we add a Japanese apple at the first index, <code class="markup--code markup--p-code">products-01</code>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="9fd1" id="9fd1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">POST /products-01/_doc/1<br />{<br />    <span class="hljs-string">&quot;product_id&quot;</span>: <span class="hljs-string">&quot;0001&quot;</span>,<br />    <span class="hljs-string">&quot;product_name&quot;</span>: <span class="hljs-string">&quot;Apple&quot;</span>,<br />    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Made in Japan&quot;</span>,<br />    <span class="hljs-string">&quot;price&quot;</span>: 100<br />}</span></pre><p name="0788" id="0788" class="graf graf--p graf-after--pre">After some time, Japanese apples were out of stock, so we switched to importing American apples. But at this time, the index has been changed to <code class="markup--code markup--p-code">products-02</code> due to <code class="markup--code markup--p-code">Rollover</code>, and the original <code class="markup--code markup--p-code">products-01</code> has been cooled down so we can&#39;t update it.</p><p name="4d6c" id="4d6c" class="graf graf--p graf-after--p">Then we need to write the same apples and updated information in <code class="markup--code markup--p-code">products-02</code>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="3626" id="3626" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">POST /products-02/_doc/1<br />{<br />    <span class="hljs-string">&quot;product_id&quot;</span>: <span class="hljs-string">&quot;0001&quot;</span>,<br />    <span class="hljs-string">&quot;product_name&quot;</span>: <span class="hljs-string">&quot;Apple&quot;</span>,<br />    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Made in USA&quot;</span>,<br />    <span class="hljs-string">&quot;price&quot;</span>: 50<br />}</span></pre><p name="ba55" id="ba55" class="graf graf--p graf-after--pre">All of these indexes will have the same alias, <code class="markup--code markup--p-code">products-search</code>, for searching.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="6b9f" id="6b9f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">POST /_aliases<br />{<br />    <span class="hljs-string">&quot;actions&quot;</span>: [<br />        {<br />            <span class="hljs-string">&quot;add&quot;</span>: {<br />                <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;products-01&quot;</span>,<br />                <span class="hljs-string">&quot;alias&quot;</span>: <span class="hljs-string">&quot;products-search&quot;</span><br />            }<br />        },<br />        {<br />            <span class="hljs-string">&quot;add&quot;</span>: {<br />                <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;products-02&quot;</span>,<br />                <span class="hljs-string">&quot;alias&quot;</span>: <span class="hljs-string">&quot;products-search&quot;</span><br />            }<br />        }<br />    ]<br />}</span></pre><p name="51ef" id="51ef" class="graf graf--p graf-after--pre">Finally, we search the results directly on <code class="markup--code markup--p-code">products-search</code> but sort them in order, and the top one will be the final result.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="cb93" id="cb93" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">POST /products-search/_search<br />{<br />    <span class="hljs-string">&quot;query&quot;</span>: {<br />        <span class="hljs-string">&quot;bool&quot;</span>: {<br />            <span class="hljs-string">&quot;must&quot;</span>: [<br />                {<br />                    <span class="hljs-string">&quot;match&quot;</span>: {<br />                        <span class="hljs-string">&quot;product_name&quot;</span>: <span class="hljs-string">&quot;Apple&quot;</span><br />                    }<br />                }<br />            ]<br />        }<br />    },<br />    <span class="hljs-string">&quot;sort&quot;</span>: [<br />        {<br />            <span class="hljs-string">&quot;_index&quot;</span>: {<br />                <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span><br />            }<br />        }<br />    ]<br />}</span></pre><p name="7eb1" id="7eb1" class="graf graf--p graf-after--pre">So the client has to de-duplicate the data using <code class="markup--code markup--p-code">product_id</code>, which is a case of updates. Similarly for deletions, a document labeled with a soft delete flag needs to be added so that the client can be aware that the data is invalid.</p><p name="165c" id="165c" class="graf graf--p graf-after--p">In order to implement data tiering on the backend, extra processing must be done on the client side. If the system wasn’t designed this way from the beginning, there would be a lot of development on the client side, which is not always a good approach.</p><p name="b1da" id="b1da" class="graf graf--p graf-after--p">Alternatively, use additional ETL to move documents that meet the criteria to a different cold index. In this way the client can maintain its existing behavior without awareness.</p><p name="7739" id="7739" class="graf graf--p graf-after--p graf--trailing">Anyway, there’s not much ILM can do for OLTP scenarios, it all depends on the system design.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/278072a9aab6"><time class="dt-published" datetime="2024-04-22T01:39:02.399Z">April 22, 2024</time></a>.</p><p><a href="https://medium.com/@lazypro/elasticsearch-index-lifecycle-management-in-a-nutshell-278072a9aab6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>