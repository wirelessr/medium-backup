<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Squeezing out MongoDB’s available storage</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Squeezing out MongoDB’s available storage</h1>
</header>
<section data-field="subtitle" class="p-summary">
Exploring Three Viable Approaches to Optimize Database Resources
</section>
<section data-field="body" class="e-content">
<section name="318c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5af3" id="5af3" class="graf graf--h3 graf--leading graf--title">Squeezing out MongoDB’s available storage</h3><h4 name="8371" id="8371" class="graf graf--h4 graf-after--h3 graf--subtitle">Exploring Three Viable Approaches to Optimize Database Resources</h4><figure name="d87d" id="d87d" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*6lpp4RNmAV8n6SNo" data-width="1000" data-height="667" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*6lpp4RNmAV8n6SNo"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@markuswinkler" data-href="https://unsplash.com/@markuswinkler" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Markus Winkler</a> on <a href="https://unsplash.com/photos/cV9-hOgoaok" data-href="https://unsplash.com/photos/cV9-hOgoaok" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="d027" id="d027" class="graf graf--p graf-after--figure">There are always times when the available space in the database is exhausted, and we need to take action.</p><p name="cf95" id="cf95" class="graf graf--p graf-after--p">Generally, the most common approach is vertical scaling, also known as scale-up, which involves increasing the specifications of the machine directly to expand the available space. Another alternative solution is horizontal scaling, also known as scale-out or sharding, which enhances overall available space by distributing data across different machines.</p><p name="2ed9" id="2ed9" class="graf graf--p graf-after--p">However, both scale-up and scale-out involve costs, and these can be substantial. For organizations with budget constraints, neither of these approaches may be immediately feasible. So, what can be done?</p><p name="c520" id="c520" class="graf graf--p graf-after--p">In such cases, the only option is to squeeze out as much space as possible from the existing machines, no matter what it takes, just pure squeezing.</p><p name="742f" id="742f" class="graf graf--p graf-after--p">In this article, we take MongoDB as an example to explore the viable approaches for squeezing out available space.</p><h3 name="4af2" id="4af2" class="graf graf--h3 graf-after--p">Remove useless index</h3><p name="9064" id="9064" class="graf graf--p graf-after--h3">Indexes are a trade-off of space for time to improve query performance. Therefore, if unused indexes can be identified and removed, the initially consumed space can be reclaimed.</p><p name="46e3" id="46e3" class="graf graf--p graf-after--p">Why do indexes become redundant?</p><p name="81db" id="81db" class="graf graf--p graf-after--p">There are several common reasons as follows:</p><ol class="postList"><li name="0758" id="0758" class="graf graf--li graf-after--p">Because MongoDB’s WiredTiger is a B-tree-based storage engine, it has a feature known as the leftmost-prefix. Thus, if a new index and an old index have the same prefix, the old index can be safely removed without affecting query performance.</li><li name="c481" id="c481" class="graf graf--li graf-after--li">Due to feature iterations, some queries that were required initially are no longer in use.</li></ol><p name="d792" id="d792" class="graf graf--p graf-after--li">Regarding the first point, we can easily identify which indexes can be removed by carefully scanning each index. However, for the second point, some additional preparation is necessary.</p><p name="4b82" id="4b82" class="graf graf--p graf-after--p">We need to know which indexes are not being used. Apart from tracing clues from the code, there is a more efficient approach, which is to directly examine the index metrics. In the case of MongoDB, the <code class="markup--code markup--p-code">$indexStats</code> <a href="https://www.mongodb.com/docs/manual/reference/operator/aggregation/indexStats/#mongodb-pipeline-pipe.-indexStats" data-href="https://www.mongodb.com/docs/manual/reference/operator/aggregation/indexStats/#mongodb-pipeline-pipe.-indexStats" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">aggregation operation</a> can provide statistical data on the indexes.</p><p name="3233" id="3233" class="graf graf--p graf-after--p">By comparing the statistics from two time periods, we can determine which indexes are not being used.</p><h3 name="bf05" id="bf05" class="graf graf--h3 graf-after--p">Remove useless data</h3><p name="bd47" id="bd47" class="graf graf--p graf-after--h3">The above-mentioned approach of deleting indexes is a relatively straightforward solution that does not affect the production environment. However, if more available space needs to be squeezed out, consider deleting unused data.</p><p name="4ac7" id="4ac7" class="graf graf--p graf-after--p">Defining what constitutes unused data entirely depends on the application. For instance, some applications use flags to mark softly deleted documents, allowing these softly deleted documents to be removed or archived to cold storage.</p><p name="ed84" id="ed84" class="graf graf--p graf-after--p">Another scenario involves time-series data, where defining how old the data should be before it can be deleted becomes relevant. However, whichever solution is chosen depends entirely on the application.</p><h3 name="1338" id="1338" class="graf graf--h3 graf-after--p">Reshard</h3><p name="2a34" id="2a34" class="graf graf--p graf-after--h3">This is a more advanced approach compared to the previous two, directly impacting the performance of the production environment.</p><p name="553d" id="553d" class="graf graf--p graf-after--p">If the MongoDB cluster is already a sharded cluster but some collections have not been sharded, setting the appropriate shard key and enabling sharding can be a relatively straightforward process.</p><p name="c1c5" id="c1c5" class="graf graf--p graf-after--p">However, if all collections have already been sharded, it’s essential to examine which collections have uneven data distribution. Consider modifying the shard key and even taking further steps to rebalance. Phew, as of MongoDB 5.0, we can finally reshard a collection.</p><p name="42f2" id="42f2" class="graf graf--p graf-after--p">I previously wrote an article describing how to correctly design a shard key to achieve as even a data distribution as possible.</p><div name="6386" id="6386" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://interviewnoodle.com/how-to-choose-a-mongodb-shard-key-e4063b636c26" data-href="https://interviewnoodle.com/how-to-choose-a-mongodb-shard-key-e4063b636c26" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://interviewnoodle.com/how-to-choose-a-mongodb-shard-key-e4063b636c26"><strong class="markup--strong markup--mixtapeEmbed-strong">How to choose a MongoDB shard key</strong><br><em class="markup--em markup--mixtapeEmbed-em">I will show you what is the ideal pattern of a MongoDB shard key and the concepts behind it.</em>interviewnoodle.com</a><a href="https://interviewnoodle.com/how-to-choose-a-mongodb-shard-key-e4063b636c26" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="fb12cbe92712470989e95becba072178" data-thumbnail-img-id="0*huNV3uOmTLrTv1Z0.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*huNV3uOmTLrTv1Z0.png);"></a></div><p name="6235" id="6235" class="graf graf--p graf-after--mixtapeEmbed">We can determine whether data distribution is uniform by using the command <code class="markup--code markup--p-code">sh.status()</code>. <a href="https://www.mongodb.com/docs/manual/reference/method/sh.status/#mongodb-data-sh.status.databases.-collection-.chunks" data-href="https://www.mongodb.com/docs/manual/reference/method/sh.status/#mongodb-data-sh.status.databases.-collection-.chunks" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">This command</a> provides explicit information in the output regarding how many shards are being used for a collection and how many chunks each shard holds. A chunk represents the unit of data distribution.</p><h3 name="d97e" id="d97e" class="graf graf--h3 graf-after--p">However</h3><p name="07c6" id="07c6" class="graf graf--p graf-after--h3">It seems like we have several approaches that should all be effective if carefully implemented, right?</p><p name="cdd5" id="cdd5" class="graf graf--p graf-after--p">In reality, after implementing the second and third approaches, observing the available space reveals no improvement. In fact, it may even worsen, especially after executing the third approach.</p><p name="03cd" id="03cd" class="graf graf--p graf-after--p">The following diagram illustrates the usage space of a particular shard on the y-axis over time on the x-axis. Here, <code class="markup--code markup--p-code">t1</code> denotes the initiation of sharding, while <code class="markup--code markup--p-code">t2</code> represents the completion of the sharding process.</p><figure name="e038" id="e038" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*w-V9o9TJxgfUObOq6MfJPg.png" data-width="1122" data-height="1200" src="https://cdn-images-1.medium.com/max/800/1*w-V9o9TJxgfUObOq6MfJPg.png"></figure><p name="de6d" id="de6d" class="graf graf--p graf-after--figure">We aimed to shard a collection that had not been sharded yet to release the available space in the original shard. However, as we can see from the diagram, after the sharding process was completed, the situation worsened, which was entirely contrary to our expectations.</p><p name="220a" id="220a" class="graf graf--p graf-after--p">Why did this happen?</p><p name="8309" id="8309" class="graf graf--p graf-after--p">The reason lies in WiredTiger’s behavior. After deleting documents, it does not immediately release the space. Instead, it retains the already allocated space, ensuring prepared chunks for future data writes in the collection.</p><p name="34e4" id="34e4" class="graf graf--p graf-after--p">This intention is well-meaning, as disk I/O performance is poor, and having a pre-arranged “clean slate” is valuable. However, this contradicts our goal of having the data disappear immediately after deletion. Hence, we see that although data is deleted, the available space does not increase.</p><p name="bc99" id="bc99" class="graf graf--p graf-after--p">Why did the diagram not only fail to decrease but also grow?</p><p name="4b5f" id="4b5f" class="graf graf--p graf-after--p">During the sharding process, to enable more efficient sharded queries, an index is created on the shard key. The additional space consumption represents the space occupied by these indexes.</p><p name="a869" id="a869" class="graf graf--p graf-after--p">Can we determine how much space WiredTiger has covertly consumed? The answer is yes.</p><p name="110d" id="110d" class="graf graf--p graf-after--p">Executing <a href="https://www.mongodb.com/docs/manual/reference/method/db.collection.stats/#mongodb-method-db.collection.stats" data-href="https://www.mongodb.com/docs/manual/reference/method/db.collection.stats/#mongodb-method-db.collection.stats" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">the command</a> <code class="markup--code markup--p-code">db.collection.stats()</code> yields an output segment that describes “file bytes available for reuse,” representing the space that has been covertly taken.</p><p name="843e" id="843e" class="graf graf--p graf-after--p">If we can find it, we can certainly reclaim it. Running the <code class="markup--code markup--p-code">compact</code> <a href="https://www.mongodb.com/docs/manual/reference/command/compact/#mongodb-dbcommand-dbcmd.compact" data-href="https://www.mongodb.com/docs/manual/reference/command/compact/#mongodb-dbcommand-dbcmd.compact" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">command accomplishes this</a>. It’s worth noting that the space regained through <code class="markup--code markup--p-code">compact</code> can only be used by the same collection, so the problem remains unresolved.</p><p name="523b" id="523b" class="graf graf--p graf-after--p">To enable all collections to reuse the occupied space, a <a href="https://www.mongodb.com/docs/manual/core/replica-set-sync/#initial-sync" data-href="https://www.mongodb.com/docs/manual/core/replica-set-sync/#initial-sync" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">complex procedure</a> is required. Let me simplify the explanation.</p><p name="727d" id="727d" class="graf graf--p graf-after--p">When we add a new member to a ReplicaSet in MongoDB, the new member executes an <code class="markup--code markup--p-code">Init Sync</code> to synchronize the current data. However, this <code class="markup--code markup--p-code">Init Sync</code> only synchronizes actual data and not the occupied space. In other words, the new member does not occupy the available space.</p><p name="8cf2" id="8cf2" class="graf graf--p graf-after--p">Thus, if we gradually replace all the members in a ReplicaSet, we can obtain a new cluster (or Ship of Theseus) with the same dataset but without the occupied space. However, this process requires a “slight” additional budget to enable an extra machine as a new member, which is no longer necessary after the entire replacement process is complete, resulting in significant savings compared to scaling up or scaling out.</p><h3 name="97d1" id="97d1" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="dd92" id="dd92" class="graf graf--p graf-after--h3">For any organization, finances are always a significant concern, particularly when it comes to database expenses, which can be quite substantial. While we aim to minimize costs wherever possible, the options available to us are limited. However, let’s quickly summarize the three methods to squeeze out available space:</p><ol class="postList"><li name="bd7f" id="bd7f" class="graf graf--li graf-after--p">Remove useless indexes</li><li name="f237" id="f237" class="graf graf--li graf-after--li">Remove useless data</li><li name="1d7a" id="1d7a" class="graf graf--li graf-after--li">Reshard</li></ol><p name="ec17" id="ec17" class="graf graf--p graf-after--li">These three methods are in his order of precedence, with the first one being the quickest to implement and having the least impact on the production environment, and vice versa.</p><p name="d7ee" id="d7ee" class="graf graf--p graf-after--p">Moreover, executing solutions 2 and 3 requires additional processes to ensure that the space is genuinely available and not occupied.</p><p name="1b5c" id="1b5c" class="graf graf--p graf-after--p graf--trailing">Perhaps there are some secret techniques that I haven’t thought of yet. Feel free to share them with me.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/40c731a923c4"><time class="dt-published" datetime="2023-10-16T02:01:10.632Z">October 16, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/squeezing-out-mongodbs-available-storage-40c731a923c4" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>