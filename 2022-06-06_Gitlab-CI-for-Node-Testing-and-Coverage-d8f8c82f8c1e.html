<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Gitlab CI for Node Testing and Coverage</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Gitlab CI for Node Testing and Coverage</h1>
</header>
<section data-field="subtitle" class="p-summary">
A look at the Gitlab CI v15.0 features for Nodejs
</section>
<section data-field="body" class="e-content">
<section name="2cde" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2469" id="2469" class="graf graf--h3 graf--leading graf--title">Gitlab CI for Node Testing and Coverage</h3><h4 name="7f02" id="7f02" class="graf graf--h4 graf-after--h3 graf--subtitle">A look at the Gitlab CI v15.0 features for Nodejs</h4><figure name="ff3d" id="ff3d" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*rX050J7TAy3HREr3" data-width="1000" data-height="667" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*rX050J7TAy3HREr3"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@frostroomhead" data-href="https://unsplash.com/@frostroomhead" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Rodion Kutsaev</a> on <a href="https://unsplash.com/photos/xNdPWGJ6UCQ" data-href="https://unsplash.com/photos/xNdPWGJ6UCQ" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="7e5f" id="7e5f" class="graf graf--p graf-after--figure">Gitlab is a popular open-source version control system which is free to use and can be built on an intranet, and Gitlab has many useful features such as Gitlab CI.</p><p name="b3c7" id="b3c7" class="graf graf--p graf-after--p">Gitlab has been integrating CI/CD pipelines into Gitlab for a long time, and has evolved the so-called <a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html" data-href="https://docs.gitlab.com/ee/topics/gitlab_flow.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Gitlab Flow</a>. In this article, I won’t go through the entire Gitlab CI guide, nor will I explain the CI/CD concept, but will focus on how to make Node testing reports more presentable.</p><p name="a282" id="a282" class="graf graf--p graf-after--p">Why this topic? The main reason is that we often use <code class="markup--code markup--p-code">nyc</code> and <code class="markup--code markup--p-code">mocha</code> together to build testing reports for Node, but such a combination needs a little twist in order to fit into the rich functionality of Gitlab. This article is about those approaches and will use an actual <code class="markup--code markup--p-code">.gitlab-ci.yml</code> as an example.</p><blockquote name="34a9" id="34a9" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Please be aware that this article is written based on Gitlab v15.0</em></blockquote><h3 name="cb21" id="cb21" class="graf graf--h3 graf-after--blockquote">Testing Report</h3><p name="e213" id="e213" class="graf graf--p graf-after--h3">In a good testing report, we will need several important features.</p><ol class="postList"><li name="8aa5" id="8aa5" class="graf graf--li graf-after--p">an artifact of the full report.</li><li name="ae6a" id="ae6a" class="graf graf--li graf-after--li">test summary for each <em class="markup--em markup--li-em">Pull Request</em> or <em class="markup--em markup--li-em">Merge Request</em>.</li><li name="d7f4" id="d7f4" class="graf graf--li graf-after--li">the change coverage of each <em class="markup--em markup--li-em">Pull Request</em> or <em class="markup--em markup--li-em">Merge Request</em>.</li><li name="b3c4" id="b3c4" class="graf graf--li graf-after--li">the status of the entire pipeline, including the latest success or failure and its coverage, preferably in the form of a badge.</li></ol><h3 name="7493" id="7493" class="graf graf--h3 graf-after--li">Report Artifacts</h3><figure name="9e69" id="9e69" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*zQGFgwZT3Hsd5mDq.png" data-width="622" data-height="482" src="https://cdn-images-1.medium.com/max/800/0*zQGFgwZT3Hsd5mDq.png"></figure><p name="3720" id="3720" class="graf graf--p graf-after--figure">This is the latest pipeline report, to be able to be downloaded here, we need to add a new <code class="markup--code markup--p-code">artifacts</code> field to specify the path we want to export at the desired stage. For example, in the figure above, the setting would be as follows.</p><pre name="dcde" id="dcde" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">test_ci:<br>  script:<br>    - npm run test<br>  artifacts:<br>    paths:<br>      - coverage/</code></pre><p name="08dc" id="08dc" class="graf graf--p graf-after--pre">This means we will export everything under the <code class="markup--code markup--p-code">coverage</code> folder as a package.</p><h3 name="44a3" id="44a3" class="graf graf--h3 graf-after--p">Test Summary</h3><figure name="5205" id="5205" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*MhOZvjqVgGGe4Skr.png" data-width="1916" data-height="222" src="https://cdn-images-1.medium.com/max/800/0*MhOZvjqVgGGe4Skr.png"></figure><p name="96aa" id="96aa" class="graf graf--p graf-after--figure">In order to display the results of a test in <em class="markup--em markup--p-em">Merge Request</em>, including how many cases were tested and how many succeeded or failed, and even to see how long each case took, you need to let Gitlab know the format of the testing report and produce the results in the corresponding format.</p><p name="00ee" id="00ee" class="graf graf--p graf-after--p">So let’s continue to extend the <code class="markup--code markup--p-code">.gitlab-ci.yml</code> example above.</p><pre name="3903" id="3903" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">test_ci:<br>  script:<br>    - npm run test<br>  artifacts:<br>    paths:<br>      - coverage/<br>    reports:<br>      junit:<br>        - test-results.xml</code></pre><p name="1362" id="1362" class="graf graf--p graf-after--pre">In this example, we use the JUnit format to create the testing report and inform Gitlab of the path to the CI report. In this way, Gitlab has the ability to present the correct report content and summary in each <em class="markup--em markup--p-em">Merge Request</em>.</p><h3 name="5f34" id="5f34" class="graf graf--h3 graf-after--p"><a href="https://docs.gitlab.com/ee/user/project/merge_requests/test_coverage_visualization.html" data-href="https://docs.gitlab.com/ee/user/project/merge_requests/test_coverage_visualization.html" class="markup--anchor markup--h3-anchor" rel="noopener" target="_blank">Change Coverage</a></h3><p name="7b6c" id="7b6c" class="graf graf--p graf-after--h3">When doing a code review, we all click into <em class="markup--em markup--p-em">Changes</em> to see what parts have been changed.</p><figure name="06d1" id="06d1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*fbRPSpLv0dsZUkWv.png" data-width="832" data-height="88" src="https://cdn-images-1.medium.com/max/800/0*fbRPSpLv0dsZUkWv.png"></figure><p name="6d02" id="6d02" class="graf graf--p graf-after--figure">It would be more efficient for the reviewer to see the test coverage of the changes here in one place. So, we would like to make it easy for the reviewer to know which code has not been tested.</p><figure name="9b9f" id="9b9f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*aSHkT7J0mEQ3xjZ-.png" data-width="118" data-height="688" src="https://cdn-images-1.medium.com/max/800/0*aSHkT7J0mEQ3xjZ-.png"></figure><p name="f0b9" id="f0b9" class="graf graf--p graf-after--figure">In this picture, we can see at a glance that line 14 is not covered by the test, while the other lines are tested. It is worth mentioning that even if there is test coverage, it does not mean that the test is complete, for example, here it is impossible to determine the conditions of the boundary test, and we have to rely on the experience of the reviewer.</p><p name="ba99" id="ba99" class="graf graf--p graf-after--p">Then, we continue to extend the original settings.</p><pre name="8869" id="8869" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">test_ci:<br>  script:<br>    - npm run test<br>  artifacts:<br>    paths:<br>      - coverage/<br>    reports:<br>      junit:<br>        - test-results.xml<br>      coverage_report:<br>        coverage_format: cobertura<br>        path: coverage/cobertura-coverage.xml</code></pre><h3 name="b4d7" id="b4d7" class="graf graf--h3 graf-after--pre"><a href="https://gitlab.svc.langlive.tech/help/ci/yaml/index#coverage" data-href="https://gitlab.svc.langlive.tech/help/ci/yaml/index#coverage" class="markup--anchor markup--h3-anchor" rel="noopener" target="_blank">Pipeline Badges</a></h3><figure name="b60d" id="b60d" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*WSekN_7jQQonrbiD.png" data-width="492" data-height="72" src="https://cdn-images-1.medium.com/max/800/0*WSekN_7jQQonrbiD.png"></figure><p name="21d9" id="21d9" class="graf graf--p graf-after--figure">In popular open source projects nowadays, users are informed of the project’s health at the beginning of <code class="markup--code markup--p-code">README.md</code>, which is a useful information for users and a quick way for developers to know the project’s health.</p><p name="e4fe" id="e4fe" class="graf graf--p graf-after--p">If you see the status of the pipeline as a failure, something is wrong. On the other hand, the coverage badge is a great indicator of whether the project’s test coverage is complete.</p><p name="fe98" id="fe98" class="graf graf--p graf-after--p">Fortunately, badges are a built-in feature of Gitlab. You can find out the badge location at Gitlab settings.</p><blockquote name="f039" id="f039" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Settings &gt; CI/CD &gt; General pipelines</em></blockquote><p name="5a69" id="5a69" class="graf graf--p graf-after--blockquote">There are three types of badges, <em class="markup--em markup--p-em">Pipeline status</em>, <em class="markup--em markup--p-em">Coverage report</em>, and <em class="markup--em markup--p-em">Latest release</em>. You can pick what you want.</p><p name="14e6" id="14e6" class="graf graf--p graf-after--p">Since Gitlab v15.0, we can assign a regular expression in <strong class="markup--strong markup--p-strong">re2 syntax</strong> at <code class="markup--code markup--p-code">.gitlab-ci.yml</code> to identify what the coverage digits are.</p><pre name="15de" id="15de" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">test_ci:<br>  script:<br>    - npm run test<br>  coverage: &#39;/All files\s+\|\s+\d+\.\d+/&#39;</code></pre><p name="6553" id="6553" class="graf graf--p graf-after--pre">The rule for this <strong class="markup--strong markup--p-strong">re2 syntax</strong> is to find the floating point number that follows <code class="markup--code markup--p-code">All files</code> as the coverage. If you are not using <code class="markup--code markup--p-code">nyc</code>, you have to adjust the rule based on the content.</p><h3 name="1d6a" id="1d6a" class="graf graf--h3 graf-after--p">Detail in <code class="markup--code markup--h3-code">package.json</code></h3><p name="df78" id="df78" class="graf graf--p graf-after--h3">The above example has fully implemented the necessary features for development. But we haven’t explained how to generate coverage reports, JUnit reports, and change coverage at the same time.</p><p name="b36a" id="b36a" class="graf graf--p graf-after--p">The key to all of this is in the <code class="markup--code markup--p-code">npm run test</code>, i. e. <code class="markup--code markup--p-code">package.json</code>.</p><pre name="0e6b" id="0e6b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">{<br>  &quot;script&quot;: {<br>    &quot;test&quot;: &quot;nyc --reporter=html --reporter=text --reporter=cobertura mocha&quot;<br>  }<br>}</code></pre><p name="2bcf" id="2bcf" class="graf graf--p graf-after--pre">As we can see from the above settings, this busy <code class="markup--code markup--p-code">nyc</code> is responsible for generating three types of outputs for the three different features.</p><ul class="postList"><li name="1863" id="1863" class="graf graf--li graf-after--p">html: Serves as a coverage report for the entire project, and will be used when downloading artifacts.</li><li name="b3a8" id="b3a8" class="graf graf--li graf-after--li">text: The console output is required to generate the badges.</li><li name="8086" id="8086" class="graf graf--li graf-after--li">cobertura: As we know from the previous section, the change coverages are presented using the <code class="markup--code markup--li-code">cobertura</code> format.</li></ul><p name="6c84" id="6c84" class="graf graf--p graf-after--li">Wait, there’s one missing? Who creates the reports for JUnit? The answer is <code class="markup--code markup--p-code">mocha</code>. But this is not a built-in feature of <code class="markup--code markup--p-code">mocha</code>, so we have to use an additional tool to do it.</p><p name="3d2e" id="3d2e" class="graf graf--p graf-after--p">First, download the <code class="markup--code markup--p-code">mocha-junit-reporter</code> package.</p><pre name="c801" id="c801" class="graf graf--pre graf-after--p">npm i mocha-junit-reporter — save-dev</pre><p name="c06e" id="c06e" class="graf graf--p graf-after--pre">Next, create the <code class="markup--code markup--p-code">mocha</code> configuration file, <code class="markup--code markup--p-code">.mocharc.js</code>.</p><pre name="994b" id="994b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">module.exports = {<br>  reporter: &quot;./junit-spec-reporter.js&quot;<br>};</code></pre><p name="dd8b" id="dd8b" class="graf graf--p graf-after--pre">In the configuration file we tell <code class="markup--code markup--p-code">mocha</code> to generate the report through another file, which is also the JUnit generator.</p><p name="18d8" id="18d8" class="graf graf--p graf-after--p">The following is the content of <code class="markup--code markup--p-code">junit-spec-reporter.js</code>.</p><pre name="f3de" id="f3de" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const mocha = require(&quot;mocha&quot;);<br>const JUnit = require(&quot;mocha-junit-reporter&quot;);<br>const Spec = mocha.reporters.Spec;<br>const Base = mocha.reporters.Base;</code></pre><pre name="7c64" id="7c64" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function JunitSpecReporter(runner, options) {<br>  Base.call(this, runner, options);<br>  this._junitReporter = new JUnit(runner, options);<br>  this._specReporter = new Spec(runner, options);<br>  return this;<br>}<br>JunitSpecReporter.prototype.__proto__ = Base.prototype;</code></pre><pre name="9bca" id="9bca" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">module.exports = JunitSpecReporter;</code></pre><p name="cfa7" id="cfa7" class="graf graf--p graf-after--pre">At this point, all the formats we need can be generated correctly, and Gitlab CI will present a rich view based on these outputs, and developers can do most of their routine work on Gitlab’s web page without actually building the outputs locally.</p><h3 name="9eef" id="9eef" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="f668" id="f668" class="graf graf--p graf-after--h3">CI/CD is a very important software development practice. However, in order for every developer to have the interest and even the confidence to “continue” the practice, people must be able to “see” the change.</p><p name="46f4" id="46f4" class="graf graf--p graf-after--p">For engineers, seeing is believing is the belief of most of us. Therefore, these rich features are essential for the pipeline to be effective enough.</p><p name="db87" id="db87" class="graf graf--p graf-after--p">The full <code class="markup--code markup--p-code">.gitlab-ci.yml</code>, which includes all mentioned features, is as follows.</p><pre name="cb1e" id="cb1e" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">test_ci:<br>  script:<br>    - npm run test<br>  artifacts:<br>    paths:<br>      - coverage/<br>    reports:<br>      junit:<br>        - test-results.xml<br>      coverage_report:<br>        coverage_format: cobertura<br>        path: coverage/cobertura-coverage.xml<br>  coverage: &#39;/All files\s+\|\s+\d+\.\d+/&#39;</code></pre><p name="0080" id="0080" class="graf graf--p graf-after--pre">In my experience, when a testing platform is built, not everyone is happy to use it, after all, writing tests is extra work. But when the platform is rich enough, most people will be willing to try it.</p><p name="876d" id="876d" class="graf graf--p graf-after--p">For a team just starting to establish a development process, it’s more important to get people willing to try it than anything else.</p><p name="4f3f" id="4f3f" class="graf graf--p graf-after--p graf--trailing">So this article focuses on the presentation of Gitlab CI and introduces the role of CI from a different perspective in the development process.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/d8f8c82f8c1e"><time class="dt-published" datetime="2022-06-06T01:29:21.290Z">June 6, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/gitlab-ci-for-node-testing-and-coverage-d8f8c82f8c1e" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>