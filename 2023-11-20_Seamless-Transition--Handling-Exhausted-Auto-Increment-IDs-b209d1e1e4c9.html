<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Seamless Transition: Handling Exhausted Auto-Increment IDs</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Seamless Transition: Handling Exhausted Auto-Increment IDs</h1>
</header>
<section data-field="subtitle" class="p-summary">
Navigating Breaking Changes with Unified Queries and Gradual Schema Upgrades
</section>
<section data-field="body" class="e-content">
<section name="a484" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1aad" id="1aad" class="graf graf--h3 graf--leading graf--title">Seamless Transition: Handling Exhausted Auto-Increment IDs</h3><h4 name="3ff3" id="3ff3" class="graf graf--h4 graf-after--h3 graf--subtitle">Navigating Breaking Changes with Unified Queries and Gradual Schema Upgrades</h4><figure name="b9e4" id="b9e4" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*Enmt3c0SHgFHdfXM" data-width="1000" data-height="667" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*Enmt3c0SHgFHdfXM"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@lakoni_creative" data-href="https://unsplash.com/@lakoni_creative" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Nuril Ahsan</a> on <a href="https://unsplash.com/photos/a-large-green-and-white-tower-next-to-a-road-QoNI4StOPgU" data-href="https://unsplash.com/photos/a-large-green-and-white-tower-next-to-a-road-QoNI4StOPgU" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="4a64" id="4a64" class="graf graf--p graf-after--figure">When we are using a relational database, we often use incremental ID as the primary key (e.g. <code class="markup--code markup--p-code">AUTO_INCREMENT</code> in MySQL or <code class="markup--code markup--p-code">SERIAL</code> in Postgres), have you ever thought about what will happen if the incremental ID is used up?</p><p name="a89b" id="a89b" class="graf graf--p graf-after--p">For example, Postgres raises the following error.<br><code class="markup--code markup--p-code">ERROR: nextval: reached maximum value of sequence &quot;&lt;table_name&gt;_&lt;pk&gt;_seq&quot;</code>.</p><p name="adaf" id="adaf" class="graf graf--p graf-after--p">Don’t feel hard of happening, it is possible to accidentally set the primary key to <code class="markup--code markup--p-code">SERIAL</code> instead of <code class="markup--code markup--p-code">BIGSERIAL</code>, and then a value larger than <strong class="markup--strong markup--p-strong">2147483647</strong> will overflow. For a database, it’s not a big number.</p><p name="786e" id="786e" class="graf graf--p graf-after--p">If such a problem unfortunately occurs, what should we do to solve this?</p><p name="898f" id="898f" class="graf graf--p graf-after--p">There are a lot of articles on how to migrate data from the original table to a new table, but in fact, I don’t recommend it. Of course, it’s easiest to migrate all the data to a new table at once, but there are several problems like the following.</p><ol class="postList"><li name="b1d8" id="b1d8" class="graf graf--li graf-after--p">Migrating a large volume data consumes a lot of database resources, and will have a significant impact on the production environment.</li><li name="8e31" id="8e31" class="graf graf--li graf-after--li">Data inconsistency is inevitable during the migration process. For example, if data is migrated to a new table and then a new version of application is deployed to read and write the new table, if there is data written to the old table during the migration period, then there will be inconsistency.</li><li name="e360" id="e360" class="graf graf--li graf-after--li">If there is a downstream application that listens for updates to the source database (or CDC), then the downstream application will be flooded with events.</li></ol><p name="ce56" id="ce56" class="graf graf--p graf-after--li">Therefore, I recommend that applications support both old and new tables. Creating new data is always written to the new table, but reading or updating is done according to whether the data is in the old table or the new table.</p><p name="8935" id="8935" class="graf graf--p graf-after--p">But how? For querying, should I look for the new table first and then the old table as in the example below?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="a838" id="a838" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span> (ret := find_orig_table(params)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br />    <span class="hljs-keyword">return</span> ret<br /><span class="hljs-keyword">elif</span> (ret := find_new_table(params)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br />    <span class="hljs-keyword">return</span> ret<br /><span class="hljs-keyword">else</span>:<br />    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span></pre><p name="6565" id="6565" class="graf graf--p graf-after--pre">Actually, there is an even simpler approach.</p><h3 name="57ce" id="57ce" class="graf graf--h3 graf-after--p">Solution Detail</h3><p name="bd78" id="bd78" class="graf graf--p graf-after--h3">To better describe the solution, let’s prepare the test environment with Postgres.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="801e" id="801e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_with_auto_increment (<br />    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,<br />    common_column1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br />    common_column2 <span class="hljs-type">INTEGER</span>,<br />    common_column3 TEXT<br />);<br /><span class="hljs-keyword">CREATE</span> EXTENSION IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> &quot;uuid-ossp&quot;;<br /><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_with_uuid_primary_key (<br />    id UUID <span class="hljs-keyword">DEFAULT</span> uuid_generate_v4() <span class="hljs-keyword">PRIMARY</span> KEY,<br />    common_column1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br />    common_column2 <span class="hljs-type">INTEGER</span>,<br />    common_column3 TEXT<br />);</span></pre><p name="c918" id="c918" class="graf graf--p graf-after--pre">Above is an old table (<code class="markup--code markup--p-code">table_with_auto_increment</code>) with <code class="markup--code markup--p-code">SERIAL</code> as primary key, it is easy to overflow, so we want to replace it with a new table (<code class="markup--code markup--p-code">table_with_uuid_primary_key</code>) with UUID as primary key.</p><blockquote name="ef83" id="ef83" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">There is a lot of debate on whether UUID as primary key is good or bad, but that’s not the point of this article, it’s just one of the examples.</em></blockquote><p name="f2ed" id="f2ed" class="graf graf--p graf-after--blockquote">Based on such a table structure, it will have a DTO (data transfer object) similar to the following.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="4340" id="4340" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass<br /><span class="hljs-meta">@dataclass</span><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">DTO</span>:<br />    <span class="hljs-built_in">id</span>: ...<br />    common_column1: ...<br />    common_column2: ...<br />    common_column3: ...</span></pre><p name="5e61" id="5e61" class="graf graf--p graf-after--pre">The DTO will be the same whether using the new table or the old table, so the business logic does not have to be modified during the migration process.</p><p name="c5de" id="c5de" class="graf graf--p graf-after--p">Then, what’s the problem of looking for the new table first and then the old one? The main problem is twice accessing the database is two round trips, which leads to one more expense, and secondly, the two functions also have maintenance complexity. Therefore, it would be great if there is a way to use one database access to assemble a DTO from two tables.</p><p name="e06c" id="e06c" class="graf graf--p graf-after--p">The first idea was to use <code class="markup--code markup--p-code">UNION</code>. However, it is worth mentioning that <code class="markup--code markup--p-code">UNION</code> requires both tables to have exactly the same datatype, and the <code class="markup--code markup--p-code">id</code> of our old and new tables are of different types.</p><p name="635f" id="635f" class="graf graf--p graf-after--p">Therefore, we need to convert the id type at the same time with <code class="markup--code markup--p-code">UNION</code>, and converting both of them to <code class="markup--code markup--p-code">text</code> is the simplest way. This is done in the following example.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="b80d" id="b80d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> id::text, common_column1, common_column2, common_column3<br /><span class="hljs-keyword">FROM</span> table_with_auto_increment<br /><span class="hljs-keyword">WHERE</span> common_column1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-keyword">AND</span> common_column2 <span class="hljs-operator">=</span> <span class="hljs-number">123</span><br /><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br /><span class="hljs-keyword">SELECT</span> id::text, common_column1, common_column2, common_column3<br /><span class="hljs-keyword">FROM</span> table_with_uuid_primary_key<br /><span class="hljs-keyword">WHERE</span> common_column1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-keyword">AND</span> common_column2 <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;</span></pre><p name="8c10" id="8c10" class="graf graf--p graf-after--pre">Our search criteria is <code class="markup--code markup--p-code">common_column1</code> is <code class="markup--code markup--p-code">test</code> and <code class="markup--code markup--p-code">common_column2</code> is 123, so we search both tables directly and combine the results. In general, only one of the two tables will have data ( with no bugs ), so it is very efficient to create the DTO in this way.</p><p name="589c" id="589c" class="graf graf--p graf-after--p">In this example, the purpose of creating two tables is to change ids seamlessly, so we can simplify the process through type conversion.</p><p name="45cd" id="45cd" class="graf graf--p graf-after--p">However, there are other scenarios where our functionality iteration leads to breaking change, so we make two tables to allow the old application to gradually transition to the new application, it may not be possible to simply do type conversion (maybe the types are not compatible at all).</p><p name="e407" id="e407" class="graf graf--p graf-after--p">So, we can consider to use <code class="markup--code markup--p-code">OUTER JOIN</code> method, and use the common field as the key of <code class="markup--code markup--p-code">JOIN</code>, so that the result will be the union of the fields of the two tables.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="5a96" id="5a96" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span><br />    t1.id <span class="hljs-keyword">AS</span> t1_id, t2.id <span class="hljs-keyword">AS</span> t2_id,<br />    <span class="hljs-built_in">COALESCE</span>(t1.common_column1, t2.common_column1) <span class="hljs-keyword">AS</span> common_column1,<br />    <span class="hljs-built_in">COALESCE</span>(t1.common_column2, t2.common_column2) <span class="hljs-keyword">AS</span> common_column2,<br />    <span class="hljs-built_in">COALESCE</span>(t1.common_column3, t2.common_column3) <span class="hljs-keyword">AS</span> common_column3<br /><span class="hljs-keyword">FROM</span><br />    table_with_auto_increment t1<br /><span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span><br />    table_with_uuid_primary_key t2<br /><span class="hljs-keyword">ON</span> t1.common_column1 <span class="hljs-operator">=</span> t2.common_column1 <span class="hljs-keyword">AND</span> t1.common_column2 <span class="hljs-operator">=</span> t2.common_column2<br /><span class="hljs-keyword">WHERE</span><br />    t1.common_column1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-keyword">AND</span> t1.common_column2 <span class="hljs-operator">=</span> <span class="hljs-number">123</span><br /><span class="hljs-keyword">OR</span><br />    t2.common_column1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-keyword">AND</span> t2.common_column2 <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;</span></pre><p name="84b1" id="84b1" class="graf graf--p graf-after--pre">The above example is very similar to <code class="markup--code markup--p-code">UNION</code>, we need to find out <code class="markup--code markup--p-code">common_column1</code> is <code class="markup--code markup--p-code">test</code> and <code class="markup--code markup--p-code">common_column2</code> is 123 in two tables, but we need to list the remaining columns.</p><p name="26e2" id="26e2" class="graf graf--p graf-after--p">Nevertheless, the whole SQL is a bit annoying, such as the series of <code class="markup--code markup--p-code">COALESCE</code>, so I suggest some template rendering to make the development more intuitive.</p><p name="3690" id="3690" class="graf graf--p graf-after--p">Here’s an example of using Python with <code class="markup--code markup--p-code">jinja2</code>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="bf84" id="bf84" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">from</span> jinja2 <span class="hljs-keyword">import</span> Template<br />columns = [<span class="hljs-string">&#x27;common_column1&#x27;</span>, <span class="hljs-string">&#x27;common_column2&#x27;</span>, <span class="hljs-string">&#x27;common_column3&#x27;</span>]<br />template_str = <span class="hljs-string">&quot;&quot;&quot;SELECT<br />    t1.id AS t1_id, t2.id AS t2_id<br />{% for column in columns %}<br />    , COALESCE(t1.{{ column }}, t2.{{ column }}) AS {{ column }}<br />{% endfor %}<br />FROM<br />    table_with_auto_increment t1<br />FULL OUTER JOIN<br />    table_with_uuid_primary_key t2<br />ON t1.{{condition_column1}} = t2.{{condition_column1}} and t1.{{condition_column2}} = t2.{{condition_column2}}<br />WHERE<br />    t1.{{condition_column1}} = &#x27;{{condition_value1}}&#x27; AND t1.{{condition_column2}} = {{condition_value2}}<br />OR<br />    t2.{{condition_column1}} = &#x27;{{condition_value1}}&#x27; AND t2.{{condition_column2}} = {{condition_value2}};<br />&quot;&quot;&quot;</span><br />condition_column1 = <span class="hljs-string">&#x27;common_column1&#x27;</span><br />condition_column2 = <span class="hljs-string">&#x27;common_column2&#x27;</span><br />condition_value1 = <span class="hljs-string">&#x27;test&#x27;</span><br />condition_value2 = <span class="hljs-number">123</span><br />template = Template(template_str)<br />query = template.render(<br />    columns=columns,<br />    condition_column1=condition_column1, condition_column2=condition_column2,<br />    condition_value1=condition_value1, condition_value2=condition_value2<br />)<br /><span class="hljs-built_in">print</span>(query)</span></pre><p name="d3cc" id="d3cc" class="graf graf--p graf-after--pre">At this point, we’ve been able to make the transition from the old table structure to the new one seamless for the application.</p><h3 name="606e" id="606e" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="f8ac" id="f8ac" class="graf graf--p graf-after--h3">Although in this article we have introduced how to solve the problem of <code class="markup--code markup--p-code">id</code> exhaustion, it can be used in any scenario where we need to make a breaking change to the table structure of the database.</p><p name="1fcc" id="1fcc" class="graf graf--p graf-after--p">When the data volume is small, breaking change is not a big deal, we just need to migrate all the old tables to the new ones, but when the data volume is huge, such an approach will increase a lot of operation risks.</p><p name="fa91" id="fa91" class="graf graf--p graf-after--p">A complete table migration involves not only the data migration itself, but also how to keep the production environment unaffected. The most common problem we encountered is how to synchronize the data to the new table if there are still clients writing to the old table during the data migration period.</p><p name="f7b8" id="f7b8" class="graf graf--p graf-after--p">In addition, in order to avoid affecting the production environment, we usually have to choose the off-peak time to perform the migration, which inevitably requires many departments to work overtime together.</p><p name="f91f" id="f91f" class="graf graf--p graf-after--p">For instance, the development team needs to release a new version of the program, the operation team needs to migrate the data, the SRE team needs to monitor the risk of online, and the QA team needs to validate. It is not worth for me to work so hard just for the sake of table migration.</p><p name="a7d9" id="a7d9" class="graf graf--p graf-after--p">Therefore, it’s best to be able to upgrade your application to a new version seamlessly. This article introduces a simple but effective practice to avoid many unnecessary breaking changes. Of course, there are many different ways to achieve this, if you have some good solutions, please feel free to share them with me.</p><h3 name="0731" id="0731" class="graf graf--h3 graf-after--p">Stackademic</h3><p name="8fa1" id="8fa1" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Thank you for reading until the end. Before you go:</em></p><ul class="postList"><li name="72db" id="72db" class="graf graf--li graf-after--p"><em class="markup--em markup--li-em">Please consider </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">clapping</em></strong><em class="markup--em markup--li-em"> and </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">following</em></strong><em class="markup--em markup--li-em"> the writer! 👏</em></li><li name="06a7" id="06a7" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Follow us on </em><a href="https://twitter.com/stackademichq" data-href="https://twitter.com/stackademichq" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Twitter(X)</em></strong></a><em class="markup--em markup--li-em">, </em><a href="https://www.linkedin.com/company/stackademic" data-href="https://www.linkedin.com/company/stackademic" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">LinkedIn</em></strong></a><em class="markup--em markup--li-em">, and </em><a href="https://www.youtube.com/c/stackademic" data-href="https://www.youtube.com/c/stackademic" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">YouTube</em></strong></a><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">.</em></strong></li><li name="1ced" id="1ced" class="graf graf--li graf-after--li graf--trailing"><em class="markup--em markup--li-em">Visit </em><a href="http://stackademic.com/" data-href="http://stackademic.com/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Stackademic.com</em></strong></a><em class="markup--em markup--li-em"> to find out more about how we are democratizing free programming education around the world.</em></li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/b209d1e1e4c9"><time class="dt-published" datetime="2023-11-20T01:46:37.797Z">November 20, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/seamless-transition-handling-exhausted-auto-increment-ids-b209d1e1e4c9" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>