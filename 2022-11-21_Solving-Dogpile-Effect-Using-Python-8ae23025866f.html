<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Solving Dogpile Effect Using Python</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Solving Dogpile Effect Using Python</h1>
</header>
<section data-field="subtitle" class="p-summary">
A workable code solution
</section>
<section data-field="body" class="e-content">
<section name="a2de" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d2c1" id="d2c1" class="graf graf--h3 graf--leading graf--title">Solving Dogpile Effect Using Python</h3><h4 name="1fe7" id="1fe7" class="graf graf--h4 graf-after--h3 graf--subtitle">A workable code solution</h4><figure name="2358" id="2358" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*R0lFWt4K4t8gxa9Q" data-width="1000" data-height="643" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*R0lFWt4K4t8gxa9Q"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@jneumeyer" data-href="https://unsplash.com/@jneumeyer" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Judi Neumeyer</a> on <a href="https://unsplash.com/photos/ECjHeJtRznQ" data-href="https://unsplash.com/photos/ECjHeJtRznQ" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="8b97" id="8b97" class="graf graf--p graf-after--figure">Last time, we talked about how to solve <a href="https://betterprogramming.pub/solving-dogpile-effect-9d869174d302" data-href="https://betterprogramming.pub/solving-dogpile-effect-9d869174d302" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Dogpile Effect</a>.</p><p name="6fc1" id="6fc1" class="graf graf--p graf-after--p">Three approaches are mentioned as follows:</p><ol class="postList"><li name="2a3d" id="2a3d" class="graf graf--li graf-after--p">Warm Up Cache</li><li name="ed83" id="ed83" class="graf graf--li graf-after--li">Extend Cache Time</li><li name="4959" id="4959" class="graf graf--li graf-after--li">Exclusive Lock</li></ol><p name="0d2c" id="0d2c" class="graf graf--p graf-after--li">However, we also mentioned that each of the three approaches has its own applicable scenario and its corresponding potential risks. So is there a way to extract the advantages of each and construct a more complete solution?</p><p name="16b5" id="16b5" class="graf graf--p graf-after--p">This article will provide an example and explain my ideas.</p><h3 name="7b58" id="7b58" class="graf graf--h3 graf-after--p">Solution Concept</h3><p name="1f2b" id="1f2b" class="graf graf--p graf-after--h3">Extending the cache time effectively improves the availability of the cache. When the cache is not valid and is requested at the same time, only one request can get through the cache and into the backend system. The rest of the requests will get the original result as the cache time is extended.</p><p name="02f0" id="02f0" class="graf graf--p graf-after--p">However, when concurrent requests occur at the same time ( which is generally uncommon), there is still the possibility of multiple requests entering the backend system, hence the exclusive lock approach.</p><p name="9ad4" id="9ad4" class="graf graf--p graf-after--p">Nevertheless, the cost of using exclusive locks all the time is too high, and we should try to minimize the use of exclusive locks if possible. Then, use the exclusive lock only when the cache does not exist and there is a need to access the backend system, else just use the extend cache time.</p><p name="4649" id="4649" class="graf graf--p graf-after--p">The whole process is as follows.</p><figure name="51de" id="51de" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5F1C1C3x8yiWirjGyOxDfg.png" data-width="1150" data-height="312" src="https://cdn-images-1.medium.com/max/800/1*5F1C1C3x8yiWirjGyOxDfg.png"></figure><p name="afe1" id="afe1" class="graf graf--p graf-after--figure">First of all, determine whether the cache exists, if the cache exists we still have to determine whether the cache is expired. If everything is fine, we can just take the original value of the cache, but if the cache is expired, we must enter the process of updating the cache.</p><p name="b183" id="b183" class="graf graf--p graf-after--p">In order to avoid the impact of high concurrent requests, all update cache processes should try to acquire a lock.</p><p name="0e52" id="0e52" class="graf graf--p graf-after--p">On the other hand, if the cache does not exist from the beginning, then the process of updating the cache will be the same. Only the process is different as mentioned above, because there is no original value, so those who did not acquire the lock must wait for the lock before they can get the result.</p><h3 name="45b6" id="45b6" class="graf graf--h3 graf-after--p">Solution Overview</h3><p name="6cda" id="6cda" class="graf graf--p graf-after--h3">Before we get into the details of the implementation, let’s look at the actual practice.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="3544" id="3544" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_aside_cached</span>(<span class="hljs-params">ttl, lock_period, race_period</span>):<br />  <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrap</span>(<span class="hljs-params">*args, **kw</span>):<br />      key = <span class="hljs-string">f&quot;<span class="hljs-subst">{func.__name__}</span>_<span class="hljs-subst">{args}</span>_<span class="hljs-subst">{kw}</span>&quot;</span><br />      <span class="hljs-keyword">return</span> cache_factory(key, ttl, lock_period, race_period).handle(func, *args, **kw)<br />      <br />    <span class="hljs-keyword">return</span> wrap<br />  <span class="hljs-keyword">return</span> decorator<br /><br /><span class="hljs-meta">@read_aside_cached(<span class="hljs-params"><span class="hljs-number">60</span> * <span class="hljs-number">5</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span></span>)</span><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b=<span class="hljs-number">1</span>, c=<span class="hljs-number">2</span></span>):<br />  <span class="hljs-keyword">return</span> db.query(a, b, c)</span></pre><p name="b7ba" id="b7ba" class="graf graf--p graf-after--pre">This is an example in Python where we use a decorator to encapsulate an actual database operation.</p><p name="3b01" id="3b01" class="graf graf--p graf-after--p">This decorator requires several parameters.</p><ol class="postList"><li name="0c47" id="0c47" class="graf graf--li graf-after--p">ttl, this is easy to understand, it is the expiry time of this cache.</li><li name="fbe9" id="fbe9" class="graf graf--li graf-after--li">lock_period, because we need to acquire the lock, so this parameter determines how long we have to lock.</li><li name="4cd6" id="4cd6" class="graf graf--li graf-after--li">race_period, this parameter is used to determine how long we want to extend the cache.</li></ol><p name="6cae" id="6cae" class="graf graf--p graf-after--li">In the above example, <code class="markup--code markup--p-code">foo</code> has a cache expiry time of 5 minutes and retains a 1 minute buffer. The lock time is 30 seconds, which is related to the expected time of the database operation.</p><h3 name="1d2c" id="1d2c" class="graf graf--h3 graf-after--p">Solution Details</h3><p name="bc79" id="bc79" class="graf graf--p graf-after--h3">Next, let’s break down the actual details of the flowchart.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="1f36" id="1f36" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cache_factory</span>(<span class="hljs-params">key, ttl, lock_period, race_period</span>):<br />  value, expired_at = Store.get(key)<br />  <br />  <span class="hljs-keyword">if</span> expired_at <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br />    handler = ExistedCacheHandler(key, ttl, lock_period, race_period)<br />  <span class="hljs-keyword">else</span>:<br />    handler = NonExistedCacheHandler(key, ttl, lock_period, race_period)<br /><br />  handler.set_meta(value, expired_at)<br />  <span class="hljs-keyword">return</span> handler</span></pre><p name="3497" id="3497" class="graf graf--p graf-after--pre">At the beginning of the flowchart, we need to try to get a cache first and use the results to see if we need to extend the cache time.</p><p name="41bd" id="41bd" class="graf graf--p graf-after--p">The top and bottom paths of the flowchart are encapsulated by each class. Let’s look at the implementation of <code class="markup--code markup--p-code">ExistedCacheHandler</code> first.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="c157" id="c157" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExistedCacheHandler</span>(<span class="hljs-title class_ inherited__">BaseCacheHandler</span>):<br />  <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">self, func, *args, **kw</span>):<br />    <span class="hljs-keyword">if</span> self.now &gt; self.expired_at <span class="hljs-keyword">and</span> Store.try_lock(self.key, self.lock_period):<br />      result = func(*args, **kw)<br />      Store.<span class="hljs-built_in">set</span>(self.key, result, self.ttl + self.race_period)<br />      Store.unlock(self.key)<br />      <span class="hljs-keyword">return</span> result<br /><br />    <span class="hljs-keyword">return</span> self.orig_val</span></pre><p name="8904" id="8904" class="graf graf--p graf-after--pre">If a cache has expired and successfully acquires a lock, it is responsible for updating the cache.</p><p name="19ea" id="19ea" class="graf graf--p graf-after--p"><a href="https://betterprogramming.pub/solving-dogpile-effect-9d869174d302" data-href="https://betterprogramming.pub/solving-dogpile-effect-9d869174d302" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">In the previous article</a>, we introduced the Rails approach, where Rails writes the original value back to the cache again and extends the valid time slightly. But here, we directly let the cache time be <code class="markup--code markup--p-code">(ttl + race_period)</code>, so we don’t need to extend the cache time manually.</p><p name="1d13" id="1d13" class="graf graf--p graf-after--p">On the contrary, if the cache has not expired or has not been locked, then the original result in the cache is used.</p><p name="64b7" id="64b7" class="graf graf--p graf-after--p">On the other hand, the logic of cache not exist is more complicated.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="00b3" id="00b3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonExistedCacheHandler</span>(<span class="hljs-title class_ inherited__">BaseCacheHandler</span>):<br />  <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">self, func, *args, **kw</span>):<br />    <span class="hljs-keyword">while</span> self.expired_at <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br />      <span class="hljs-keyword">if</span> Store.try_lock(self.key, self.lock_period):<br />        result = func(*args, **kw)<br />        Store.<span class="hljs-built_in">set</span>(self.key, result, self.ttl + self.race_period)<br />        Store.unlock(self.key)<br />        <span class="hljs-keyword">return</span> result<br />      <span class="hljs-keyword">else</span>:<br />        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> Store.try_lock(self.key, self.lock_period):<br />          time.sleep(<span class="hljs-number">0.01</span>)<br />          self.orig_val, self.expired_at = Store.get(self.key)<br />        <br />        Store.unlock(self.key)<br />    <span class="hljs-keyword">else</span>:<br />      <span class="hljs-keyword">return</span> self.orig_val</span></pre><p name="6fa9" id="6fa9" class="graf graf--p graf-after--pre">When a cache is found to be non-existed, we still have to acquire the lock in order to update the cache. But if the lock is not acquired successfully, we must wait, either for the lock or for the cache to be updated.</p><p name="23cd" id="23cd" class="graf graf--p graf-after--p">Why should we wait for either of these two conditions?</p><p name="58c2" id="58c2" class="graf graf--p graf-after--p">The reason is the person who acquired the lock may not have released the lock for “some reason”. Our ultimate goal is to get the cache result, so even if we don’t get the lock, we still get the result. Of course, if the lock is successfully acquired, the responsibility of updating the cache will be taken up.</p><p name="e0a1" id="e0a1" class="graf graf--p graf-after--p">Finally, let’s look at two common components.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="7bc3" id="7bc3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span>:<br /><span class="hljs-meta">  @staticmethod</span><br />  <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">k</span>):<br />    value = redis.get(k)<br />    expired_at = redis.pttl(k) / <span class="hljs-number">1000</span> + time.time() <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br />    <span class="hljs-keyword">return</span> value, expired_at<br />    <br /><span class="hljs-meta">  @staticmethod</span><br />  <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">k, v, ttl</span>):<br />    <span class="hljs-keyword">return</span> redis.<span class="hljs-built_in">set</span>(k, v, <span class="hljs-string">&quot;EX&quot;</span>, ttl)<br /><br /><span class="hljs-meta">  @staticmethod</span><br />  <span class="hljs-keyword">def</span> <span class="hljs-title function_">try_lock</span>(<span class="hljs-params">k, lock_period</span>):<br />    r = redis.<span class="hljs-built_in">set</span>(k, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;NX&quot;</span>, <span class="hljs-string">&quot;EX&quot;</span>, lock_period)<br />    <span class="hljs-keyword">return</span> r == <span class="hljs-string">&quot;OK&quot;</span><br /><span class="hljs-meta">  @staticmethod</span><br />  <span class="hljs-keyword">def</span> <span class="hljs-title function_">unlock</span>(<span class="hljs-params">k</span>):<br />    redis.<span class="hljs-keyword">del</span>(k)<br />    <br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseCacheHandler</span>:<br />  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key, ttl, lock_period, race_period</span>):<br />    self.key = key<br />    self.ttl = ttl<br />    self.lock_period = lock_period<br />    self.race_period = race_period<br />  <br />  <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_meta</span>(<span class="hljs-params">self, value, expired_at</span>):<br />    self.orig_val = value<br />    self.expired_at = expired_at</span></pre><p name="1a82" id="1a82" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">BaseCacheHandler</code> defines the constructors and a helper function.</p><p name="f179" id="f179" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Store</code> is the core of the whole implementation, and I use Redis as a demonstration.</p><ul class="postList"><li name="bce7" id="bce7" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">get()</code>: In addition to getting the cache value, we also need to get the expiry time of the cache.</li><li name="82a6" id="82a6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">set()</code>: Write the value and also set the expiry time.</li><li name="6a4e" id="6a4e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">try_lock()</code>: Use Redis’ atomic update to lock with <code class="markup--code markup--li-code">NX</code>.</li><li name="6a50" id="6a50" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">unlock()</code>: simply removes the key.</li></ul><p name="fad0" id="fad0" class="graf graf--p graf-after--li">By assembling all these pieces, the cache decorator is complete, not only with the ability to extend the cache time but also with exclusive lock support.</p><h3 name="aafe" id="aafe" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="83ed" id="83ed" class="graf graf--p graf-after--h3">This is a workable example, and we have arranged it in a more intuitive way to make it easier to understand. However, there are some things that could be refined.</p><p name="128a" id="128a" class="graf graf--p graf-after--p">For example, many places currently use a single command to operate Redis directly, and it would be better to write it in <a href="https://redis.io/docs/manual/pipelining/" data-href="https://redis.io/docs/manual/pipelining/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Redis pipeline</a>. Moreover, it would be a good idea to write some simple logic as a script in Lua.</p><p name="327f" id="327f" class="graf graf--p graf-after--p">I have to say such an implementation is actually very complex, but does a read-aside cache really need to do that?</p><p name="3c55" id="3c55" class="graf graf--p graf-after--p">It depends on the load of the application and what we expect from the application.</p><p name="bc70" id="bc70" class="graf graf--p graf-after--p">If the backend system is strong and can handle a sudden spike, then a regular extended cache time can work. But if the backend is weak, it is necessary to consider a more solid approach.</p><p name="ebf9" id="ebf9" class="graf graf--p graf-after--p">Enhancing the caching mechanism is one option, but enhancing the backend system is also an option. There are several common ways to enhance the availability of the backend system.</p><ol class="postList"><li name="08d0" id="08d0" class="graf graf--li graf-after--p">circuit breaker pattern</li><li name="9895" id="9895" class="graf graf--li graf-after--li">service degradation</li><li name="327b" id="327b" class="graf graf--li graf-after--li">multi-layer caching</li></ol><p name="957e" id="957e" class="graf graf--p graf-after--li graf--trailing">This article provides an option to enhance the cache, without the need to deploy new components and just modify the logic, in my opinion, it is still worth it.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/8ae23025866f"><time class="dt-published" datetime="2022-11-21T01:46:49.204Z">November 21, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/solving-dogpile-effect-completely-in-code-8ae23025866f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>