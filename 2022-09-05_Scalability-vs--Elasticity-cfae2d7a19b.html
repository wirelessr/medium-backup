<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Scalability vs. Elasticity</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Scalability vs. Elasticity</h1>
</header>
<section data-field="subtitle" class="p-summary">
Understanding the main difference between scalability and elasticity
</section>
<section data-field="body" class="e-content">
<section name="0896" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="759f" id="759f" class="graf graf--h3 graf--leading graf--title">Scalability vs. Elasticity</h3><h4 name="24ac" id="24ac" class="graf graf--h4 graf-after--h3 graf--subtitle">Understanding the main difference between scalability and elasticity</h4><figure name="fca2" id="fca2" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*P_sNDP3G-T3YHj_Y" data-width="1000" data-height="686" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*P_sNDP3G-T3YHj_Y"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@daniele_franchi" data-href="https://unsplash.com/@daniele_franchi" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Daniele Franchi</a> on <a href="https://unsplash.com/photos/SXRhpwKcMpc" data-href="https://unsplash.com/photos/SXRhpwKcMpc" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="9b6a" id="9b6a" class="graf graf--p graf-after--figure">In system design, there are two single words are confusing, which are scalability and elasticity. They are so similar that we don’t distinguish them correctly.</p><p name="d90d" id="d90d" class="graf graf--p graf-after--p">However, when we want to solve the issues caused by these two non-functional requirements individually, we need completely different approaches.</p><p name="c3bc" id="c3bc" class="graf graf--p graf-after--p">Therefore, in order to design the right approach we have to know them and recognize their properties. In this article, we will talk about what scalability and elasticity are and how to treat the symptoms.</p><h3 name="67b6" id="67b6" class="graf graf--h3 graf-after--p">Scalability</h3><p name="42e6" id="42e6" class="graf graf--p graf-after--h3">We often talked about horizontal scalability and vertical scalability, i. e., scale-out, and scale-up.</p><p name="6bb2" id="6bb2" class="graf graf--p graf-after--p">But what’s good and bad for scalability?</p><p name="f41c" id="f41c" class="graf graf--p graf-after--p">Let’s take a look at an example.</p><figure name="6b2e" id="6b2e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*RUAuNB-u9yy3ELnS.png" data-width="540" data-height="510" src="https://cdn-images-1.medium.com/max/800/0*RUAuNB-u9yy3ELnS.png"></figure><p name="0dd9" id="0dd9" class="graf graf--p graf-after--figure">CPU grows with the time. This is normal. As the system grows, the number of users increases, the feature requirements increase, and thus the resource consumption increases as well. In this case, resources refer to CPU, but it can be applied to other resources, such as memory, response time, etc.</p><p name="8daa" id="8daa" class="graf graf--p graf-after--p">So, if this diagram indicates a normal situation, what diagram indicates a problem?</p><figure name="cf3a" id="cf3a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*qGSKtxooiJ14GsLj.png" data-width="540" data-height="510" src="https://cdn-images-1.medium.com/max/800/0*qGSKtxooiJ14GsLj.png"></figure><p name="ebd6" id="ebd6" class="graf graf--p graf-after--figure">When resource usage does not rise linearly, but exponentially, something is wrong. It could be a bottleneck in usage that results in additional overhead, or a dramatic drop in performance when the amount of data exceeds a certain amount.</p><p name="851c" id="851c" class="graf graf--p graf-after--p">On the other hand, what kind of shape represents good scalability?</p><figure name="b753" id="b753" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*7h5Y68D3yQOzlBzT.png" data-width="540" data-height="510" src="https://cdn-images-1.medium.com/max/800/0*7h5Y68D3yQOzlBzT.png"></figure><p name="d7db" id="d7db" class="graf graf--p graf-after--figure">Similarly, resource usage rises over time, but the rate of increase shrinks, which means that scalability becomes better. The ideal state is a horizontal line, where the resource usage remains constant regardless of the number of users and the increase in feature requirements.</p><p name="e1af" id="e1af" class="graf graf--p graf-after--p">In other words, how to make this line as straight and as close to the horizontal as possible is the issue to be addressed in solving the scalability.</p><h3 name="acf3" id="acf3" class="graf graf--h3 graf-after--p">Elasticity</h3><p name="333d" id="333d" class="graf graf--p graf-after--h3">After talking about scalability, let’s look at an example of elasticity.</p><p name="e218" id="e218" class="graf graf--p graf-after--p">First, let’s also look at the normal situation of a system.</p><figure name="0cc2" id="0cc2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*6APHPIwZ9_H8vmUh.png" data-width="540" data-height="510" src="https://cdn-images-1.medium.com/max/800/0*6APHPIwZ9_H8vmUh.png"></figure><p name="3116" id="3116" class="graf graf--p graf-after--figure">Resource usage fluctuates dramatically over time, with spikes occurring at certain times. It is easy to understand why this happens. Take an e-commerce site for example, when there is a Black Friday sale or Christmas coming up, the system usage will be much higher than usual. Or a ticketing site, when a top singer is going to have a concert, will also attract a large number of people to come to grab tickets.</p><p name="f507" id="f507" class="graf graf--p graf-after--p">So what is good elasticity? It’s about eliminating those spikes, of course.</p><figure name="9722" id="9722" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*yyLOWcLR-drgjx_L.png" data-width="540" data-height="510" src="https://cdn-images-1.medium.com/max/800/0*yyLOWcLR-drgjx_L.png"></figure><p name="a93c" id="a93c" class="graf graf--p graf-after--figure">There are two key points in this diagram.</p><ol class="postList"><li name="5950" id="5950" class="graf graf--li graf-after--p">The red line is more stable than the blue line, but the red line is not a horizontal line.</li><li name="35f2" id="35f2" class="graf graf--li graf-after--li">The red line is significantly higher than the blue line after the occurrence of a spike.</li></ol><p name="2e87" id="2e87" class="graf graf--p graf-after--li">The reason for the first point is simple, because the system usage is not fixed, so the use of resources will vary with the system usage. But in general, it can still be maintained in a stable state and there will be no significant ups and downs.</p><p name="cbea" id="cbea" class="graf graf--p graf-after--p">The second point, I believe, is not difficult to understand: the reason why we can flatten the blue line as much as possible is not to reject all the user requests, but to postpone the instantaneous usage through “a sort of mechanism”. Therefore, after the spike, there will always be a period of digestion, causing the red line to be higher than the blue line.</p><p name="9285" id="9285" class="graf graf--p graf-after--p">You may ask, though, the system can handle so many users without elasticity, so is it still necessary to improve the elasticity to make the effect of the red line?</p><p name="0bad" id="0bad" class="graf graf--p graf-after--p">The answer is, definitely. Why?</p><p name="a9a1" id="a9a1" class="graf graf--p graf-after--p">Because the highest point of the blue line is the limit of what the system can record, and more rejected user requests cannot enter the system and are not recorded. In the moment of the spike, the system’s maximum capacity is defined there, and all requests exceeding it are rejected.</p><p name="fed5" id="fed5" class="graf graf--p graf-after--p">On the other hand, a more elastic system has a smoother resource usage and can handle more user requests without crashing the system.</p><h3 name="00e8" id="00e8" class="graf graf--h3 graf-after--p">The Myth of Autoscaling</h3><p name="f579" id="f579" class="graf graf--p graf-after--h3">Now, we understand the scalability and elasticity. So, can you answer one question?</p><blockquote name="3833" id="3833" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Ask, does autoscaling address the need for scalability or elasticity?</em></blockquote><p name="213d" id="213d" class="graf graf--p graf-after--blockquote">The answer is, scalability.</p><p name="5a63" id="5a63" class="graf graf--p graf-after--p">First of all, the principle of autoscaling is to track specific metrics by sampling and start scaling when the threshold is exceeded for a period of time.</p><p name="2277" id="2277" class="graf graf--p graf-after--p">Therefore, it is already a while after the spike has occurred before scaling can begin. In addition, scaling is not immediately available; even containerized applications have to go through several steps to scale, such as loading the container image and cold-starting it on a new instance. A complex application can take a few minutes from the time it decides to scale to the time it is launched.</p><p name="1739" id="1739" class="graf graf--p graf-after--p">As a result, autoscaling is not about elasticity, but about scalability.</p><p name="55c3" id="55c3" class="graf graf--p graf-after--p">More importantly, autoscaling does not improve the whole system. In other words, autoscaling only allows the system to continue to grow with its original scalability, but does not make it better.</p><p name="4fa6" id="4fa6" class="graf graf--p graf-after--p">One exception is that if elastic requirements can be predicted, then autoscaling can be effectively applied.</p><p name="c88c" id="c88c" class="graf graf--p graf-after--p">For example, if the system receives a large number of requests at the beginning of the workday (e.g., 9:00 a.m.), then the system can be autoscaled by activating it at regular intervals. In this example, setting the time of the autoscaling between 8:30 am and 9:30 am can effectively solve the elasticity problem faced during that time.</p><p name="0bcd" id="0bcd" class="graf graf--p graf-after--p">However, in general, the autoscaling faces the issue of scalability.</p><h3 name="cda9" id="cda9" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="b28c" id="b28c" class="graf graf--p graf-after--h3">In this article, we introduced scalability and elasticity and explained what it looks like after improvement.</p><p name="6c43" id="6c43" class="graf graf--p graf-after--p">Nevertheless, this article does not describe how to improve scalability, because scalability is a systemic issue and there is no one specific solution that can solve it all at once.</p><p name="82f4" id="82f4" class="graf graf--p graf-after--p">First, bottlenecks must be identified, then the root causes must be figured out, and finally different solutions must be proposed for each bottleneck. This requires an extra investment of time and human resources to enable the system evolution, and autoscaling is a compromise to buy time. By spending additional money, the system is given time to evolve and is not shut down by the inability to scale.</p><p name="af1a" id="af1a" class="graf graf--p graf-after--p">But autoscaling is not a long-term solution, and additional analysis, design and implementation costs are required to fundamentally solve the scalability issue.</p><p name="33a5" id="33a5" class="graf graf--p graf-after--p">On the other hand, how to solve the elasticity issue?</p><p name="0121" id="0121" class="graf graf--p graf-after--p">The answer is relatively simple, through caching or messaging. In order to tolerate a large number of requests in a moment, there must be a mechanism to postpone the current spike, and the most commonly used practice is caching.</p><p name="22fe" id="22fe" class="graf graf--p graf-after--p">However, there are many different ways to implement caching, and the balance between caching and consistency is an important issue. I have introduced several caching practices.</p><ol class="postList"><li name="dbf6" id="dbf6" class="graf graf--li graf-after--p"><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-1-f64f4a76720" data-href="https://medium.com/starbugs/consistency-between-cache-and-database-part-1-f64f4a76720" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Consistency between Cache and Database, Part 1</a></li><li name="4266" id="4266" class="graf graf--li graf-after--li"><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-2-e28fc7f8a7c3" data-href="https://medium.com/starbugs/consistency-between-cache-and-database-part-2-e28fc7f8a7c3" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Consistency between Cache and Database, Part 2</a></li></ol><p name="62a2" id="62a2" class="graf graf--p graf-after--li">These are the basic versions of caching, but there are many more advanced caching practices that will be mentioned in subsequent articles.</p><p name="de48" id="de48" class="graf graf--p graf-after--p graf--trailing">The purpose of this article is only to explain the two words that are easily confused, and the only way to find a feasible solution among the many approaches is to correctly understand scalability and elasticity.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/cfae2d7a19b"><time class="dt-published" datetime="2022-09-05T01:40:48.178Z">September 5, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/scalability-vs-elasticity-cfae2d7a19b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>