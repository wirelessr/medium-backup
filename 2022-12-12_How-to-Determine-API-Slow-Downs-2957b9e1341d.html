<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How to Determine API Slow Downs</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How to Determine API Slow Downs</h1>
</header>
<section data-field="subtitle" class="p-summary">
A statistical solution to know if its time to refactor your code
</section>
<section data-field="body" class="e-content">
<section name="09fd" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9c18" id="9c18" class="graf graf--h3 graf--leading graf--title">How to Determine API Slow Downs</h3><h4 name="0376" id="0376" class="graf graf--h4 graf-after--h3 graf--subtitle">A statistical solution to know if its time to refactor your code</h4><figure name="20b9" id="20b9" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*78o50Oz16WdfGi3Z" data-width="1000" data-height="640" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*78o50Oz16WdfGi3Z"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@pascalvendel" data-href="https://unsplash.com/@pascalvendel" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Pascal van de Vendel</a> on <a href="https://unsplash.com/photos/J3pkJFnpDkM" data-href="https://unsplash.com/photos/J3pkJFnpDkM" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="06dd" id="06dd" class="graf graf--p graf-after--figure">API slowdown has a great impact on the user experience or even loss of trust, so we always want to know the latency as early as possible.</p><p name="36f4" id="36f4" class="graf graf--p graf-after--p">Therefore, it is common to integrate performance tests and measurement benchmarks into automation testing.</p><p name="356e" id="356e" class="graf graf--p graf-after--p">But the concept of slow is very difficult to evaluate.</p><ul class="postList"><li name="20fe" id="20fe" class="graf graf--li graf-after--p">Did it happen by accident? Or is it an ongoing status?</li><li name="ca7a" id="ca7a" class="graf graf--li graf-after--li">Is it caused by the experimental environment? Or is it a side effect of the code?</li><li name="9abd" id="9abd" class="graf graf--li graf-after--li">Is it the result of increased features? Or is it a defect?</li></ul><p name="e4ac" id="e4ac" class="graf graf--p graf-after--li">It is difficult to have a clear answer to these questions.</p><p name="0ee0" id="0ee0" class="graf graf--p graf-after--p">Assuming we have a way to detect “slow”, then we will send an alarm or a report. But if it’s just a “coincidence” or a false alarm caused by experimental environments, eventually people will try to ignore these signals.</p><p name="42fa" id="42fa" class="graf graf--p graf-after--p">In addition, it is to be expected that APIs will slow down as features are added. When we have more parameters, more business logic, and more <code class="markup--code markup--p-code">if-else</code>, it’s no wonder that the response time slows down.</p><p name="5ab2" id="5ab2" class="graf graf--p graf-after--p">Furthermore, if we use threshold to avoid the above problem, then when we really recognize API slowdown, we won’t know what the root cause of the slowdown is.</p><p name="2c2f" id="2c2f" class="graf graf--p graf-after--p">All these factors make the task of detecting API slowdowns extremely hard.</p><h3 name="27f0" id="27f0" class="graf graf--h3 graf-after--p">It’s time for statistics to come into play</h3><p name="fdde" id="fdde" class="graf graf--p graf-after--h3">To address the mentioned issues, let’s summarize the requirements.</p><ol class="postList"><li name="1bee" id="1bee" class="graf graf--li graf-after--p">to be able to know specifically when the problem occurs</li><li name="6ef1" id="6ef1" class="graf graf--li graf-after--li">to be able to allow accidental outliers</li><li name="9cf9" id="9cf9" class="graf graf--li graf-after--li">to be able to avoid the normal phenomenon of slow rise</li><li name="9c19" id="9c19" class="graf graf--li graf-after--li">to be able to issue alarms</li></ol><p name="2387" id="2387" class="graf graf--p graf-after--li">First, let’s look at a diagram.</p><figure name="13a9" id="13a9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*tMj_LdNdjVQMAMAY.png" data-width="688" data-height="456" src="https://cdn-images-1.medium.com/max/800/0*tMj_LdNdjVQMAMAY.png"></figure><ul class="postList"><li name="c906" id="c906" class="graf graf--li graf-after--figure">The horizontal axis indicates each test, which can be considered as time or release version, or even if integrated into CI/CD pipeline, that is each commit.</li><li name="d492" id="d492" class="graf graf--li graf-after--li">The vertical axis is the latency of the target tests.</li><li name="46c3" id="46c3" class="graf graf--li graf-after--li">The red line is the main character of this article, Linear Regression.</li></ul><p name="9bc2" id="9bc2" class="graf graf--p graf-after--li">From the diagram, we can know before a certain time, basically the latency is slowly increasing, but after a certain time, the whole latency is rapidly increasing. And that time point is the problem we want to know.</p><p name="3c34" id="3c34" class="graf graf--p graf-after--p">Perhaps you will say, it is easy to find out by the naked eye by looking at the numbers each time? After all, it is quite intuitive.</p><p name="2411" id="2411" class="graf graf--p graf-after--p">The key is the scale of the latency. If the average of the data points from the group below is 0.1 seconds, and the group behind is 0.2 seconds, will you still feel very intuitive?</p><p name="0f08" id="0f08" class="graf graf--p graf-after--p">Therefore, we need a brain-friendly standard, i.e., linear regression.</p><p name="80ea" id="80ea" class="graf graf--p graf-after--p">Through linear regression, we can know the overall trend of the data set is up. However, this is not enough, because just knowing that the trend is up does not mean we can judge whether it is normal or abnormal.</p><p name="f8ed" id="f8ed" class="graf graf--p graf-after--p">The group of dense data points in the front is also up, so how can we determine that the trend is abnormal and the front is normal?</p><p name="21d0" id="21d0" class="graf graf--p graf-after--p">Let’s look at another diagram.</p><figure name="7df5" id="7df5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*2xL-leRQxaIq25eB.png" data-width="688" data-height="456" src="https://cdn-images-1.medium.com/max/800/0*2xL-leRQxaIq25eB.png"></figure><p name="96ec" id="96ec" class="graf graf--p graf-after--figure">Question: Is the latency of this diagram normal or abnormal?</p><p name="b80d" id="b80d" class="graf graf--p graf-after--p">It looks very similar to the previous diagram, there is a clear upward trend, so it should be abnormal, right? Really?</p><p name="9a81" id="9a81" class="graf graf--p graf-after--p">Let’s add some reference points and zoom out a bit.</p><figure name="45da" id="45da" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*tlEi8HA7jn8aX-MG.png" data-width="688" data-height="456" src="https://cdn-images-1.medium.com/max/800/0*tlEi8HA7jn8aX-MG.png"></figure><p name="b817" id="b817" class="graf graf--p graf-after--figure">Have you found? The diagram above is actually a normal part of the original diagram, just a slow rise.</p><p name="ef38" id="ef38" class="graf graf--p graf-after--p">By simply doing linear regression analysis on a single data set, we may get wrong conclusions because we have no benchmark for comparison and cannot tell whether it is a natural phenomenon caused by increased features or a problem caused by defects.</p><h3 name="aa39" id="aa39" class="graf graf--h3 graf-after--p">Solution</h3><p name="793b" id="793b" class="graf graf--p graf-after--h3">Back to our question, how can we detect the problem as early as possible without false positives?</p><p name="5583" id="5583" class="graf graf--p graf-after--p">First, we need to choose a reference point, e.g., one day ago. Then, we perform a linear regression on the entire data to get a red line. Of course, we also need to perform a linear regression on the data before the reference point, which will lead to the green line.</p><p name="8473" id="8473" class="graf graf--p graf-after--p">The slope of the red line and the green line is used to calculate the angle as the judgment basis. In other words, when the angle between the red line and the green line is larger, then it is more likely to be abnormal.</p><p name="5d92" id="5d92" class="graf graf--p graf-after--p">Therefore, the threshold for setting an alarm is neither the latency itself nor the slope, but the angle of the two lines.</p><p name="ff91" id="ff91" class="graf graf--p graf-after--p">Given the slopes of the two lines are k1 and k2, then the formula for the angle θ is as follows.</p><figure name="bea0" id="bea0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*yVcX05DNgFQgVvX1yJQEtw.png" data-width="340" data-height="90" src="https://cdn-images-1.medium.com/max/800/1*yVcX05DNgFQgVvX1yJQEtw.png"></figure><p name="382f" id="382f" class="graf graf--p graf-after--figure">In Python, it would be:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="d37d" id="d37d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> math<br />thera = math.degrees(math.atan2(<span class="hljs-built_in">abs</span>(k2 - k1), <span class="hljs-built_in">abs</span>(<span class="hljs-number">1</span> + k1 * k2)))<br /><span class="hljs-comment"># atan2 does not need to handle denominator zero error cases</span><br /><span class="hljs-comment"># If we use atan</span><br /><span class="hljs-comment"># we need to solve the case where k1 * k2 is equal to -1 first</span></span></pre><p name="d493" id="d493" class="graf graf--p graf-after--pre">We can do several experiments with simulated values to get our ideal alarm threshold.</p><p name="9020" id="9020" class="graf graf--p graf-after--p">Finally, in addition to the angle threshold, we also need another alarm indicator, which is the upper bound of the allowed latency.</p><p name="879f" id="879f" class="graf graf--p graf-after--p">Why do we need to set an upper bound?</p><p name="30d5" id="30d5" class="graf graf--p graf-after--p">Because if our latency keeps increasing in a green line trend, one day it will reach an unacceptable value, but if we just set the angle threshold, we will never know how bad the situation is until we have a disaster on the production.</p><p name="5077" id="5077" class="graf graf--p graf-after--p">Finally, the following is an example of how to compute linear regression in Python.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="b311" id="b311" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br /><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br /><br /><span class="hljs-comment"># raw_x and raw_y are the results of each test</span><br /><span class="hljs-comment"># raw_x can be a time, version or commit normalization</span><br /><span class="hljs-comment"># raw_y are latencies</span><br />x = np.array(raw_x)[:, np.newaxis]<br />y = np.array(raw_y)[:, np.newaxis]<br /><br />bfl = LinearRegression()<br />bfl.fit(x,y)<br />y_pred = bfl.predict(x)<br /><br />slope = bfl.coef_[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span></pre><h3 name="77bd" id="77bd" class="graf graf--h3 graf-after--pre">Conclusion</h3><p name="699c" id="699c" class="graf graf--p graf-after--h3">So, how do we know if the API is slowing down? We need two alerts.</p><ol class="postList"><li name="beaf" id="beaf" class="graf graf--li graf-after--p">the angle between the current data line and the data line of the reference point after linear regression.</li><li name="63f7" id="63f7" class="graf graf--li graf-after--li">the maximum upper bound of the latency.</li></ol><p name="743d" id="743d" class="graf graf--p graf-after--li">When we have these two alarms, we can know exactly when the code is causing problems and if it is time to refactor the system.</p><p name="68a2" id="68a2" class="graf graf--p graf-after--p">In fact, this is a statistical approach to achieve the goal, but there are still some drawbacks to this. For example, how to set the threshold value of the slope angle? How to choose the reference point? What is the statistical range to be chosen? All these questions require experiments to find the answers.</p><p name="cd91" id="cd91" class="graf graf--p graf-after--p">Therefore, the most effective way is to introduce machine learning into the system of latency analysis, and judge whether the current result is normal or abnormal through the prediction model, rather than through human settings. It’s more difficult for humans to make judgments than machines.</p><p name="494f" id="494f" class="graf graf--p graf-after--p graf--trailing">However, to build a machine learning model requires corresponding domain knowledge and skills, which may not be suitable for small organizations, so linear regression is a reliable and low-cost solution.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/2957b9e1341d"><time class="dt-published" datetime="2022-12-12T01:52:44.138Z">December 12, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/how-to-know-api-is-slowing-down-2957b9e1341d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>