<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Stream Processing Introduction</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Stream Processing Introduction</h1>
</header>
<section data-field="subtitle" class="p-summary">
Easy to understand what is streaming architecture
</section>
<section data-field="body" class="e-content">
<section name="2833" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9fb6" id="9fb6" class="graf graf--h3 graf--leading graf--title">Stream Processing Introduction</h3><h4 name="37a1" id="37a1" class="graf graf--h4 graf-after--h3 graf--subtitle">Easy to understand what is streaming architecture</h4><figure name="3efe" id="3efe" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*mMsRDE9XQ6abWUEI" data-width="1000" data-height="660" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*mMsRDE9XQ6abWUEI"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@jachan_devol" data-href="https://unsplash.com/@jachan_devol" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Jachan DeVol</a> on <a href="https://unsplash.com/photos/ssEQdOiKd8U" data-href="https://unsplash.com/photos/ssEQdOiKd8U" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="a12c" id="a12c" class="graf graf--p graf-after--figure">The purpose of this article is to introduce stream processing in an easy-to-understand way, so it does not dive too deep into the technical details, nor does it mention specific frameworks. However, a few popular frameworks will be used as examples to illustrate.</p><p name="b4cc" id="b4cc" class="graf graf--p graf-after--p">Before we start to introduce stream processing, let’s talk about batch processing, i.e., the opposing concept of stream processing.</p><h3 name="4a45" id="4a45" class="graf graf--h3 graf-after--p">Batch processing</h3><p name="5871" id="5871" class="graf graf--p graf-after--h3">I believe most of you are familiar with batch processing, in which a large scale data processing is performed after a given period of data and the final result is produced. This is the actual operation of batch processing, and the expertise area of batch processing is fixed amount of data processing.</p><p name="3ce5" id="3ce5" class="graf graf--p graf-after--p">However, in an event-driven architecture, the data, i.e., the events, are endless, that is to say, it is difficult to define a fixed amount. Therefore, the compromise is to change the fixed amount to a fixed time, so that the amount of data can be expected after a given time interval, and batch processing can be applied.</p><p name="6dfd" id="6dfd" class="graf graf--p graf-after--p">In other words, batch processing can be summarized in several characteristics.</p><ol class="postList"><li name="d0f2" id="d0f2" class="graf graf--li graf-after--p">Fixed. Whether it is fixed time or fixed volume, the key is to make the amount of data predictable.</li><li name="ae84" id="ae84" class="graf graf--li graf-after--li">Discrete. The data is computed in a specific interval, and the intervals are not related to each other at all.</li></ol><p name="bb29" id="bb29" class="graf graf--p graf-after--li">The most typical approach is to process the data at the moment per second/minute/hr/day.</p><h3 name="f032" id="f032" class="graf graf--h3 graf-after--p">Stream processing</h3><p name="8e22" id="8e22" class="graf graf--p graf-after--h3">However, there is a difference in the approach of stream processing.</p><p name="c768" id="c768" class="graf graf--p graf-after--p">First of all, there is no concept of fixation in stream processing. Imagine it as a river, where water keeps flowing down from upstream, and if you don’t catch it where you are at, the water will flow away.</p><p name="d206" id="d206" class="graf graf--p graf-after--p">The same is happening with data. The data source keeps generating data into the stream, and the application has to retrieve what it needs in the stream and use it.</p><p name="84bd" id="84bd" class="graf graf--p graf-after--p">Unlike batch processing, which is fixed time or fixed volume, if there is no given time interval, then the amount of data can be considered basically infinite. On the other hand, since the data is not divided into several time intervals by batching, there is a context between the data.</p><p name="a81a" id="a81a" class="graf graf--p graf-after--p">We can also summarize several characteristics for stream processing, which are exactly the opposite of batch processing.</p><ol class="postList"><li name="3291" id="3291" class="graf graf--li graf-after--p">Infinite. In the lack of a specified time interval, both the amount of data and the time can be considered infinite.</li><li name="9874" id="9874" class="graf graf--li graf-after--li">Continuous. The data in the data stream are related to each other.</li></ol><p name="5343" id="5343" class="graf graf--p graf-after--li">Nevertheless, applications do not work that way, or perhaps it should be said that the human brain cannot understand the concept of continuous infinity. When we develop an application, we always give the input, compute it, and produce the output.</p><p name="918a" id="918a" class="graf graf--p graf-after--p">Therefore, when we develop stream processing applications, we take some techniques to make the data stream fit our mind as much as possible, in other words, we slice the data stream. The method of slicing is called windows.</p><p name="dcb4" id="dcb4" class="graf graf--p graf-after--p">There are three common types of windows.</p><ol class="postList"><li name="5213" id="5213" class="graf graf--li graf-after--p">Tumbling window</li><li name="7930" id="7930" class="graf graf--li graf-after--li">Sliding window</li><li name="b7b2" id="b7b2" class="graf graf--li graf-after--li">Session window</li></ol><h3 name="b2b2" id="b2b2" class="graf graf--h3 graf-after--li">Tumbling window</h3><p name="2cc2" id="2cc2" class="graf graf--p graf-after--h3">The first method of data slicing is tumbling window also known as micro-batch.</p><figure name="f861" id="f861" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*dxpS_mvEQNgKzuQv.png" data-width="1560" data-height="968" src="https://cdn-images-1.medium.com/max/800/0*dxpS_mvEQNgKzuQv.png"><figcaption class="imageCaption"><a href="https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/#tumbling-windows" data-href="https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/#tumbling-windows" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/#tumbling-windows</a></figcaption></figure><p name="1bc6" id="1bc6" class="graf graf--p graf-after--figure">The continuous data is processed by dividing the data into intervals of a fixed time. This is the same concept as batch processing, but the only difference is the length of the time interval. In batch processing, the time span is larger than the tumbling window.</p><p name="52ca" id="52ca" class="graf graf--p graf-after--p">In this way, data streams can be processed in a batch manner. Most of the streaming frameworks support this technique, e.g. Apache Spark Streaming, Apache Flink, Apache Samza, etc.</p><h3 name="5c18" id="5c18" class="graf graf--h3 graf-after--p">Sliding window</h3><p name="1954" id="1954" class="graf graf--p graf-after--h3">The second approach is the sliding window.</p><figure name="18ea" id="18ea" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*L-Kn6bGZ1POF3PH2.png" data-width="1560" data-height="968" src="https://cdn-images-1.medium.com/max/800/0*L-Kn6bGZ1POF3PH2.png"><figcaption class="imageCaption"><a href="https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/#sliding-windows" data-href="https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/#sliding-windows" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/#sliding-windows</a></figcaption></figure><p name="cd40" id="cd40" class="graf graf--p graf-after--figure">Given a window size and a window slide to move the window, a sliding window will be created. As you can see from the diagram, it is possible to overlap data between windows, and therefore to discover the context of the data.</p><p name="f41c" id="f41c" class="graf graf--p graf-after--p">The tumbling window mentioned in the previous section is actually a special case of a sliding window. When the window size is equal to the window slide, the sliding window becomes a tumbling window.</p><p name="b0de" id="b0de" class="graf graf--p graf-after--p">This is a very common data slicing pattern used in streaming, and not every streaming framework supports it; Apache Spark has streaming capabilities, but it only supports micro-batches.</p><h3 name="3b4f" id="3b4f" class="graf graf--h3 graf-after--p">Session window</h3><p name="e9e6" id="e9e6" class="graf graf--p graf-after--h3">The third approach is the session window.</p><figure name="9038" id="9038" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*HbEb7ZCscU5L_Aua.png" data-width="1560" data-height="968" src="https://cdn-images-1.medium.com/max/800/0*HbEb7ZCscU5L_Aua.png"><figcaption class="imageCaption"><a href="https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/#session-windows" data-href="https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/#session-windows" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://nightlies.apache.org/flink/flink-docs-master/docs/dev/datastream/operators/windows/#session-windows</a></figcaption></figure><p name="4d05" id="4d05" class="graf graf--p graf-after--figure">Unlike the previous two methods, the session window does not have a fixed window size; instead, it has to wait until the data stops for a period of time, which is called session gap.</p><p name="fff3" id="fff3" class="graf graf--p graf-after--p">After the data is stopped for a period of time, the received data segments are processed, so the real-time performance is slightly worse than the previous two methods. However, since the data is grouped in advance and accumulated for a period of time, it is easier to process.</p><p name="bb59" id="bb59" class="graf graf--p graf-after--p">In addition, the session window provides an additional information about the data density at this point by the amount of data collected.</p><p name="c16d" id="c16d" class="graf graf--p graf-after--p">Again, this is not supported by every streaming framework, and Apache Spark does not support it.</p><h3 name="7499" id="7499" class="graf graf--h3 graf-after--p">Summary</h3><p name="1ca3" id="1ca3" class="graf graf--p graf-after--h3">It sounds like stream processing is the same as traditional message queue processing, where a broker stores the message and assigns it to a handler responsible for execution.</p><p name="f454" id="f454" class="graf graf--p graf-after--p">Is the difference only that one is a single message and another is a data stream?</p><p name="431f" id="431f" class="graf graf--p graf-after--p">In fact, this is only one of the differences. Stream processing has three advantages over traditional message workers.</p><ol class="postList"><li name="41c0" id="41c0" class="graf graf--li graf-after--p">Understand the context of the data. Although this depends on the window setting, due to the nature of data streams, they are able to express much more semantically than a single message.</li><li name="9c8d" id="9c8d" class="graf graf--li graf-after--li">Stream processing has state. To enable faster processing of message streams, streaming frameworks provide internal state management and also state persistence.</li><li name="b9b6" id="b9b6" class="graf graf--li graf-after--li">Simultaneous processing of concurrent data streams. In a message queue worker architecture, it would be a challenge to handle multiple messages simultaneously, but in a stream processing framework, it is possible. Furthermore, the framework provides more methods for handling multiple event streams, such as join operations.</li></ol><p name="0f08" id="0f08" class="graf graf--p graf-after--li">Overall, stream processing can be regarded as an advanced version of the message queue worker architecture.</p><p name="4518" id="4518" class="graf graf--p graf-after--p">There are two core components in the entire stream processing. The first one is Kafka as a broker and the other one is the streaming framework.</p><p name="13c4" id="13c4" class="graf graf--p graf-after--p">Kafka is able to provide very good functionality, including fault tolerance, persistence and ensuring message order, while also providing very high throughput.</p><p name="7599" id="7599" class="graf graf--p graf-after--p">On the other hand, the streaming framework is to provide a higher level of abstraction based on Kafka. It can make it easier for developers to get started, including the various windowing methods mentioned in this article and concurrent event stream processing.</p><p name="63a8" id="63a8" class="graf graf--p graf-after--p">More importantly, the streaming framework provides an exactly-once guarantee. in the message queue worker architecture, often only at-least-once guarantee, but in the streaming framework can further support exactly-once.</p><h3 name="1f7c" id="1f7c" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="fd08" id="fd08" class="graf graf--p graf-after--h3">Traditional data processing architectures are very complex and often require various technologies, for example, ETL technology is required to extract and transform data from various data stores into a unified data warehouse or data lake, and various batch processing methods such as Map-reduce must be used to transform data into a useful format during analysis.</p><p name="32e9" id="32e9" class="graf graf--p graf-after--p">In order to solve the real-time problem of batch processing, different message queue processing frameworks are integrated to aggregate the batch dataset with the real-time dataset under specific real-time requirements.</p><p name="c1c8" id="c1c8" class="graf graf--p graf-after--p">The entire data processing architecture involves a variety of storage, message queues, scheduling and processing technologies. It is difficult to become master of all of them, and new requirements have to be developed to continue stacking on top of this complex architecture, which also affects productivity.</p><p name="4648" id="4648" class="graf graf--p graf-after--p">Streaming architectures were created to address these complexities. It is possible to use only two core components, Kafka and the streaming framework, to accomplish various feature requirements that previously required various technology stacks.</p><p name="6522" id="6522" class="graf graf--p graf-after--p">Of course, no technical selection is perfect.</p><p name="849c" id="849c" class="graf graf--p graf-after--p">To me, the biggest problem with stream processing is that it’s not easy, either to understand or to develop. As described earlier in this article, the concept of continuous infinity is not intuitive to humans. Even if it is possible to collapse the stack of techniques into a single solution, it requires developers to have more experience and overcome a learning curve. Moreover, when problems are encountered that cannot be solved by a framework, there is still a need to mix solutions.</p><p name="2e6e" id="2e6e" class="graf graf--p graf-after--p">Nevertheless, the streaming framework still offers a good entry point to meet most development needs with minimal overhead.</p><p name="a74e" id="a74e" class="graf graf--p graf-after--p graf--trailing">The next article will introduce a common streaming design pattern, which is enrichments. Let’s call it a day.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/796f15061880"><time class="dt-published" datetime="2022-08-22T01:18:09.179Z">August 22, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/stream-processing-introduction-796f15061880" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>