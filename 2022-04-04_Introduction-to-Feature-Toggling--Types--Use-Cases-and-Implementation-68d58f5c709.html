<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Introduction to Feature Toggling— Types, Use Cases and Implementation</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Introduction to Feature Toggling— Types, Use Cases and Implementation</h1>
</header>
<section data-field="subtitle" class="p-summary">
many scenarios where feature toggles can be used and how to treat them properly
</section>
<section data-field="body" class="e-content">
<section name="e55e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="eeff" id="eeff" class="graf graf--h3 graf--leading graf--title">Introduction to Feature Toggling— Types, Use Cases, and Implementation</h3><h4 name="4052" id="4052" class="graf graf--h4 graf-after--h3 graf--subtitle">Know the many scenarios where feature toggles can be used and how to treat them properly</h4><figure name="3cf3" id="3cf3" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*92ROY5iQcpAhd5PG" data-width="3456" data-height="2160" data-unsplash-photo-id="vFhsyAMbHkE" src="https://cdn-images-1.medium.com/max/800/0*92ROY5iQcpAhd5PG"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@arthurbizkit?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@arthurbizkit?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Arthur Mazi</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="2c81" id="2c81" class="graf graf--p graf-after--figure">I have been using <a href="https://lazypro.medium.com/trunk-based-development-can-help-4bb425595c00" data-href="https://lazypro.medium.com/trunk-based-development-can-help-4bb425595c00" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">trunk-based development</a> for some time to improve productivity in the team I supervise. In order to perform trunk-based development smoothly, feature toggle plays an important role in it, so I use this article to introduce feature toggles, what kinds of toggles are included and how to use them.</p><p name="f815" id="f815" class="graf graf--p graf-after--p">But before we get to that, let’s talk about a concept that is easily confused. What is the difference between feature toggle and configuration?</p><p name="d311" id="d311" class="graf graf--p graf-after--p">First, wherever a configuration is stored, such as a file, or a central storage system, such as <a href="https://www.consul.io/docs/intro" data-href="https://www.consul.io/docs/intro" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Consul by HashiCorp</a>, it is considered static. When the system is initialized, the entire configuration file is stored in each instance’s memory to reduce unnecessary I/O overhead. That is, if a setting is to be modified, the associated instance must be restarted in order to reload the setting into memory.</p><p name="0cf6" id="0cf6" class="graf graf--p graf-after--p">On the other hand, a feature toggle does not work this way; a feature toggle calls the management system each time to get the current settings for the instance or even the feature. Therefore, the feature toggle is more dynamic than the configuration.</p><p name="57c4" id="57c4" class="graf graf--p graf-after--p">Let’s use code as an example.</p><p name="0d4a" id="0d4a" class="graf graf--p graf-after--p">If it is a configuration file, it will look like the following.</p><pre name="387b" id="387b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const config = loadConfigFromSomewhere();<br>function foo() {<br>    if (config.featureA) doA();<br>    else doB();<br>}</code></pre><p name="1d88" id="1d88" class="graf graf--p graf-after--pre">As for the feature toggle, it is a little different.</p><pre name="da9c" id="da9c" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const connection = initFeatureToggle();<br>function bar() {<br>    if (connection.isEnabled(&quot;featureA&quot;)) doA();<br>    else doB();<br>}</code></pre><p name="2187" id="2187" class="graf graf--p graf-after--pre">As you can see from the above example, the configuration is fixed after <code class="markup--code markup--p-code">loadConfigFromSomewhere</code>, and then the value is just taken from the variable. However, the feature toggle may get a different result each time when calling <code class="markup--code markup--p-code">isEnabled</code>, depending on the current environment.</p><h3 name="c576" id="c576" class="graf graf--h3 graf-after--p">What kinds of feature toggles are there?</h3><figure name="0898" id="0898" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*T7Hdo7lVIXXrxnag.png" data-width="1024" data-height="768" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*T7Hdo7lVIXXrxnag.png"><figcaption class="imageCaption"><a href="https://martinfowler.com/articles/feature-toggles.html" data-href="https://martinfowler.com/articles/feature-toggles.html" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://martinfowler.com/articles/feature-toggles.html</a></figcaption></figure><p name="2f4e" id="2f4e" class="graf graf--p graf-after--figure">There are four types of feature toggles.</p><ol class="postList"><li name="319e" id="319e" class="graf graf--li graf-after--p">Release Toggles</li><li name="41ef" id="41ef" class="graf graf--li graf-after--li">Ops Toggles</li><li name="af78" id="af78" class="graf graf--li graf-after--li">Experiment Toggles</li><li name="e399" id="e399" class="graf graf--li graf-after--li">Permission Toggles</li></ol><p name="cd14" id="cd14" class="graf graf--p graf-after--li">There are two dimensions in the diagram, dynamism and longevity.</p><ul class="postList"><li name="e9a2" id="e9a2" class="graf graf--li graf-after--p">Dynamism said that the frequency of the toggle will be changed, the closer to the right side means the more frequently the toggle will be changed.</li><li name="355b" id="355b" class="graf graf--li graf-after--li">Longevity refers to how long the toggle will stay in the source code, the closer to the bottom the shorter the retention time.</li></ul><p name="3d85" id="3d85" class="graf graf--p graf-after--li">The release toggle in the blue area is relatively static and is only used when a feature is released, and will be removed when the feature is stable. On the other hand, the toggles in the green area are relatively dynamic and may change according to various needs.</p><h3 name="7556" id="7556" class="graf graf--h3 graf-after--p">Release Toggles</h3><p name="f78c" id="f78c" class="graf graf--p graf-after--h3">Release toggle is the most commonly used form of toggle and is intended to control the impact scope of each release.</p><p name="5661" id="5661" class="graf graf--p graf-after--p">Assuming there is a new requirement for this release, the code for that new requirement should be fully encapsulated by the toggle for this release. At the moment of release, the default toggle should be off, in other words, the behavior of this release and the last release should be exactly the same.</p><p name="37d4" id="37d4" class="graf graf--p graf-after--p">When the release is successful, the toggle can be turned on gradually on demand. At first, it may be 1% of the calls will get turned on, then 5%, then 10% and so on. In this way, the functionality is gradually opened to 100%. Such an approach is also known as the canary release.</p><p name="cd6f" id="cd6f" class="graf graf--p graf-after--p">Alternatively, the toggle is turned on all the way at the beginning. Once any problem is encountered, the toggle is turned off completely to avoid a disaster affecting the entire system. The practice is known as blue-green deployment.</p><p name="c34d" id="c34d" class="graf graf--p graf-after--p">It is important to note that the life cycle of these release toggles should be just a short period of time. These toggles should be removed from the code as soon as it is determined that the functionality is stable. If you don’t do this, the code will be filled with more and more toggles, which in return will cause a maintenance effort.</p><h3 name="05c8" id="05c8" class="graf graf--h3 graf-after--p">Ops Toggles</h3><p name="7303" id="7303" class="graf graf--p graf-after--h3">Ops toggles are different from release toggles because release toggles are designed to react to each release, but ops toggles are designed to handle changes to the infrastructure. When the infrastructure has to be upgraded or migrated for some purpose, it can be managed through ops toggles.</p><p name="9449" id="9449" class="graf graf--p graf-after--p">For example, if a system starts with a distributed tracking system called <code class="markup--code markup--p-code">Elastic APM</code> and wants to replace it with <code class="markup--code markup--p-code">jaeger</code> for budget or maintenance reasons, then an ops toggle can be used to switch between the two systems. Until we are sure that <code class="markup--code markup--p-code">jaeger</code> can be operated correctly, the two systems will coexist, possibly with a half-monitoring ratio of 50-50. The ops toggle will remain in place until we are confident that we can replace the original system with <code class="markup--code markup--p-code">jaeger</code>, so the duration will be much longer than the release toggle.</p><p name="2b7a" id="2b7a" class="graf graf--p graf-after--p">Another example of using ops toggle is a manual circuit breaker. For a high throughput system, a rate limit algorithm is usually implemented, but once the traffic reaches a certain level, it is necessary to directly cut off the excess traffic to avoid impacting the whole system. It is ideal for the system to be able to adjust and recover itself, however, such a mechanism is highly complex and difficult to do well at the beginning, so ops toggle is a good choice.</p><p name="bca3" id="bca3" class="graf graf--p graf-after--p">This toggle will also exist for a long time until the developer has a way to implement an automatic mechanism.</p><h3 name="a63f" id="a63f" class="graf graf--h3 graf-after--p">Experiment Toggles</h3><p name="9000" id="9000" class="graf graf--p graf-after--h3">Experiment toggles, as the name suggests, are toggles that are used to perform experiments. When a feature has two different behaviors and we want to evaluate the effectiveness of these two behaviors, we use experiment toggles, and the process of experimentation is called A/B testing.</p><p name="7b69" id="7b69" class="graf graf--p graf-after--p">It operates a bit like a release toggle, but unlike a release toggle that allows old and new behaviors to coexist, an experiment toggle allows two new behaviors to coexist. It may even be possible to bring in more experimental parameters through experiment toggles to make the whole experimental process more flexible and efficient.</p><p name="c753" id="c753" class="graf graf--p graf-after--p">Yes, most of the feature toggles can carry additional parameters, not just true or false. Therefore, this can play the most accelerating role for the constantly changing experimental environment.</p><p name="3669" id="3669" class="graf graf--p graf-after--p">Just like other toggles, the experiment toggles should be removed from the code after the experiment is done and the results are confirmed.</p><h3 name="8ff3" id="8ff3" class="graf graf--h3 graf-after--p">Permission Toggles</h3><p name="af05" id="af05" class="graf graf--p graf-after--h3">This last one is the most complex applicable case. From the diagram, we can see that it is both dynamic and long-lived.</p><p name="563a" id="563a" class="graf graf--p graf-after--p">Then, what exactly is the existence of this toggle?</p><p name="14fc" id="14fc" class="graf graf--p graf-after--p">From my point of view, it has two scenarios, one is the system-wide access control and another is the product level access control.</p><p name="d533" id="d533" class="graf graf--p graf-after--p">System-wide access control means that there are certain functions or operations that are only available to specific users, thus we manage these restricted functions through permissions toggles. A little hard to imagine? I’ll provide a pseudo code.</p><pre name="f538" id="f538" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function restrictedFunction() {<br>    const metadata = {userId, userLevel, userRole};<br>    if (connection.isEabled(&quot;featureA&quot;, metadata))<br>        doFunction();<br>    else return;<br>}</code></pre><p name="55c2" id="55c2" class="graf graf--p graf-after--pre">From the above example, we can know that this specific function is only allowed for certain users, and the user must verify his <code class="markup--code markup--p-code">Id</code>, <code class="markup--code markup--p-code">Level</code> and <code class="markup--code markup--p-code">Role</code> to make sure he meets the eligibility criteria before the function is available, otherwise, it will be skipped.</p><p name="c787" id="c787" class="graf graf--p graf-after--p">Such a toggle seems to be very stable, right? In fact, it is not, the verification method may change, originally only <code class="markup--code markup--p-code">Id</code> and <code class="markup--code markup--p-code">Level</code> maybe required, until one day due to demand and add <code class="markup--code markup--p-code">Role</code>. So the rules of the toggle may change with requirements, and the usage context of the toggle may also change as requirements expand.</p><h3 name="ec3b" id="ec3b" class="graf graf--h3 graf-after--p">How to use feature toggles correctly?</h3><p name="42f2" id="42f2" class="graf graf--p graf-after--h3">We’ve already seen what the code looks like when using the feature toggle.</p><pre name="c036" id="c036" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const connection = initFeatureToggle();<br>function bar() {<br>    if (connection.isEnabled(&quot;featureA&quot;)) doA();<br>    else doB();<br>}</code></pre><p name="5b26" id="5b26" class="graf graf--p graf-after--pre">When more and more toggles are made, there will be more and more if-else in between, which actually violates most of the clean code principles. Therefore, you should be extra careful when using feature toggle and follow a few basic principles.</p><ol class="postList"><li name="85b2" id="85b2" class="graf graf--li graf-after--p">Use only where needed.</li><li name="1b4c" id="1b4c" class="graf graf--li graf-after--li">control the number of toggles.</li><li name="2de7" id="2de7" class="graf graf--li graf-after--li">Toggles do not overlap with each other.</li><li name="ec70" id="ec70" class="graf graf--li graf-after--li">Regularly clear the useless toggles.</li></ol><p name="36e5" id="36e5" class="graf graf--p graf-after--li">In addition, the code of using toggles will eventually become as follows.</p><pre name="b500" id="b500" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function bar() {<br>    doB();<br>}</code></pre><p name="22ec" id="22ec" class="graf graf--p graf-after--pre">Because of this, it is very important to be able to remove toggles easily. I recommend using the <em class="markup--em markup--p-em">Factory Method</em> and encapsulating the code with a feature toggle so that only the product inside the <em class="markup--em markup--p-em">Factory Method</em> is removed when removing toggles and not all the external callers are touched. Here is a simple demonstration.</p><pre name="046f" id="046f" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function factory()<br>{<br>    if ( connection.isEnabled(&quot;featureA&quot;, metadata) ) {<br>        return new NewHandler();<br>    } else {<br>        return new OrigHandler();<br>    }<br>}</code></pre><pre name="af65" id="af65" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// qwer.js<br>factory().doA();<br>// asdf.js<br>factory().doB();<br>// zxcv.js<br>factory().doC();</code></pre><p name="ca62" id="ca62" class="graf graf--p graf-after--pre">Wrapping the whole feature toggle judgment in the factory method, the external caller doesn’t need to know whether he gets a new or old handler. when removing the feature toggle in the future, we only needs to modify the factory method and drop the <code class="markup--code markup--p-code">OrigHandler</code>.</p><pre name="4030" id="4030" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function factory()<br>{<br>    return new NewHandler();<br>}</code></pre><p name="bab2" id="bab2" class="graf graf--p graf-after--pre">As a result, whether it is <code class="markup--code markup--p-code">qwer.js</code>, <code class="markup--code markup--p-code">asdf.js</code> or <code class="markup--code markup--p-code">zxcv.js</code> do not need to change.</p><h3 name="be18" id="be18" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="c537" id="c537" class="graf graf--p graf-after--h3">This time we talked about the many scenarios where feature toggles can be used and how to treat them properly, and you should know why trunk-based development needs feature toggles so much because new versions are released frequently and to avoid affecting the online environment. So all unstable modifications must have a mechanism to isolate them. Feature toggles are exactly such a role.</p><p name="b75b" id="b75b" class="graf graf--p graf-after--p">Another commonly mentioned use case in using feature toggles is that once a toggle is modified, it must immediately react to some online functionality. Such a requirement can be achieved through <em class="markup--em markup--p-em">Observer Pattern</em>, but I don’t recommend this kind of conjunction. After all, we know that these toggles will eventually be removed and they should not be involved in the whole domain model, instead, they play the role of coordinator, coordinating between people and systems.</p><p name="90b2" id="90b2" class="graf graf--p graf-after--p graf--trailing">In this article, we have only discussed the use of feature toggles and their considerations, without mentioning specific solutions. Next time I will introduce two famous providers of feature toggle, <a href="https://lazypro.medium.com/unleash-vs-launchdarkly-c35f586ccf49" data-href="https://lazypro.medium.com/unleash-vs-launchdarkly-c35f586ccf49" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">LaunchDarkly and Unleash</a>, and provide some comments and guidelines based on my experience with them respectively.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/68d58f5c709"><time class="dt-published" datetime="2022-04-04T02:22:35.176Z">April 4, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/feature-toggle-introduction-68d58f5c709" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>