<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Boosting Elasticsearch Cluster Performance: 3 Proven Tips</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Boosting Elasticsearch Cluster Performance: 3 Proven Tips</h1>
</header>
<section data-field="subtitle" class="p-summary">
Tuning Elasticsearch Configuration for Improved Resource Utilization
</section>
<section data-field="body" class="e-content">
<section name="f096" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ae4e" id="ae4e" class="graf graf--h3 graf--leading graf--title">Boosting Elasticsearch Cluster Performance: 3 Proven Tips</h3><h4 name="faef" id="faef" class="graf graf--h4 graf-after--h3 graf--subtitle">Tuning Elasticsearch configuration for improved resource utilization</h4><figure name="2a4c" id="2a4c" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*z2L5pXZQ31wrAbZa" data-width="1000" data-height="563" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*z2L5pXZQ31wrAbZa"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@theshubhamdhage" data-href="https://unsplash.com/@theshubhamdhage" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Shubham Dhage</a> on <a href="https://unsplash.com/photos/HBlxnNR0TaQ" data-href="https://unsplash.com/photos/HBlxnNR0TaQ" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="b4c7" id="b4c7" class="graf graf--p graf-after--figure">This article will explain what the application does better from the underlying Elasticsearch implementation, but I’m not going to dive into too much detail in a very obscure way, so I’ll try to use a simplified process.</p><p name="20d7" id="20d7" class="graf graf--p graf-after--p">Before we get started, let’s go over a few important Elasticsearch terminologies.</p><ul class="postList"><li name="6978" id="6978" class="graf graf--li graf-after--p">Index: This is like the table in RDBMS or the collection in MongoDB, not to be confused with index in RDBMS.</li><li name="d549" id="d549" class="graf graf--li graf-after--li">Shard (aka Primary Shard): The access point where the data is written to the index, and of course the data can be read.</li><li name="16f4" id="16f4" class="graf graf--li graf-after--li">Replica: Access point to read data, can not be used to write data.</li></ul><p name="3c08" id="3c08" class="graf graf--p graf-after--li">These terminologies are closely related to today’s three tips.</p><p name="01a1" id="01a1" class="graf graf--p graf-after--p">So, what is the role of these components in Elasticsearch?</p><p name="98cd" id="98cd" class="graf graf--p graf-after--p">Let me illustrate with an example. Suppose we have a two-node Elasticsearch cluster with two indexes, <code class="markup--code markup--p-code">A</code> and <code class="markup--code markup--p-code">B</code>, and they are configured as follows.</p><p name="a2b4" id="a2b4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">A</code> index</p><ul class="postList"><li name="9105" id="9105" class="graf graf--li graf-after--p">number_of_shards = 2</li><li name="c691" id="c691" class="graf graf--li graf-after--li">number_of_replicas = 1</li></ul><p name="46fb" id="46fb" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">B</code> index</p><ul class="postList"><li name="7892" id="7892" class="graf graf--li graf-after--p">number_of_shards = 1</li><li name="1369" id="1369" class="graf graf--li graf-after--li">number_of_replicas = 2</li></ul><p name="e93f" id="e93f" class="graf graf--p graf-after--li">These are the index settings, which clearly indicate how many shards and replica are required, and the following diagram shows how Elasticsearch looks internally.</p><figure name="ace8" id="ace8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-CUpJ39HS6Ob8uF-BkUh-g.png" data-width="1370" data-height="398" src="https://cdn-images-1.medium.com/max/800/1*-CUpJ39HS6Ob8uF-BkUh-g.png"></figure><p name="60e0" id="60e0" class="graf graf--p graf-after--figure">The red block represents the shard, and the normal block is the replica; the user, or application, will access both nodes to manipulate the corresponding data.</p><h3 name="d52d" id="d52d" class="graf graf--h3 graf-after--p">Tip #1: The number of shards should align to the number of nodes</h3><p name="6c0c" id="6c0c" class="graf graf--p graf-after--h3">This tip is limited to those large indexes, because we know the more shards are used, the more evenly the data is distributed, and if the data in each shard is only a little bit and distributed in many nodes, it will cause more search overhead.</p><p name="0be6" id="0be6" class="graf graf--p graf-after--p">According to the official recommendation, the data volume of a shard should be less than 50GB.</p><ul class="postList"><li name="aea1" id="aea1" class="graf graf--li graf-after--p"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/scalability.html#it-depends" data-href="https://www.elastic.co/guide/en/elasticsearch/reference/current/scalability.html#it-depends" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">20–40 GB</a></li><li name="eebb" id="eebb" class="graf graf--li graf-after--li"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/size-your-shards.html#shard-size-recommendation" data-href="https://www.elastic.co/guide/en/elasticsearch/reference/current/size-your-shards.html#shard-size-recommendation" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">10–50 GB</a></li></ul><p name="d68d" id="d68d" class="graf graf--p graf-after--li">Why such a tip? Let’s use a counter-example to observe. Suppose we have many nodes, but each index has only one shard.</p><p name="737f" id="737f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">A</code> index</p><ul class="postList"><li name="27f1" id="27f1" class="graf graf--li graf-after--p">number_of_shards = 1</li><li name="e307" id="e307" class="graf graf--li graf-after--li">number_of_replicas = 3</li></ul><p name="4f4c" id="4f4c" class="graf graf--p graf-after--li">Then the user’s read operations will be evenly distributed on each node, but the write operations will be concentrated on a single node.</p><figure name="82e8" id="82e8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*4GZ6w5qXha429b-0WSuxpA.png" data-width="888" data-height="450" src="https://cdn-images-1.medium.com/max/800/1*4GZ6w5qXha429b-0WSuxpA.png"></figure><p name="009c" id="009c" class="graf graf--p graf-after--figure">In the case of a large volume of writes, such a setting can create a performance bottleneck on a single node and affect every operation on that node.</p><p name="ddd2" id="ddd2" class="graf graf--p graf-after--p">Since Elasticsearch 5.x started to support <a href="https://www.elastic.co/blog/hot-warm-architecture-in-elasticsearch-5-x" data-href="https://www.elastic.co/blog/hot-warm-architecture-in-elasticsearch-5-x" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">hot warm architecture</a>, if a cluster has hot warm architecture enabled, then the number of shards should align to the number of hot nodes.</p><h3 name="3f6c" id="3f6c" class="graf graf--h3 graf-after--p">Tip #2: The document should be routed</h3><p name="9e15" id="9e15" class="graf graf--p graf-after--h3">Let’s continue with the top example, assuming a two-node cluster, and index <code class="markup--code markup--p-code">A</code> has two shards and one replica each.</p><figure name="fff4" id="fff4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*JwANelKigIQwIK4u2gKrJw.png" data-width="888" data-height="450" src="https://cdn-images-1.medium.com/max/800/1*JwANelKigIQwIK4u2gKrJw.png"></figure><p name="193c" id="193c" class="graf graf--p graf-after--figure">When a user writes to a document, which node does he write to?</p><p name="77f3" id="77f3" class="graf graf--p graf-after--p">This is determined by Elasticsearch’s built-in routing rules, briefly, by the following formula.</p><blockquote name="df15" id="df15" class="graf graf--blockquote graf-after--p"><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">shard = hash(_id) % number_of_shards</em></code></blockquote><p name="5730" id="5730" class="graf graf--p graf-after--blockquote">The <code class="markup--code markup--p-code">_id</code> is automatically dispatched by Elasticsearch, but can of course be specified by the user. As for the hash algorithm, it is <code class="markup--code markup--p-code">murmur3</code>, which is not a consistent hash, so a specific shard will be calculated.</p><p name="20b1" id="20b1" class="graf graf--p graf-after--p">So, the worst case would look like the following diagram.</p><figure name="239b" id="239b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NWanLXbsPTjlekLlmHSG9Q.png" data-width="888" data-height="484" src="https://cdn-images-1.medium.com/max/800/1*NWanLXbsPTjlekLlmHSG9Q.png"></figure><p name="d5b9" id="d5b9" class="graf graf--p graf-after--figure">When one user starts a bulk operation, writing a large volume of documents to the cluster, and at the same time, one user is searching, the two users’ operations interfere with each other.</p><p name="032c" id="032c" class="graf graf--p graf-after--p">If there is a way to keep the data of a single user in a single node, then the above case can be effectively avoided. At most, one user’s search performance will be affected when he writes a lot. This is called custom routing.</p><figure name="e180" id="e180" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*eOKyiLeM17wdaNfLzbutEg.png" data-width="888" data-height="484" src="https://cdn-images-1.medium.com/max/800/1*eOKyiLeM17wdaNfLzbutEg.png"></figure><p name="f61d" id="f61d" class="graf graf--p graf-after--figure">Elasticsearch is able to add a <code class="markup--code markup--p-code">routing</code> parameter to read and write operations, so that the formula mentioned earlier becomes</p><blockquote name="77f6" id="77f6" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">shard = hash(routing) % number_of_shards</em></blockquote><p name="31b6" id="31b6" class="graf graf--p graf-after--blockquote">Nevertheless, it is also the need to pay attention to whether there will be a hotspot problem, i.e., data is overly concentrated in certain nodes.</p><p name="8a73" id="8a73" class="graf graf--p graf-after--p">I have an article to explain the <a href="https://medium.com/interviewnoodle/how-to-choose-a-mongodb-shard-key-e4063b636c26" data-href="https://medium.com/interviewnoodle/how-to-choose-a-mongodb-shard-key-e4063b636c26" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">design of sharding keys</a>. Although this article is about MongoDB, the concepts are the same.</p><h3 name="b7a3" id="b7a3" class="graf graf--h3 graf-after--p">Tip #3: Turn off <code class="markup--code markup--h3-code">replica</code> and <code class="markup--code markup--h3-code">refresh</code> when doing a large volume of writes</h3><p name="60c1" id="60c1" class="graf graf--p graf-after--h3">When doing a large volume of writes, stop replication first to reduce resource consumption, and then turn on replication when the large volume of writes is complete. This can significantly reduce write consumption and improve the performance of the cluster.</p><p name="2ab9" id="2ab9" class="graf graf--p graf-after--p">Disabling <code class="markup--code markup--p-code">replica</code> is easy to understand, but what about disabling <code class="markup--code markup--p-code">refresh</code>?</p><p name="b602" id="b602" class="graf graf--p graf-after--p">Before we explain, let’s understand the mechanism of <code class="markup--code markup--p-code">refresh</code>.</p><figure name="8a9d" id="8a9d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*O_PsPEIHWR_rOeJCZz3AbA.png" data-width="984" data-height="390" src="https://cdn-images-1.medium.com/max/800/1*O_PsPEIHWR_rOeJCZz3AbA.png"></figure><p name="0456" id="0456" class="graf graf--p graf-after--figure">When a user writes data to the shard, it is first written to the memory buffer, and the data is invisible to the search operation at this time. Then, Elasticsearch writes the data in the memory buffer to the hard drive via <code class="markup--code markup--p-code">refresh</code> and converts it into <code class="markup--code markup--p-code">Lucene</code> format, and then it is really searchable.</p><p name="c385" id="c385" class="graf graf--p graf-after--p">There are two ways to <code class="markup--code markup--p-code">refresh</code>.</p><ol class="postList"><li name="67ec" id="67ec" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">refresh_interval</code> in Index setting, <code class="markup--code markup--li-code">refresh</code> will be triggered automatically when the time is up.</li><li name="147a" id="147a" class="graf graf--li graf-after--li">Explicitly call Refresh API.</li></ol><p name="7fcd" id="7fcd" class="graf graf--p graf-after--li">We don’t actively invoke the Refresh API during heavy writes, so by turning it off, we mean turning <code class="markup--code markup--p-code">refresh_interval</code> longer or even off.</p><p name="5ec7" id="5ec7" class="graf graf--p graf-after--p">Of course, either turning off <code class="markup--code markup--p-code">replica</code> or turning off <code class="markup--code markup--p-code">refresh</code> is to reduce resource consumption so that all resources can be dedicated to processing large amounts of writes.</p><p name="16a0" id="16a0" class="graf graf--p graf-after--p">So, you may wonder, won’t turning off <code class="markup--code markup--p-code">refresh</code> cause data loss?</p><p name="70ce" id="70ce" class="graf graf--p graf-after--p">No, it won’t.</p><p name="60f3" id="60f3" class="graf graf--p graf-after--p">The reason is that Elasticsearch’s persistence model relies on more than just <code class="markup--code markup--p-code">refresh</code>. Let’s dig a little deeper.</p><figure name="c1e1" id="c1e1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-j9Nnp1xHknLlOcXZfIAxg.png" data-width="660" data-height="904" src="https://cdn-images-1.medium.com/max/800/1*-j9Nnp1xHknLlOcXZfIAxg.png"></figure><p name="5ea6" id="5ea6" class="graf graf--p graf-after--figure">From the above diagram, we can see even the process of writing from the memory buffer to the hard drive is not really on the hard drive yet, it still needs to go through <code class="markup--code markup--p-code">flush</code> before it is really persisted.</p><p name="e921" id="e921" class="graf graf--p graf-after--p">However, this is a pretty long path, which is totally unreliable for a database, so in fact, when writing data, it will write to two places at the same time: the memory buffer and the transaction log.</p><p name="70df" id="70df" class="graf graf--p graf-after--p">In the event of a disaster, the entire written dataset can still be recovered through the transaction log. But of course, there is a price to pay for this. There is no insurance mechanism, and if the transaction log is corrupted, the data will really be lost. Nevertheless, I believe the chance is definitely much lower, and the loss is only for the data during this bulk writing period.</p><h3 name="0f05" id="0f05" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="b906" id="b906" class="graf graf--p graf-after--h3">This time, we introduce three ways to significantly improve the performance of Elasticsearch clusters.</p><p name="0ed5" id="0ed5" class="graf graf--p graf-after--p">I have to say that in the big data world, it is obviously not enough to use all kinds of data storage. Without a deep understanding of the underlying implementation of data storage, there is a high risk of wasting resources. This will not only result in lower cluster performance, but also in higher hardware costs as more hardware is used to solve these overheads.</p><p name="3cb2" id="3cb2" class="graf graf--p graf-after--p">In this article, we briefly explain a few terminologies behind Elasticsearch, and then use this knowledge to learn more about optimization techniques. I believe you may be able to learn more details through this process.</p><p name="3749" id="3749" class="graf graf--p graf-after--p graf--trailing">If you have any good tips, please feel free to share them with me.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/9b718a9114bc"><time class="dt-published" datetime="2023-05-22T01:39:23.093Z">May 22, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/boosting-elasticsearch-cluster-performance-3-proven-tips-9b718a9114bc" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>