<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Understanding Exactly-once Semantics</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Understanding Exactly-once Semantics</h1>
</header>
<section data-field="subtitle" class="p-summary">
Explaining how to achieve end-to-end exactly-once guarantee
</section>
<section data-field="body" class="e-content">
<section name="49f9" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8b6c" id="8b6c" class="graf graf--h3 graf--leading graf--title">Understanding Exactly-once Semantics</h3><h4 name="2d99" id="2d99" class="graf graf--h4 graf-after--h3 graf--subtitle">Explaining how to achieve end-to-end exactly-once guarantee</h4><figure name="1fc9" id="1fc9" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*LFngB3Juj-a2xErh" data-width="1000" data-height="667" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*LFngB3Juj-a2xErh"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@aronvisuals" data-href="https://unsplash.com/@aronvisuals" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Aron Visuals</a> on <a href="https://unsplash.com/photos/BXOXnQ26B7o" data-href="https://unsplash.com/photos/BXOXnQ26B7o" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="cd50" id="cd50" class="graf graf--p graf-after--figure">Previously, when <a href="https://selectfrom.dev/message-queue-in-redis-9efe0de2c39c" data-href="https://selectfrom.dev/message-queue-in-redis-9efe0de2c39c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">discussing message queues</a>, we mentioned that when selecting a message queue, we should consider its delivery guarantee. Depending on the needs, there are different requirements for the delivery guarantee. The more critical the application, the higher level of guarantee is required.</p><p name="c900" id="c900" class="graf graf--p graf-after--p">There are three different levels of delivery guarantees, ranging from weak to strong as follows.</p><ol class="postList"><li name="8ade" id="8ade" class="graf graf--li graf-after--p">At most once</li><li name="d755" id="d755" class="graf graf--li graf-after--li">At least once</li><li name="d6b2" id="d6b2" class="graf graf--li graf-after--li">Exactly once</li></ol><p name="d732" id="d732" class="graf graf--p graf-after--li">When we define a delivery guarantee, in fact, we need to understand the scope of the guarantee. In an end-to-end delivery guarantee, there are three different paths that work together to define a complete end-to-end delivery guarantee.</p><p name="6cd0" id="6cd0" class="graf graf--p graf-after--p">These three paths are as follows.</p><ul class="postList"><li name="b182" id="b182" class="graf graf--li graf-after--p">Producer Perspective</li><li name="5e13" id="5e13" class="graf graf--li graf-after--li">Consumer Perspective</li><li name="ba65" id="ba65" class="graf graf--li graf-after--li">Sink Perspective</li></ul><p name="bcb1" id="bcb1" class="graf graf--p graf-after--li">An end-to-end delivery guarantee is actually determined by the weakest of these three paths. For example, if the producer has an exactly-once guarantee, but the consumer can only achieve at-least once, and the sink has at-least once too, then end-to-end is at-least once guaranteed.</p><p name="6e88" id="6e88" class="graf graf--p graf-after--p">In this article, we will focus on how to achieve an exactly-once guarantee. Therefore, it is necessary to understand the meaning of these three paths and how to handle failures.</p><h3 name="faec" id="faec" class="graf graf--h3 graf-after--p">Producer Perspective</h3><p name="8228" id="8228" class="graf graf--p graf-after--h3">From the producer’s point of view, we always want any message that is sent to be delivered.</p><p name="337b" id="337b" class="graf graf--p graf-after--p">Most message queues are able to tell the producer whether the message was sent successfully or not, and when the message is sent successfully, the producer will receive a response. We can be sure that if we receive a response, it was successful, and if we don’t receive it, it’s basically a failure.</p><p name="02a9" id="02a9" class="graf graf--p graf-after--p">However, if we just lose the response but send it successfully, we have a problem.</p><figure name="ec0f" id="ec0f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*DHa-QK5vqP4oPqh6O2KRuA.png" data-width="738" data-height="766" src="https://cdn-images-1.medium.com/max/800/1*DHa-QK5vqP4oPqh6O2KRuA.png"></figure><p name="0f3d" id="0f3d" class="graf graf--p graf-after--figure">The diagram above shows a common error process, so how do we avoid sending twice?</p><p name="a159" id="a159" class="graf graf--p graf-after--p">There are several approaches.</p><p name="23df" id="23df" class="graf graf--p graf-after--p">The first approach is for the producer to maintain a unique constraint on the message, e.g. <code class="markup--code markup--p-code">(producer_id, msg_id)</code>. When a send failure occurs, the producer goes to the broker and queries the broker’s internal storage to determine whether the send failed or the response was lost.</p><p name="62d8" id="62d8" class="graf graf--p graf-after--p">Nevertheless, not every message queue supports this approach. If the message disappears as soon as it is taken away by the consumer, such as RabbitMQ, then this approach will not work. Conversely, systems like Kafka, which store messages as logs, can provide producers with queries.</p><p name="f8e1" id="f8e1" class="graf graf--p graf-after--p">In the second approach, the producer does not identify if a response is lost, instead resending the message anyway, but leaving a GUID (globally unique ID) on the message. On the other hand, the consumer receives the message and has to determine if the GUID has been processed, or simply ignore it if it has been processed.</p><p name="6f2f" id="6f2f" class="graf graf--p graf-after--p">If using Kafka, there is another approach to guarantee exactly-once, that is, through message transactions.</p><p name="add0" id="add0" class="graf graf--p graf-after--p">Just like a relational database, declare <code class="markup--code markup--p-code">START TRANSACTION</code> before sending a message, and declare <code class="markup--code markup--p-code">COMMIT</code> after the message is sent. If any of the intermediate messages fail, then the producer does not <code class="markup--code markup--p-code">COMMIT</code> but simply aborts the entire transaction and resends it. In this way, a failed resend does not result in a duplicate send.</p><h3 name="2e62" id="2e62" class="graf graf--h3 graf-after--p">Consumer Perspective</h3><p name="364c" id="364c" class="graf graf--p graf-after--h3">This is the scenario that all message queues focus on. The delivery guarantee provided by the message queue is only a part of the overall end-to-end delivery guarantee from the consumer perspective.</p><p name="7a49" id="7a49" class="graf graf--p graf-after--p">Most message queues can only provide at-least once guarantee. Once the consumer has correctly processed the message, an acknowledgment is sent to the message queue, and the message is removed only when the message queue receives the acknowledgment.</p><p name="09c0" id="09c0" class="graf graf--p graf-after--p">And, the flow of the problem is as follows.</p><figure name="1033" id="1033" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*H1EtHr2h0kRGBqj5iUBbdQ.png" data-width="1002" data-height="756" src="https://cdn-images-1.medium.com/max/800/1*H1EtHr2h0kRGBqj5iUBbdQ.png"></figure><p name="f3ba" id="f3ba" class="graf graf--p graf-after--figure">When Consumer 1 handles Message A and an acknowledgment is lost, then Consumer 2 can continue to get the same Message A and handle it, resulting in handling twice.</p><p name="4117" id="4117" class="graf graf--p graf-after--p">Basically, this is a common problem for messages queues that are supported at-least once.</p><p name="865e" id="865e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Idempotent Updates</em></strong></p><p name="e1df" id="e1df" class="graf graf--p graf-after--p">In general, developers try to make messages as idempotent as possible so that they do not cause problems no matter how many times a message is handled.</p><p name="08a5" id="08a5" class="graf graf--p graf-after--p">As mentioned in the previous section, putting a GUID inside each message is an obvious solution. Consumers store handled messages in a durable storage, and each consumer must verify whether a message has been handled before handling it.</p><p name="0f7a" id="0f7a" class="graf graf--p graf-after--p">In addition, consumers must avoid duplicate updates when updating the storage by using transactions.</p><p name="dfea" id="dfea" class="graf graf--p graf-after--p">Let’s take MySQL as an example.</p><pre name="9dc7" id="9dc7" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">START TRANSACTION;<br>$RET = UPDATE event SET handled = true WHERE msg_id = 123 AND handled = false;<br>if $RET == 1:<br>    Do whatever you want;<br>COMMIT;</code></pre><p name="9628" id="9628" class="graf graf--p graf-after--pre">Please notice in the first line after the transaction, in addition to <code class="markup--code markup--p-code">msg_id</code> in the <code class="markup--code markup--p-code">WHERE</code> clause we must also add <code class="markup--code markup--p-code">handled = false</code>, this is one of the ways to avoid MySQL having racing conditions. If we don’t add this check condition, it is still possible to process the same message twice under race conditions.</p><p name="0512" id="0512" class="graf graf--p graf-after--p">There is a detailed explanation of how MySQL handles race conditions in my previous article, if you want to know the details you can refer to the following.</p><div name="71fe" id="71fe" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/interviewnoodle/how-to-avoid-the-race-condition-and-the-negative-value-3f397b2b08e4" data-href="https://medium.com/interviewnoodle/how-to-avoid-the-race-condition-and-the-negative-value-3f397b2b08e4" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/interviewnoodle/how-to-avoid-the-race-condition-and-the-negative-value-3f397b2b08e4"><strong class="markup--strong markup--mixtapeEmbed-strong">How to avoid the race condition and the negative value</strong><br><em class="markup--em markup--mixtapeEmbed-em">easy way in MySQL</em>medium.com</a><a href="https://medium.com/interviewnoodle/how-to-avoid-the-race-condition-and-the-negative-value-3f397b2b08e4" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="8eef2d6836b64f09cc383bd0b47f6cb2" data-thumbnail-img-id="1*nxZSMf4aCpfj-EZrZOgYFg.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*nxZSMf4aCpfj-EZrZOgYFg.png);"></a></div><p name="a575" id="a575" class="graf graf--p graf-after--mixtapeEmbed">Nevertheless, it is not easy to make the message idempotent. In addition to the consumer, it often requires the cooperation of the producer, which adds to the coupling and complexity.</p><p name="4637" id="4637" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Event Sourcing</em></strong></p><p name="f18c" id="f18c" class="graf graf--p graf-after--p">Another approach is to use event sourcing. To implement event sourcing, the message queue must support querying message logs, such as Kafka.</p><p name="1349" id="1349" class="graf graf--p graf-after--p">Event sourcing means that the current state of the consumer is generated by replaying all events, so any event handling failure can be recovered by simply replaying the event from the beginning.</p><p name="d2b6" id="d2b6" class="graf graf--p graf-after--p">However, this approach creates two problems.</p><ol class="postList"><li name="dd01" id="dd01" class="graf graf--li graf-after--p">The efficiency of replaying from scratch is not good.</li><li name="31e4" id="31e4" class="graf graf--li graf-after--li">It is difficult to get a list of several current states.</li></ol><p name="06ed" id="06ed" class="graf graf--p graf-after--li">To solve the first problem, a checkpoint mechanism is usually used. Take snapshots of the states and record offsets at regular time intervals or for each batch of messages handled.</p><p name="07c6" id="07c6" class="graf graf--p graf-after--p">When a problem occurs, just restore the last snapshot and replay the last offset to the latest data. Through the checkpoint mechanism, we can greatly improve the replay efficiency.</p><p name="f897" id="f897" class="graf graf--p graf-after--p">The second problem is usually solved by using CQRS, so that a variety of different read requirements have a snapshot available for reference. For more information on how to evolve the CQRS architecture, please refer to my previous article.</p><div name="42df" id="42df" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e" data-href="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e"><strong class="markup--strong markup--mixtapeEmbed-strong">Shift from Monolith to CQRS</strong><br><em class="markup--em markup--mixtapeEmbed-em">Software design is an evolving process. This article shows how to design a system and solve some design problems in DDD…</em>medium.com</a><a href="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="07efd57968440364d9a5a168029c77f8" data-thumbnail-img-id="1*s5O9jiJ2rv7NRe2b4aLF5g.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*s5O9jiJ2rv7NRe2b4aLF5g.png);"></a></div><p name="903f" id="903f" class="graf graf--p graf-after--mixtapeEmbed">To sum up, in order to achieve an exactly-once guarantee by using event sourcing, the consumer must be able to record the handled states and offsets; when each error occurs, the consumer discards the current result and tries to replay it from the previous state snapshot to get the correct result.</p><h3 name="86ff" id="86ff" class="graf graf--h3 graf-after--p">Sink Perspective</h3><p name="f0b7" id="f0b7" class="graf graf--p graf-after--h3">Sink means downstream of the message. In fact, the sink perspective is a special case of the customer perspective.</p><p name="c881" id="c881" class="graf graf--p graf-after--p">Suppose the sink is a database, the consumer itself can already achieve exactly-once guarantee through the event sourcing.</p><p name="c83c" id="c83c" class="graf graf--p graf-after--p">But this is not enough, because in the process of recovering the consumer will propagate the event to the next again, resulting in downstream receiving duplicate results of the same event.</p><figure name="bd64" id="bd64" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BI7_kNugq6tdvRGX9jOQlA.png" data-width="1002" data-height="1096" src="https://cdn-images-1.medium.com/max/800/1*BI7_kNugq6tdvRGX9jOQlA.png"></figure><p name="2009" id="2009" class="graf graf--p graf-after--figure">In the above process, the consumer itself can guarantee exactly-once by restoring the state, but the downstream database has been written twice, which is still a problem.</p><p name="8dc0" id="8dc0" class="graf graf--p graf-after--p">Honestly, there is no silver bullet in sink that can completely achieve exactly-once guarantee without side effects.</p><p name="b015" id="b015" class="graf graf--p graf-after--p">Let’s check Solution 1, we only output the accumulated results after the consumer has successfully created a checkpoint.</p><p name="abbd" id="abbd" class="graf graf--p graf-after--p">Since consumers are guaranteed exactly-once through the checkpoint mechanism, we only output the results when the checkpoint is created, thus ensuring consistency between consumer and sink. It is important to make the checkpoint creation and output be transactional.</p><p name="6ac2" id="6ac2" class="graf graf--p graf-after--p">However, Solution 1 has an obvious drawback. The message handling loses its real-time nature and generates spikes in the database. Because the checkpoints are created in batches, not for each message, i.e., there are no current results in the database. In addition, the output process is also batch, which results in a large number of writes to the database at regular intervals.</p><p name="e31d" id="e31d" class="graf graf--p graf-after--p">So, let’s see Solution 2, which makes the database update idempotent.</p><p name="f1b6" id="f1b6" class="graf graf--p graf-after--p">It is straightforward to simply make each database update have a primary key and overwrite the rows with the same primary key.</p><p name="3f46" id="3f46" class="graf graf--p graf-after--p">However, Solution 2 also has drawbacks. Firstly, it is not easy to define the primary key for each update. Secondly, when a consumer fails to handle and starts a replay, the saved results may time travel and be reverted back to the past then updated again.</p><p name="9e86" id="9e86" class="graf graf--p graf-after--p">This inconsistency depends on how often the checkpoints are created and how efficiently they are replayed, which can take up to a couple of minutes.</p><p name="5ffa" id="5ffa" class="graf graf--p graf-after--p">Both Solution 1 and Solution 2 have their potential risks, but if I had to choose, I would prefer Solution 2 more.</p><h3 name="23e3" id="23e3" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="75d8" id="75d8" class="graf graf--p graf-after--h3">In this article, we take a closer look at the semantics of exactly-once and understand how end-to-end exactly-once can be implemented.</p><p name="08d7" id="08d7" class="graf graf--p graf-after--p">Starting with the message producer at the beginning, the message is sent and enters the message queue, then is read and handled by the consumer, and finally the result is output downstream.</p><p name="c84d" id="c84d" class="graf graf--p graf-after--p">I have to say exactly-once guarantee is a very difficult holy grail to achieve, and it has to be done correctly at every stage of the message flow in order to fully achieve end-to-end exactly-once guarantee.</p><p name="6985" id="6985" class="graf graf--p graf-after--p graf--trailing">I believe there must be some original designs besides listed in this article that I have never noticed, if you have your own implementation, please feel free to share with me.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/338a56d8ba6a"><time class="dt-published" datetime="2022-10-31T01:21:29.597Z">October 31, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/understanding-exactly-once-semantics-338a56d8ba6a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>