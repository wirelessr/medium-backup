<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How to Make Example-based Testing Better</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How to Make Example-based Testing Better</h1>
</header>
<section data-field="subtitle" class="p-summary">
Writing maintainable unit tests
</section>
<section data-field="body" class="e-content">
<section name="744a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="806a" id="806a" class="graf graf--h3 graf--leading graf--title">How to Make Example-based Testing Better</h3><h4 name="9c94" id="9c94" class="graf graf--h4 graf-after--h3 graf--subtitle">Writing maintainable unit tests</h4><figure name="89e3" id="89e3" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*OGPlI3M-2QWFBLZ9.png" data-width="800" data-height="533" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*OGPlI3M-2QWFBLZ9.png"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@martinadams" data-href="https://unsplash.com/@martinadams" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Martin Adams</a> on <a href="https://unsplash.com/photos/a_PDPUPuNZ8" data-href="https://unsplash.com/photos/a_PDPUPuNZ8" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="3653" id="3653" class="graf graf--p graf-after--figure">I have <a href="https://medium.com/better-programming/property-based-testing-framework-for-node-1ca702ad30bc" data-href="https://medium.com/better-programming/property-based-testing-framework-for-node-1ca702ad30bc" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">introduced property-based testing</a> before and mentioned that property-based testing is designed to cover the shortcomings of example-based testing. Since it is difficult to generate examples to hit various edge cases and boundary conditions, we generate a large number of examples in an automated way to cover the tests completely.</p><p name="9eba" id="9eba" class="graf graf--p graf-after--p">Nevertheless, there is a big challenge in property-based testing, how to write a validation condition?</p><p name="e7a6" id="e7a6" class="graf graf--p graf-after--p">We can’t expect what kind of input will be there, so it’s like we have to rewrite the original test target in a different way to be able to verify it. For example, if we want to verify the function <code class="markup--code markup--p-code">add</code> by a property-based test, then our verification condition will be as follows.</p><blockquote name="64e6" id="64e6" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">a + b == add(a, b)</em></blockquote><p name="8cf3" id="8cf3" class="graf graf--p graf-after--blockquote">When the test target is complicated enough, writing such a condition is extremely hard, not to mention, if I have a way to write the verification condition, why didn’t I write the test target in that way?</p><p name="087b" id="087b" class="graf graf--p graf-after--p">Anyway, the example-based test still has its value.</p><p name="5912" id="5912" class="graf graf--p graf-after--p">Then, how to write a good example-based test? I’m not sure you have ever encountered a problem when there are too many examples in a unit test, making it almost impossible to modify the unit test.</p><p name="ccac" id="ccac" class="graf graf--p graf-after--p">When we are not the author of a unit test, it is difficult to understand the author’s thinking in a complex unit test, and it is also difficult to understand a complex test case completely.</p><p name="54e2" id="54e2" class="graf graf--p graf-after--p">Therefore, this article introduces a few ways to make example-based testing easier.</p><h3 name="50f7" id="50f7" class="graf graf--h3 graf-after--p">Table-based Testing</h3><p name="a4ab" id="a4ab" class="graf graf--p graf-after--h3">First of all, before simplifying the unit test, we need to understand the structure of the unit test, which I call the 3A principle.</p><ul class="postList"><li name="25c8" id="25c8" class="graf graf--li graf-after--p">Arrange: At the beginning, we need to prepare test data and test preconditions.</li><li name="f4af" id="f4af" class="graf graf--li graf-after--li">Act: Then the actual execution of the test target.</li><li name="c072" id="c072" class="graf graf--li graf-after--li">Assert: Finally, we verify that the execution results are as expected.</li></ul><p name="ef97" id="ef97" class="graf graf--p graf-after--li">No matter what kind of unit test is used, it basically involves these three steps. There are several reasons why unit testing becomes complicated.</p><ol class="postList"><li name="0547" id="0547" class="graf graf--li graf-after--p">Expected results are hard to produce.</li><li name="43da" id="43da" class="graf graf--li graf-after--li">The number of test cases becomes larger over time.</li><li name="96ca" id="96ca" class="graf graf--li graf-after--li">Relationship between the arrangement and the assessment cannot be identified.</li><li name="f762" id="f762" class="graf graf--li graf-after--li">Arrangement workload is huge.</li></ol><p name="6c74" id="6c74" class="graf graf--p graf-after--li">The root cause of the first one is usually the complexity of the test target, which means the unit itself is too large, so it is necessary to reduce the scope of the unit test.</p><p name="15c5" id="15c5" class="graf graf--p graf-after--p">The second reason is the focus of this article. When writing unit tests, we often add a corresponding test when we encounter a new bug, resulting in a test case getting larger and larger. Here is a simple example.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="903f" id="903f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_calculator</span>():<br />    <span class="hljs-comment"># 1st</span><br />    expression = <span class="hljs-string">&quot;2 + 3&quot;</span><br />    ret = calculator(expression)<br />    <span class="hljs-keyword">assert</span> ret == <span class="hljs-number">5</span><br />    <span class="hljs-comment"># 2nd</span><br />    expression = <span class="hljs-string">&quot;2 + 3 * 4&quot;</span><br />    ret = calculator(expression)<br />    <span class="hljs-keyword">assert</span> ret == <span class="hljs-number">14</span><br />    <span class="hljs-comment"># 3rd</span><br />    expression = <span class="hljs-string">&quot;(2 + 3) * 4&quot;</span><br />    ret = calculator(expression)<br />    <span class="hljs-keyword">assert</span> ret == <span class="hljs-number">20</span><br />    <span class="hljs-comment"># and so on</span></span></pre><p name="7f16" id="7f16" class="graf graf--p graf-after--pre">Such a case will get larger and it is not difficult to find plenty of duplicate codes that differ only in parameters. So how should we simplify it?</p><p name="5ceb" id="5ceb" class="graf graf--p graf-after--p">Building a table.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="2373" id="2373" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_calculator</span>():<br />    table = [<br />        (<span class="hljs-string">&quot;2 + 3&quot;</span>, <span class="hljs-number">5</span>),<br />        (<span class="hljs-string">&quot;2 + 3 * 4&quot;</span>, <span class="hljs-number">14</span>),<br />        (<span class="hljs-string">&quot;(2 + 3) * 4&quot;</span>, <span class="hljs-number">20</span>),<br />        <span class="hljs-comment"># and so on</span><br />    ]<br />    <span class="hljs-keyword">for</span> expression, expected <span class="hljs-keyword">in</span> table:<br />        ret = calculator(expression)<br />        <span class="hljs-keyword">assert</span> ret == expected</span></pre><p name="134c" id="134c" class="graf graf--p graf-after--pre">By building a table, all we need to do for adding new cases in the future is to add the corresponding entries to the table. There is a more elegant solution to this approach in the PyTest framework: <code class="markup--code markup--p-code">parametrize</code>. Here is a PyTest example.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="9e12" id="9e12" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> pytest<br /><br /><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;expression,expected&quot;</span>,<br />    [<br />        (<span class="hljs-params"><span class="hljs-string">&quot;2 + 3&quot;</span>, <span class="hljs-number">5</span></span>),<br />        (<span class="hljs-params"><span class="hljs-string">&quot;2 + 3 * 4&quot;</span>, <span class="hljs-number">14</span></span>),<br />        (<span class="hljs-params"><span class="hljs-string">&quot;(2 + 3) * 4&quot;</span>, <span class="hljs-number">20</span></span>),<br />        <span class="hljs-comment"># and so on</span><br />    ]<br /></span>)</span><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_calculator</span>(<span class="hljs-params">expression, expected</span>):<br />    ret = calculator(expression)<br />    <span class="hljs-keyword">assert</span> ret == expected</span></pre><p name="52e2" id="52e2" class="graf graf--p graf-after--pre">With <code class="markup--code markup--p-code">parametrize</code>, it can handle loops directly, so the code is much more simple. Of course, I feel building a table is enough to achieve our goal.</p><p name="0289" id="0289" class="graf graf--p graf-after--p">Building a table also solves problem 3, so we can easily know in the table what are the changing conditions of the test and how to relate them to the expected results.</p><p name="daa0" id="daa0" class="graf graf--p graf-after--p">And what is problem 4? Let’s continue with the calculator example as an extension. Suppose our calculator is able to remember the results, how should we test it?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="956f" id="956f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_calculator</span>():<br />    calculator = Calculator()<br />    expression1 = <span class="hljs-string">&quot;x = 5 * 10&quot;</span><br />    calculator.calculate(expression1)<br />    expression2 = <span class="hljs-string">&quot;y = 2 + 3&quot;</span><br />    calculator.calculate(expression2)<br />    expression3 = <span class="hljs-string">&quot;x / y&quot;</span><br />    ret = calculator.calculate(expression3)<br />    <span class="hljs-keyword">assert</span> ret == <span class="hljs-number">10</span></span></pre><p name="e36c" id="e36c" class="graf graf--p graf-after--pre">From the above example, we know the state of the target will change with time and input, so how to build a table?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="8317" id="8317" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_calculator</span>():<br />    table = [<br />        (<span class="hljs-string">&quot;x = 2&quot;</span>, <span class="hljs-string">&quot;y = 3&quot;</span>, <span class="hljs-string">&quot;x + y&quot;</span>, <span class="hljs-number">5</span>),<br />        (<span class="hljs-string">&quot;x = 2&quot;</span>, <span class="hljs-string">&quot;y = 3 * 4&quot;</span>, <span class="hljs-string">&quot;x + y&quot;</span>, <span class="hljs-number">14</span>),<br />        <span class="hljs-comment"># and so on</span><br />    ]<br />    <span class="hljs-keyword">for</span> *expressions, expected <span class="hljs-keyword">in</span> table:<br />        calculator = Calculator() <span class="hljs-comment"># no init params</span><br />        <span class="hljs-keyword">for</span> expression <span class="hljs-keyword">in</span> expressions:<br />            ret = calculator.calculate(expression)<br />        <br />        <span class="hljs-keyword">assert</span> ret == expected<br />        calculator.reset() <span class="hljs-comment"># important</span></span></pre><p name="3c2e" id="3c2e" class="graf graf--p graf-after--pre">It still seems to work, but this simple example already makes the test logic a bit complicated. If our target changes its state not only with the input, but also with the initialization state and many external conditions, then the table will have more and more columns and complexity will arise.</p><p name="3b65" id="3b65" class="graf graf--p graf-after--p">Is there a way to simplify it even further? So that people who need to add new cases in the future will know what to do at a glance?</p><p name="bcd0" id="bcd0" class="graf graf--p graf-after--p">Yes, I call it config-based testing.</p><h3 name="e0d2" id="e0d2" class="graf graf--h3 graf-after--p">Config-based Testing</h3><p name="39ac" id="39ac" class="graf graf--p graf-after--h3">Let’s continue to look at the example of this calculator.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="yaml" name="262c" id="262c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-attr">scenario:</span><br />  <span class="hljs-bullet">-</span> <span class="hljs-attr">calculator_test1:</span><br />    <span class="hljs-attr">expressions:</span><br />      <span class="hljs-bullet">-</span> <span class="hljs-string">x</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><br />      <span class="hljs-bullet">-</span> <span class="hljs-string">y</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span><br />      <span class="hljs-bullet">-</span> <span class="hljs-string">x</span> <span class="hljs-string">+</span> <span class="hljs-string">y</span><br />    <span class="hljs-attr">execute:</span> <span class="hljs-string">calculate</span><br />    <span class="hljs-attr">expect:</span><br />      <span class="hljs-attr">result:</span> <span class="hljs-number">5</span><br />  <span class="hljs-bullet">-</span> <span class="hljs-attr">calculator_test2:</span><br />    <span class="hljs-attr">expressions:</span><br />      <span class="hljs-bullet">-</span> <span class="hljs-string">x</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><br />      <span class="hljs-bullet">-</span> <span class="hljs-string">y</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span> <span class="hljs-string">*</span> <span class="hljs-number">4</span><br />      <span class="hljs-bullet">-</span> <span class="hljs-string">x</span> <span class="hljs-string">+</span> <span class="hljs-string">y</span><br />    <span class="hljs-attr">execute:</span> <span class="hljs-string">calculate</span><br />    <span class="hljs-attr">expect:</span><br />      <span class="hljs-attr">result:</span> <span class="hljs-number">14</span></span></pre><p name="6e98" id="6e98" class="graf graf--p graf-after--pre">By writing a human-readable configuration file, we can simply describe the test scenario we want, and in addition, we can read the purpose of the past cases. I believe maintaining a configuration is more relaxing than maintaining code.</p><p name="4359" id="4359" class="graf graf--p graf-after--p">Of course, in the beginning, we have to use a parser to handle the configuration, but it is worth such an investment. Moreover, when the behavior of the target is affected by many factors, we only need to add descriptive fields to the configuration file.</p><p name="b0f8" id="b0f8" class="graf graf--p graf-after--p">Frankly speaking, such a configuration file will not be any difficult even if it is written by someone who does not know how to write programs, and anyone can help us improve the test coverage.</p><h3 name="396f" id="396f" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="19fa" id="19fa" class="graf graf--p graf-after--h3">It is not hard to write a unit test, but it takes a lot of effort to write a unit test that is easy to maintain.</p><p name="568d" id="568d" class="graf graf--p graf-after--p">When we write a unit test, we often look at the test case from the author’s point of view, but in fact, it is often someone else who maintains the case. That other person does not have the original idea of the author, which makes it very difficult for us to maintain the unit test.</p><p name="e463" id="e463" class="graf graf--p graf-after--p">Even worse, when the test cases become large, the functional evolution is seriously affected. Have you ever changed a little bit of code and the unit test exploded: a lot of red lights, and you wanted to fix it but found that you couldn’t understand what it was testing?</p><p name="9ac7" id="9ac7" class="graf graf--p graf-after--p">Sometimes, we document the purpose of these test cases in a file, but document synchronization is a major challenge, and the documents are often not up-to-date.</p><p name="6eeb" id="6eeb" class="graf graf--p graf-after--p">It is better to let the file itself be an executable object. It is far more efficient to write documents as a unit test than to “explore” the concept of testing afterward.</p><p name="567c" id="567c" class="graf graf--p graf-after--p graf--trailing">This article uses an interesting feature of PyTest, but actually, PyTest is very deep and profound, so if you have more great uses for PyTest, please feel free to share them with me.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/99dbfbbe5b8c"><time class="dt-published" datetime="2023-03-06T01:50:13.293Z">March 6, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/how-to-make-example-based-testing-better-99dbfbbe5b8c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>