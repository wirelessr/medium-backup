<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Understand Temporal Coupling in Code</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Understand Temporal Coupling in Code</h1>
</header>
<section data-field="subtitle" class="p-summary">
We often talk about coupling, what exactly is coupling?
</section>
<section data-field="body" class="e-content">
<section name="1bd5" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="074e" id="074e" class="graf graf--h3 graf--leading graf--title">Understand Temporal Coupling in Code</h3><h4 name="dd0f" id="dd0f" class="graf graf--h4 graf-after--h3 graf--subtitle"><em class="markup--em markup--h4-em">We often talk about coupling, what exactly is coupling?</em></h4><figure name="af47" id="af47" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*UrvZqN0L9uK6XzO4" data-width="6000" data-height="4000" data-unsplash-photo-id="4hbJ-eymZ1o" src="https://cdn-images-1.medium.com/max/800/0*UrvZqN0L9uK6XzO4"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@florianolv?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@florianolv?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Florian Olivo</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="8317" id="8317" class="graf graf--p graf-after--figure">Generally, there are three types of component coupling.</p><ol class="postList"><li name="ca0c" id="ca0c" class="graf graf--li graf-after--p">Afferent coupling: The task of the A component must depend on the implementation of B, C, and D.</li></ol><figure name="4eb2" id="4eb2" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*SSCMX0zM8-8Gws4VXwep5g.png" data-width="282" data-height="502" src="https://cdn-images-1.medium.com/max/800/1*SSCMX0zM8-8Gws4VXwep5g.png"></figure><p name="3aad" id="3aad" class="graf graf--p graf-after--figure">2. Efferent coupling: After the task of the A component is completed, B, C, D must be executed.</p><figure name="eaf2" id="eaf2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rLqf9u2kJOHIGL8LcEBgVg.png" data-width="282" data-height="502" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*rLqf9u2kJOHIGL8LcEBgVg.png"></figure><p name="2999" id="2999" class="graf graf--p graf-after--figure">3. Temporal coupling: After the task of the A component is completed, B and C must be executed. In addition, B is earlier than C.</p><figure name="c8ff" id="c8ff" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tjkqnGevNGSW5zLVn-sJkw.png" data-width="430" data-height="204" src="https://cdn-images-1.medium.com/max/800/1*tjkqnGevNGSW5zLVn-sJkw.png"></figure><p name="38cd" id="38cd" class="graf graf--p graf-after--figure">The components mentioned here can be source code level, module level or even service level based on the granularity.</p><p name="7aad" id="7aad" class="graf graf--p graf-after--p">In this article we will dive into the temporal coupling in particular, because this is the most common and most overlooked pitfall. First we describe in Node.js as follows:</p><figure name="d800" id="d800" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*toZFte37Li_5D7I_g203bw.png" data-width="688" data-height="558" src="https://cdn-images-1.medium.com/max/800/1*toZFte37Li_5D7I_g203bw.png"></figure><p name="338b" id="338b" class="graf graf--p graf-after--figure">At this point, we found that this is really generic. Almost all of our code looks like this. It is normal to do three things in sequence in a method, isn’t it?</p><p name="f014" id="f014" class="graf graf--p graf-after--p">Let’s take a more concrete example. Suppose we have an e-commerce with a function, <code class="markup--code markup--p-code">purchase</code>. Therefore, we begin to code in a simple way.</p><figure name="e723" id="e723" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Bq3Btv9FvTOmWN0h4hKuMQ.png" data-width="1060" data-height="634" src="https://cdn-images-1.medium.com/max/800/1*Bq3Btv9FvTOmWN0h4hKuMQ.png"></figure><p name="ae97" id="ae97" class="graf graf--p graf-after--figure">First summarize the price of all items in the cart. And then call the payment service to deal with the credit card. Simple, right?</p><p name="694b" id="694b" class="graf graf--p graf-after--p">Alright, the marketing team wants to let people who spend over 1,000 dollars get a discount coupon, so we continue to modify our <code class="markup--code markup--p-code">purchase</code>.</p><figure name="763c" id="763c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*LlZYz55Pw54uoS6Zsy2CaA.png" data-width="1094" data-height="782" src="https://cdn-images-1.medium.com/max/800/1*LlZYz55Pw54uoS6Zsy2CaA.png"></figure><p name="7389" id="7389" class="graf graf--p graf-after--figure">This feature is also quite common, and then the sales team found that coupon is a good promotion method, so they proposed that people who reached 5,000 dollars could get a lottery chance. This <code class="markup--code markup--p-code">purchase</code> keeps growing.</p><figure name="f45e" id="f45e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*izql41NdZm2gQhxaFdCGyQ.png" data-width="1094" data-height="894" src="https://cdn-images-1.medium.com/max/800/1*izql41NdZm2gQhxaFdCGyQ.png"></figure><p name="0b4e" id="0b4e" class="graf graf--p graf-after--figure">This is a temporal coupling. Either <code class="markup--code markup--p-code">giveCoupon</code> or <code class="markup--code markup--p-code">lottery</code> actually depend on <code class="markup--code markup--p-code">purchase</code>, which must be done within the life cycle of <code class="markup--code markup--p-code">purchase</code>. Once the feature requirement becomes larger and larger, the performance of the entire <code class="markup--code markup--p-code">purchase</code> will be continuously dragged down. Especially, the <code class="markup--code markup--p-code">lottery</code> usually requires huge calculations, and the <code class="markup--code markup--p-code">purchase</code> is forced to wait for the <code class="markup--code markup--p-code">lottery</code> success to be considered a success.</p><h3 name="1149" id="1149" class="graf graf--h3 graf-after--p">De-couple timing by domain events</h3><p name="d5ce" id="d5ce" class="graf graf--p graf-after--h3">From the previous section, we learned that <code class="markup--code markup--p-code">purchase</code> should only need to process payments, the rest of the behavior is additional, and should not be in the same life cycle as <code class="markup--code markup--p-code">purchase</code>. In other words, even if the <code class="markup--code markup--p-code">giveCoupon</code> fails, it should not affect <code class="markup--code markup--p-code">purchase</code> or <code class="markup--code markup--p-code">lottery</code>.</p><p name="9a46" id="9a46" class="graf graf--p graf-after--p">There is a method in domain-driven development called domain events. When a task is completed, it will issue an event, and the handler that cares about the event can take the corresponding action after receiving the event. By the way, this approach is also called the <em class="markup--em markup--p-em">Observer Pattern</em> in the design pattern. In domain-driven development, the “notification” contains the domain’s ubiquitous language, hence the notification is named domain events.</p><p name="347e" id="347e" class="graf graf--p graf-after--p">Therefore, let’s modify <code class="markup--code markup--p-code">purchase</code> a little bit in the Node’s way.</p><figure name="c414" id="c414" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0lcfBJKz0ywUgRvhfb-kFg.png" data-width="1094" data-height="856" src="https://cdn-images-1.medium.com/max/800/1*0lcfBJKz0ywUgRvhfb-kFg.png"></figure><p name="d5ca" id="d5ca" class="graf graf--p graf-after--figure">With events, we can completely decouple <code class="markup--code markup--p-code">giveCoupon</code> and <code class="markup--code markup--p-code">lottery</code> from <code class="markup--code markup--p-code">purchase</code>. Even if any one of the handler fails, it does not impact the original payment flow.</p><p name="5402" id="5402" class="graf graf--p graf-after--p">Whereas <code class="markup--code markup--p-code">purchase</code> only needs to concentrate on the payment process. When the payment is successful, emit the event and let other functions take over.</p><figure name="02d2" id="02d2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6UY2qnE1kDwMGvAvxIij7w.png" data-width="1178" data-height="782" src="https://cdn-images-1.medium.com/max/800/1*6UY2qnE1kDwMGvAvxIij7w.png"></figure><p name="2d96" id="2d96" class="graf graf--p graf-after--figure">If there are more needs in the future, there is no need to change the original <code class="markup--code markup--p-code">purchase</code>, just add a new handler. And this is the concept of decoupling. Here we remove the code-level coupling and timing-level coupling.</p><h3 name="a1b3" id="a1b3" class="graf graf--h3 graf-after--p">How to handle event loss</h3><p name="ee7b" id="ee7b" class="graf graf--p graf-after--h3">In <a href="https://towardsdev.com/resilient-caching-in-redis-a5b3c1a49f14" data-href="https://towardsdev.com/resilient-caching-in-redis-a5b3c1a49f14" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">my previous article</a>, we mentioned that whenever failures can happen, we have to expect them and handle them gracefully. This is called <a href="https://www.bmc.com/blogs/resilience-engineering/" data-href="https://www.bmc.com/blogs/resilience-engineering/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">resilience engineering</a>.</p><p name="1f2b" id="1f2b" class="graf graf--p graf-after--p">When we decouple the coupons and lottery through domain events, we will immediately face a problem. What if the event is lost? The payment is finish, but the coupon has not been issued, which is definitely a big problem for the customer.</p><p name="d111" id="d111" class="graf graf--p graf-after--p">In other words, how do we ensure that the emitted event will be executed. This is exactly why message queues were introduced into the system.</p><p name="8981" id="8981" class="graf graf--p graf-after--p">We discussed the <a href="https://selectfrom.dev/message-queue-in-redis-9efe0de2c39c" data-href="https://selectfrom.dev/message-queue-in-redis-9efe0de2c39c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">message queue</a> before, there are three different levels of guarantees in message delivery, which are:</p><ul class="postList"><li name="e5ce" id="e5ce" class="graf graf--li graf-after--p">At most once</li><li name="07b4" id="07b4" class="graf graf--li graf-after--li">At least once</li><li name="8210" id="8210" class="graf graf--li graf-after--li">Exactly once</li></ul><p name="ba7a" id="ba7a" class="graf graf--p graf-after--li">Most message queues have the at-least-once guarantee. That is to say, through the message queue we can make sure that all events can be executed at least once. This also ensures that messages are not lost.</p><p name="fc65" id="fc65" class="graf graf--p graf-after--p">Thus, to avoid event loss, we will change <code class="markup--code markup--p-code">emitter.emit</code> to a queue submission with like RabbitMQ or Kafka. At this stage, we have introduced decoupling at the system level, i.e., make event producers and consumers belong to different execution units.</p><h3 name="1f6d" id="1f6d" class="graf graf--h3 graf-after--p">How to handle emitting loss</h3><p name="ead1" id="ead1" class="graf graf--p graf-after--h3">The story isn’t over yet. We can already ensure that emitted events are executed. What if the event isn’t sent at all? Continue to take <code class="markup--code markup--p-code">purchase</code> as an example, when <code class="markup--code markup--p-code">payByCreditCard</code> has been successful, but it doesn’t send the event due to the system crashes for unexpected reasons. Then, even with a message queue, we still get the incorrect result.</p><p name="51bb" id="51bb" class="graf graf--p graf-after--p">In order to avoid this problem, we can leverage the event sourcing. In <a href="https://medium.com/interviewnoodle/distributed-transaction-introduction-1cd105c830a2" data-href="https://medium.com/interviewnoodle/distributed-transaction-introduction-1cd105c830a2" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Distributed Transaction</a> and <a href="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e" data-href="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CQRS</a>, I have described the core concept of event sourcing.</p><p name="0fbd" id="0fbd" class="graf graf--p graf-after--p">Before the event is emitted, store the event into a storage first. After the handler finishes processing the event, then mark the event in the storage as “processed”.</p><p name="3881" id="3881" class="graf graf--p graf-after--p">There is one thing should be aware, the writing of events and the payment must be under the same transaction. In this way, as long as the payment is successful, the event will also be written successfully. Finally, we can periodically monitor for overdue events to know what went wrong.</p><h3 name="cd5e" id="cd5e" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="836a" id="836a" class="graf graf--p graf-after--h3">This time we are still going through a step-by-step evolution of the system as we did in <a href="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e" data-href="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Shift from Monolith to CQRS</a> to let you know how to decouple when systems become large and complex. At the beginning, we first decoupled source code and execution timing through domain events; then we introduced message queues with message producers and consumers to achieve system-level decoupling.</p><p name="b87f" id="b87f" class="graf graf--p graf-after--p">As I said before, a system evolves to solve a problem, but it also creates new problems. We can only choose the most acceptable solution and seek compromises in complexity, performance, productivity and other factors.</p><p name="f1bd" id="f1bd" class="graf graf--p graf-after--p">Splitting a complete action into different execution units must encounter inconsistencies. In resolving inconsistencies, there are many considerations, such as:</p><ul class="postList"><li name="a9d2" id="a9d2" class="graf graf--li graf-after--p">Regardless of whether the event will be lost or not, just use the simplest architecture, <code class="markup--code markup--li-code">EventEmitter</code>. This approach is the simplest, and there may be no problem in 80% of the cases, but what should we do if there is a problem?</li><li name="dea9" id="dea9" class="graf graf--li graf-after--li">Attempting to be as reliable as possible, so introduce message queues, which should be 99% sure that there will be no problems. But there is still 1%, is such a risk bearable?</li><li name="fb01" id="fb01" class="graf graf--li graf-after--li">Implementing event sourcing comes at the cost of increased complexity and performance may be affected. Is this acceptable?</li></ul><p name="7e6d" id="7e6d" class="graf graf--p graf-after--li graf--trailing">Just like I always say, there is no perfect solution to system design. Each organization has a different level of risk tolerance. In various indicators, we look for the most acceptable solution for ourselves and think about the risks and failures we face at any time. As a result, everyone should be able to build a resilient system.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/e74899f7a48f"><time class="dt-published" datetime="2022-02-14T01:00:51.972Z">February 14, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/temporal-coupling-in-code-e74899f7a48f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>