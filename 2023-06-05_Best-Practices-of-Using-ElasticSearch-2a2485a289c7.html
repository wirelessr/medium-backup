<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Best Practices of Using ElasticSearch</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Best Practices of Using ElasticSearch</h1>
</header>
<section data-field="subtitle" class="p-summary">
Explaining how to use ElasticSearch in a better way
</section>
<section data-field="body" class="e-content">
<section name="8306" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2141" id="2141" class="graf graf--h3 graf--leading graf--title">Best Practices of Using ElasticSearch</h3><h4 name="3c59" id="3c59" class="graf graf--h4 graf-after--h3 graf--subtitle">Explaining how to use ElasticSearch in a better way</h4><figure name="14b1" id="14b1" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*ZBNdENpLL5oTQaVi" data-width="1000" data-height="563" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*ZBNdENpLL5oTQaVi"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@opollophotography" data-href="https://unsplash.com/@opollophotography" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Geometric Photography</a> on <a href="https://unsplash.com/photos/DGKm-IIq8lU" data-href="https://unsplash.com/photos/DGKm-IIq8lU" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="8b4e" id="8b4e" class="graf graf--p graf-after--figure">Last time, we have introduced some tips for boosting ElasticSearch performance.</p><div name="2894" id="2894" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://betterprogramming.pub/boosting-elasticsearch-cluster-performance-3-proven-tips-9b718a9114bc" data-href="https://betterprogramming.pub/boosting-elasticsearch-cluster-performance-3-proven-tips-9b718a9114bc" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://betterprogramming.pub/boosting-elasticsearch-cluster-performance-3-proven-tips-9b718a9114bc"><strong class="markup--strong markup--mixtapeEmbed-strong">Boosting Elasticsearch Cluster Performance: 3 Proven Tips</strong><br><em class="markup--em markup--mixtapeEmbed-em">Tuning Elasticsearch Configuration for Improved Resource Utilization</em>betterprogramming.pub</a><a href="https://betterprogramming.pub/boosting-elasticsearch-cluster-performance-3-proven-tips-9b718a9114bc" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="3247173f6c128096190e63d3d13f9f56" data-thumbnail-img-id="0*z2L5pXZQ31wrAbZa" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*z2L5pXZQ31wrAbZa);"></a></div><p name="9cc2" id="9cc2" class="graf graf--p graf-after--mixtapeEmbed">In addition, that article explains the underlying details of ElasticSearch. This time, we are going to talk a little more about best practices for using ElasticSearch.</p><p name="5850" id="5850" class="graf graf--p graf-after--p">These practices are general recommendations and can be applied to any use cases. Let’s go.</p><ul class="postList"><li name="874e" id="874e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Bulk Requests</strong>: The Bulk API makes it possible to perform many index/delete operations in a single API call. This can greatly increase the<br>indexing speed. Each subrequest is executed independently, so the failure of one subrequest won’t affect the success of the others. If<br>any of the requests fail, the top-level error flag is set to true and the error details will be reported under the relevant request.</li><li name="aad5" id="aad5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Multithread clients to Index Data</strong>: A single thread sending bulk requests is unlikely to be able to max out the indexing capacity of an<br>ElasticSearch cluster. In order to use all resources of the cluster, you should send data from multiple threads or processes. In addition to<br>making better use of the resources of the cluster, this should help reduce the cost of each fsync. Both the index data and transaction log<br>are periodically flushed to disk. If there are more data with multithread, the more data is synced to disk to reduce I/O to improve<br>performance.</li><li name="d8e0" id="d8e0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">index.refresh_interval</strong>: By default, ElasticSearch periodically refreshes indices every second, but only on indices that have received one<br>search request or more in the last 30 seconds.This is the optimal configuration if you have no or very little search traffic (e.g. less than<br>one search request every 5 minutes) and want to optimize for indexing speed. This behavior aims to automatically optimize bulk indexing<br>in the default case when no searches are performed. In order to opt out of this behavior set the refresh interval explicitly. On the other<br>hand, if your index experiences regular search requests, this default behavior means that ElasticSearch will refresh your index every 1<br>second. If you can afford to increase the amount of time between when a document gets indexed and when it becomes visible,<br>increasing the index.refresh_interval to a larger value, e.g. 30s, might help improve indexing speed.</li><li name="fa0f" id="fa0f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Auto generated IDs</strong>: When indexing a document that has an explicit id, ElasticSearch needs to check whether a document with the same<br>id already exists within the same shard, which is a costly operation and gets even more costly as the index grows. By using auto-<br>generated ids, ElasticSearch can skip this check, which makes indexing faster.</li><li name="676b" id="676b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">index.translog.sync_interval</strong>: This parameter determines how often the translog is fsynced to disk and committed, regardless of write<br>operations. Defaults to 5s. Values less than 100ms are not allowed.</li><li name="35c4" id="35c4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">index.translog.flush_threshold_size</strong>: The translog stores all operations that are not yet safely persisted in Lucene (i.e., are not part of a<br>Lucene commit point). Although these operations are available for reads, they will need to be replayed if the shard was stopped and had<br>to be recovered. This setting controls the maximum total size of these operations, to prevent recoveries from taking too long. Once the<br>maximum size has been reached a flush will happen, generating a new Lucene commit point. Defaults to 512mb.</li><li name="5c94" id="5c94" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Large Documents</strong>: Large documents put more stress on network, memory usage and disk. Indexing large document can use an amount<br>of memory that is a multiplier of the original size of the document. Proximity search (phrase queries for instance) and highlighting also<br>becomes more expensive since their cost directly depends on the size of the original document.</li><li name="741a" id="741a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Set Index Mapping Explicitly</strong>: ElasticSearch can create mapping dynamically, but it might be not suitable for all scenarios. For example,<br>the default string field mappings in ElasticSearch 5.x are both “keyword” and “text” types. It’s unnecessary in a lot of scenarios.</li><li name="aa9c" id="aa9c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Index Mapping — Nested Types</strong>: Querying on nested fields is slower compared to fields in parent document. Retrieval of matching<br>nested fields adds an additional slowdown. Once you update any field of a document containing nested fields, independent of whether<br>you updated a nested field or not, all the underlying Lucene documents (parent and all its nested children) need to be marked as deleted<br>and rewritten. In addition to slowing down your updates, such an operation also creates garbage to be cleaned up by segment merging<br>later on.</li><li name="9f28" id="9f28" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Index Mapping</strong>: Disable the <strong class="markup--strong markup--li-strong">_all</strong> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.7/mapping-all-field.html" data-href="https://www.elastic.co/guide/en/elasticsearch/reference/6.7/mapping-all-field.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">field</a> concatenates the values of all other fields into one string. It requires more CPU and disk space<br>than other fields. Most use cases don’t require the _all field. You can concatenate multiple fields using the <code class="markup--code markup--li-code">copy_to</code> parameter. The _all<br>field is disabled by default in ElasticSearch versions 6.0 and later. To disable the _all field in earlier versions, set enabled to false.</li><li name="a30e" id="a30e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Leverage Index Templates</strong>: Index templates define settings like number of shards, replicas and mappings that you can automatically<br>apply when creating new indices. ElasticSearch applies templates to new indices based on an index pattern that matches the index name.</li><li name="c322" id="c322" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Use Replicas for Scalability &amp; Resilience</strong>: ElasticSearch is built to be always available and to scale with your needs. It does this by being<br>distributed in nature. You can add nodes to a cluster to increase capacity and ElasticSearch automatically distributes your data and query<br>load across all of the available nodes. For ElasticSearch to be highly available, its indices needs to have fault tolerance in place. This can be<br>achieved using replica shards. A replica shard is a copy of a primary shard. Replicas provide redundant copies of your data to protect<br>against hardware failure and increase capacity to serve read requests like searching or retrieving a document.</li><li name="7090" id="7090" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Shard Sizing</strong>: A shard is a Lucene index under the covers, which uses file handles, memory, and CPU cycles. Default shard strategy for an<br>index in ES is 5 primary shards with a replica. The goal of choosing a number of shards is to distribute an index evenly across all data<br>nodes in the cluster. However, these shards shouldn’t be too large or too numerous. A good rule of thumb is to try to keep shard size<br>between 10–50 GB. Large shards can make it difficult for ElasticSearch to recover from failure, but because each shard uses some amount<br>of CPU and memory, having too many small shards can cause performance issues and out of memory errors.</li><li name="ef88" id="ef88" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Keep shard count of index in multiple of data nodes</strong> with <strong class="markup--strong markup--li-strong">equivalent size</strong> and <strong class="markup--strong markup--li-strong">distributed across nodes</strong>. Set a primary shard count,<br>via a template, by targeting 50GB max per primary shard (log analytics) or 30GB max (search use cases)<br>Shard assignment across data nodes will happen based on 2 important rules.</li></ul><blockquote name="2238" id="2238" class="graf graf--blockquote graf-after--li"><strong class="markup--strong markup--blockquote-strong">Primary</strong> and <strong class="markup--strong markup--blockquote-strong">replica</strong> shard of same index will not be assigned on same data nodes.</blockquote><blockquote name="f566" id="f566" class="graf graf--blockquote graf-after--blockquote">A shard is placed on a node based on how many shards are available on that node or to equalize the number of shards per index<br>across all nodes in the cluster. Also note there can be chances of bigger shards allocated to some node and smaller to others.<br>It is recommended that shard count of an index (primary + replica) should be multiple of data node count. Let’s say, you have a 4<br>node cluster, the total shards (primary + Replica) for your index should be either 4 or 8 or 12 etc. This ensures that the data is evenly<br>distributed across the nodes.</blockquote><ul class="postList"><li name="80db" id="80db" class="graf graf--li graf-after--blockquote"><strong class="markup--strong markup--li-strong">Index State Management</strong>: ISM lets you define custom management policies to automate routine tasks and apply them to indices and<br>index patterns. You no longer need to set up and manage external processes to run your index operations. A policy contains a default<br>state and a list of states for the index to transition between. Within each state, you can define a list of actions to perform and conditions<br>that trigger these transitions. A typical use case is to periodically delete old indices after a certain period of time.</li><li name="214a" id="214a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Organize the data in index by date</strong>: For most logging or monitoring use cases, we can organize indices to be daily, weekly, or monthly,<br>and then we can get an index list by a specified date range. ElasticSearch only needs to query on a smaller dataset instead of the whole<br>dataset. In addition, it would be easy to shrink/delete the old indices when data has expired.</li><li name="840f" id="840f" class="graf graf--li graf-after--li graf--trailing"><strong class="markup--strong markup--li-strong">Use Curator to rotate data</strong>: Curator offers numerous filters to help you identify indices and snapshots that meet certain criteria, such<br>as indices created more than 60 days ago or snapshots that failed to complete</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/2a2485a289c7"><time class="dt-published" datetime="2023-06-05T01:38:26.740Z">June 5, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/best-practices-of-using-elasticsearch-2a2485a289c7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>