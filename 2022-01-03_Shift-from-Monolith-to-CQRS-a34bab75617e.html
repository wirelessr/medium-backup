<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Shift from Monolith to CQRS</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Shift from Monolith to CQRS</h1>
</header>
<section data-field="subtitle" class="p-summary">
Software design is an evolving process. This article shows how to design a system and solve some design problems in DDD and CQRS.
</section>
<section data-field="body" class="e-content">
<section name="ead9" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5bf3" id="5bf3" class="graf graf--h3 graf--leading graf--title">Shift from Monolith to CQRS</h3><p name="7f5a" id="7f5a" class="graf graf--p graf-after--h3">Software design is an evolving process. Every large system starts from a tiny system. When a problem is encountered in the existing architecture but cannot be solved, the system will begin to evolve. Every evolution is accompanied by some technical selections. What problems should be solved? What price will it pay? As an architect or a senior engineer, there must find a reasonable way to evolve, regardless of the development schedule, technical stack, and team level, it is necessary to be able to meet these criteria before a feasible solution can be made.</p><p name="b445" id="b445" class="graf graf--p graf-after--p">This article will introduce the spirit of <code class="markup--code markup--p-code">CQRS</code> (Command Query Responsibility Segmentation) and the problems to be solved. We will start from a small monolith and evolve it like the evolution of every software system, and this article will introduce the reasons and approaches behind each evolution.</p><h3 name="dfd9" id="dfd9" class="graf graf--h3 graf-after--p">Traditional Monolith</h3><figure name="5c72" id="5c72" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*yL20KQu7Fjrk-W5s6Zi36g.png" data-width="854" data-height="626" src="https://cdn-images-1.medium.com/max/800/1*yL20KQu7Fjrk-W5s6Zi36g.png"></figure><p name="b159" id="b159" class="graf graf--p graf-after--figure">This is the most common system design. There is an API server, usually a restful API, and a database. Client negotiates the transmission format with the backend in advance. Both reading and writing are done through DTO, data transfer object. However, when the backend processes business logic, it converts DTO into a domain object with domain knowledge and uses the domain object as the storage unit of the database.</p><p name="4ec8" id="4ec8" class="graf graf--p graf-after--p">In order to achieve <strong class="markup--strong markup--p-strong">Read/Write Splitting</strong>, in the write path on the left, the client sends up DTO to the backend to perform CUD (create/update/delete) operation on the database, and the backend responses to the client with <em class="markup--em markup--p-em">Ack</em> for success and <em class="markup--em markup--p-em">Nak</em> for failure after processing. In restful API, usually 2xx represents success and 4xx represents failure. The read path on the right simply obtains the corresponding DTO through a read request.</p><p name="daeb" id="daeb" class="graf graf--p graf-after--p">I further explain the meaning of DTO for the client. DTO on the client usually contains all the data to render on the screen. For example, when you look at your profile on a social medium, it will include your name, account, and other personal information, as well as your own recent activity, and even the activity you followed. DTO contains all the information that needs to be presented on this page.</p><p name="9c08" id="9c08" class="graf graf--p graf-after--p">Why do we need to emphasize Read/Write Splitting? Can’t we use the same procedure on both the read and write path? Because we want to better optimize our system in the future. The write path has a particular optimization method, and so is the read path. For instance, to make a cache, read aside caching can be used on the read path to reduce the response time. And, the write path can be improved by write through caching. Secondly, the writing may also be performed asynchronously. All the DTOs are written into the message queue and processed by the worker to handle the huge amount of written data. Moreover, each appropriate database may be used for writing and reading.</p><p name="defe" id="defe" class="graf graf--p graf-after--p">Therefore, Read/Write Splitting is essential. And it should be taken into consideration in the early stages of system design. The write path is to concentrate on data persistence; while the read path is to concentrate on data query.</p><p name="644f" id="644f" class="graf graf--p graf-after--p">Nevertheless, there are two main problems in this system design model.</p><ol class="postList"><li name="5c00" id="5c00" class="graf graf--li graf-after--p">Anemic model. It is also known as CRUD model. When backend focuses on data conversion, it is difficult to have space to handle business logic, which will cause business logic to be scattered everywhere. Domain knowledge will also disappear, e.g., to an ecommerse website, we will say “purchase” instead of “inserting an order record”.</li><li name="7eb8" id="7eb8" class="graf graf--li graf-after--li">Insufficient scalability. From the perspective of system architecture, the database can easily become a bottleneck of the entire system. Both reading and writing must be onto it. The problem of RDBMS is even more serious due to no horizontal scaling.</li></ol><h3 name="dd4b" id="dd4b" class="graf graf--h3 graf-after--li">Task-based Monolith</h3><p name="613b" id="613b" class="graf graf--p graf-after--h3">In order to solve the problems encountered by the above traditional monolith, here we try to introduce the concept of domains.</p><figure name="bb63" id="bb63" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Fxz5fFVVKBhUmbrIF6KDLA.png" data-width="854" data-height="626" src="https://cdn-images-1.medium.com/max/800/1*Fxz5fFVVKBhUmbrIF6KDLA.png"></figure><p name="a2be" id="a2be" class="graf graf--p graf-after--figure">This diagram is basically the same as the above one. The only difference is replacing DTO with messages on the write path. Messages contain actions and data, not just the data itself like DTO. Thus, we can carry domain-specific actions in the message to make it easier for the backend to recognize each action, and have a corresponding domain implementation.</p><p name="56e0" id="56e0" class="graf graf--p graf-after--p">At this stage, <strong class="markup--strong markup--p-strong">C</strong> in <code class="markup--code markup--p-code">CQRS</code> has appeared, and message is a kind of commands. However, the problem of scalability is still unresolved.</p><p name="8e64" id="8e64" class="graf graf--p graf-after--p">In addition, although we have simplified DTO and changed to use messages to communicate, we still need DTO on the read path. Let’s take the social medium as an example again. When modifying the nickname, the format of a message may be <code class="markup--code markup--p-code">{&quot;rename&quot;: &quot;LazyDr&quot;}</code>. But when rendering the profile, we still need additional information such as activities. This information gap makes it necessary to do a lot of processing on the read path to retrieve DTO.</p><h3 name="2a4d" id="2a4d" class="graf graf--h3 graf-after--p">CQS (Command Query Segmentation)</h3><p name="4ecf" id="4ecf" class="graf graf--p graf-after--h3">The emergence of CQS is to solve the above pain points of Read/Write Splitting.</p><p name="8086" id="8086" class="graf graf--p graf-after--p">When reading, the client needs DTO, so the backend can do some optimizations dedicated to reading on the read path, such as pre-generating DTO from the original domain object, and storing DTO in a dedicated database for reading.</p><figure name="6d05" id="6d05" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0iuIGQPnWIs_hoM4Kxmb8w.png" data-width="440" data-height="626" src="https://cdn-images-1.medium.com/max/800/1*0iuIGQPnWIs_hoM4Kxmb8w.png"></figure><p name="8a51" id="8a51" class="graf graf--p graf-after--figure">In this way, on the read path, the implementation of the application service becomes simpler. The application service can become a thin read layer, which only needs to be responsible for paging, sorting, etc. After requesting, the client can easily retrieve DTO from the database.</p><p name="c383" id="c383" class="graf graf--p graf-after--p">So the question is, who is going to generate those pre-built DTOs? It is the responsibility of the write path.</p><figure name="86dd" id="86dd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*uZzRH4J6uhN_UanSMBiAWg.png" data-width="440" data-height="626" src="https://cdn-images-1.medium.com/max/800/1*uZzRH4J6uhN_UanSMBiAWg.png"></figure><p name="634d" id="634d" class="graf graf--p graf-after--figure">Although the diagram is similar with the examples seen before, in fact, in addition to persist the domain object, the application service must also persist DTO. In other words, most of the business logic will be pressed on the write path, and various read views need to be prepared.</p><p name="3459" id="3459" class="graf graf--p graf-after--p">At this stage, we have solved most of the problems encountered by the domain, but scaling still has no solution. Now, we further define scaling. Scaling has two different aspects.</p><ol class="postList"><li name="bffb" id="bffb" class="graf graf--li graf-after--p">Traffic: increase in write volume.</li><li name="7f48" id="7f48" class="graf graf--li graf-after--li">Extension: functional requirements increase, such as the need for a variety of different read views. Continuing to take the social medium as an example, there is one presentation on the profile, but there may be another presentation on the timeline.</li></ol><h3 name="de4e" id="de4e" class="graf graf--h3 graf-after--li">CQRS</h3><p name="46a8" id="46a8" class="graf graf--p graf-after--h3">Why is the write path responsible for preparing the read view? Writing should focus on persistence, and those various read views should not be processed on the write path. But there is only reading on the read path, who should prepare those read views?</p><p name="d0ad" id="d0ad" class="graf graf--p graf-after--p">Therefore, the total solution is as follows.</p><figure name="3cb5" id="3cb5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*s5O9jiJ2rv7NRe2b4aLF5g.png" data-width="888" data-height="802" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*s5O9jiJ2rv7NRe2b4aLF5g.png"></figure><p name="9574" id="9574" class="graf graf--p graf-after--figure">The write path on the left and the read path on the right have been introduced in the CQS section. The only difference is that an eventually block is added, which is responsible for converting the database on the write path into the database used on the read path. Once data synchronization is involved, it is possible to encounter data consistency issues, so here is a list of several approaches for implementing eventually consistency, sorted by time consuming from short to long:</p><ol class="postList"><li name="1004" id="1004" class="graf graf--li graf-after--p">Background thread: The typical representative is Redis. After the data is written to the primary, Redis will immediately send the data to the replicas in the background.</li><li name="c845" id="c845" class="graf graf--li graf-after--li">Message queue plus workers: This is a common practice for asynchronous data replication. When writing to the database, an event is initiated into the message queue and processed by the workers.</li><li name="ddd7" id="ddd7" class="graf graf--li graf-after--li">Extract-Transform-Load: This time interval is the longest, ranging from a few minutes to a few hours. Use map-reduce or other methods to write the results on the other side.</li></ol><p name="8ad9" id="8ad9" class="graf graf--p graf-after--li">No matter which approach, the single source of truth is mandatory. That is to say if there is any failure occurred on converting, the system must be able to recover the unfinished jobs. Therefore, the data has to be unique and reliable.</p><p name="387c" id="387c" class="graf graf--p graf-after--p">Data usually laid on two types,</p><ol class="postList"><li name="4c79" id="4c79" class="graf graf--li graf-after--p">state: State refers to what you see at the moment, such as the balance written on the bank passbook.</li><li name="d8d0" id="d8d0" class="graf graf--li graf-after--li">event: An event is an action to modify each state, such as every transaction record on the bank passbook</li></ol><p name="ffc0" id="ffc0" class="graf graf--p graf-after--li">Actually, we already have messages that can be stored as events. For the write path, it is very efficient to store messages in order. Through each different message, you can easily build a different read view according to your needs. This approach is also called <strong class="markup--strong markup--p-strong">event sourcing</strong>.</p><p name="24f9" id="24f9" class="graf graf--p graf-after--p">But only events are difficult to use efficiently. In order to obtain the final result, every conversion must be run from the beginning to the end to rebuild the read view. As a result, the hybrid method would be ideal. On the write path, both the state and the event are kept, and the conversion process can choose the data source based on the actual situation.</p><p name="134e" id="134e" class="graf graf--p graf-after--p">To sum up the whole life cycle of data in CQRS.</p><figure name="ea78" id="ea78" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cZYWVAE37VIdHieRI9oOlA.png" data-width="934" data-height="230" src="https://cdn-images-1.medium.com/max/800/1*cZYWVAE37VIdHieRI9oOlA.png"></figure><p name="069a" id="069a" class="graf graf--p graf-after--figure">The data starts from the client and then enters to the backend in the command format. According to the business logic, it is converted into a domain object and stored in the database. These domain objects are converted into various read views and stored in different read special databases according to requirements. Finally, the client takes these read views back in the form of DTO.</p><h3 name="5a1e" id="5a1e" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="09d9" id="09d9" class="graf graf--p graf-after--h3">There are many books and articles describing DDD and CQRS with many patterns. From my point of view, those patterns lead to the limitation on imagination of DDD like Entity, Value Object, Aggregate, etc. It results in most developers feel DDD is far from themselves and hard to realize as well as implementations. In fact, the concepts of DDD is not so complicated; instead, DDD is proposed to encapsulate the business logic and then facilitate expending the functional requirements.</p><p name="dc89" id="dc89" class="graf graf--p graf-after--p">CQRS is even simpler. In this article, we start from the process of system evolution, understand the entire system design process and the problems to be solved, and finally derive the conclusion of CQRS naturally.</p><p name="bbb3" id="bbb3" class="graf graf--p graf-after--p">There is no silver bullet in the system design. Each evolution is made for solving some specific problems, however, it may come out a new problem. Take the design processes of this article as an example, CQRS seems to resolve all mentioned problems, anemic model, and insufficient scalability, but actually CQRS also brings new problems, such as data consistency. Each technical selection has its trade-off, as long as understanding all threats behind every option, you can choose relatively acceptable approaches.</p><p name="b9cd" id="b9cd" class="graf graf--p graf-after--p">Even if you choose CQRS, in practice, there are still three choices on implementing eventual consistency. System design is the result of continuous selection.</p><p name="fe4e" id="fe4e" class="graf graf--p graf-after--p graf--trailing">The purpose of this article is to tell you that DDD is not that scary, and CQRS is not that complicated, it is just a decision.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/a34bab75617e"><time class="dt-published" datetime="2022-01-03T01:20:59.588Z">January 3, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/shift-from-monolith-to-cqrs-a34bab75617e" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>