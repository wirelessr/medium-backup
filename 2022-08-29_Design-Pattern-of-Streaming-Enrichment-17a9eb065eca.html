<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Design Pattern of Streaming Enrichment</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Design Pattern of Streaming Enrichment</h1>
</header>
<section data-field="subtitle" class="p-summary">
Understanding the concept of streaming architecture
</section>
<section data-field="body" class="e-content">
<section name="a0c1" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="03f3" id="03f3" class="graf graf--h3 graf--leading graf--title">Design Pattern of Streaming Enrichment</h3><h4 name="af21" id="af21" class="graf graf--h4 graf-after--h3 graf--subtitle">Understanding the concept of streaming architecture</h4><figure name="522c" id="522c" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*gwm6shsOymkXvJPF" data-width="1000" data-height="667" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*gwm6shsOymkXvJPF"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@jfobranco" data-href="https://unsplash.com/@jfobranco" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Joao Branco</a> on <a href="https://unsplash.com/photos/1_2d3MRbI9c" data-href="https://unsplash.com/photos/1_2d3MRbI9c" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="71e6" id="71e6" class="graf graf--p graf-after--figure">Last time, we <a href="https://lazypro.medium.com/stream-processing-introduction-796f15061880" data-href="https://lazypro.medium.com/stream-processing-introduction-796f15061880" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">introduced streaming processing</a>. In order to be able to handle batch and real-time data with a more pure infrastructure, we introduced Kafka and the streaming framework.</p><p name="0082" id="0082" class="graf graf--p graf-after--p">In this article, we will introduce a common design pattern for streaming, enrichment, and examine what benefits the streaming framework can bring.</p><p name="91a7" id="91a7" class="graf graf--p graf-after--p">What is enrichment? Briefly, it is the implementation of extending the original events to meet the new feature requirements.</p><h3 name="1bc9" id="1bc9" class="graf graf--h3 graf-after--p">Feature Description</h3><p name="9fea" id="9fea" class="graf graf--p graf-after--h3">Similar features are available on many social media platforms.</p><ol class="postList"><li name="983c" id="983c" class="graf graf--li graf-after--p">Who visits me</li><li name="940a" id="940a" class="graf graf--li graf-after--li">Others are also viewing</li><li name="d8c5" id="d8c5" class="graf graf--li graf-after--li">What is the identity to view me</li></ol><p name="77dd" id="77dd" class="graf graf--p graf-after--li">The first feature is how many people have viewed my profile in a given time period. For example, how many times my profile has been viewed in a week.</p><p name="12ad" id="12ad" class="graf graf--p graf-after--p">The second feature is an advanced version of the previous feature, who else did these people view? For example, 10 people viewed my profile in a week, and they also viewed Elon Musk.</p><p name="05f0" id="05f0" class="graf graf--p graf-after--p">The third feature is a derivative of the first one. What is the identity of these people who viewed me? For example, 10 people viewed my profile in a week, and three of them were google employees.</p><h3 name="a65b" id="a65b" class="graf graf--h3 graf-after--p">Who visits me &amp; Others are also viewing</h3><p name="ca76" id="ca76" class="graf graf--p graf-after--h3">The first and second features can be easily implemented using event streaming techniques. First, let’s define a “view” event.</p><pre name="1cec" id="1cec" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">{<br>    eventType: &quot;PageView&quot;,<br>    timestamp: 1660270009,<br>    viewerId: 1234,<br>    viewedId: 5678<br>}</code></pre><p name="2f4b" id="2f4b" class="graf graf--p graf-after--pre">This event includes the time of occurrence and who viewed who. Then we just need to create a stream that collects all view events to analyze the features we need.</p><figure name="824b" id="824b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*TirXw-Z-2iyoHmgd.png" data-width="846" data-height="312" src="https://cdn-images-1.medium.com/max/800/0*TirXw-Z-2iyoHmgd.png"></figure><p name="6014" id="6014" class="graf graf--p graf-after--figure">In the above diagram, suppose my user id is 4567, then it is easy to find two users who have viewed me from the event stream, which are 2345 and 1234.</p><p name="3503" id="3503" class="graf graf--p graf-after--p">Further from the stream record, we can also understand that 2345 has viewed 1234, while 1234 has viewed 5678 and 2345.</p><p name="e188" id="e188" class="graf graf--p graf-after--p">Putting this information together, we can answer.</p><ol class="postList"><li name="f00c" id="f00c" class="graf graf--li graf-after--p">Who visits me? 2345 and 1234.</li><li name="f07f" id="f07f" class="graf graf--li graf-after--li">Others are also viewing 1234, 5678, and 2345.</li></ol><p name="a3aa" id="a3aa" class="graf graf--p graf-after--li">With all the event streams recorded by the streaming framework, we can perform a simple analysis to get the desired features.</p><h3 name="51f7" id="51f7" class="graf graf--h3 graf-after--p">What is the identity to view me?</h3><p name="5f43" id="5f43" class="graf graf--p graf-after--h3">However, it is not so simple to know what the identity to view my profile is.</p><p name="cbfa" id="cbfa" class="graf graf--p graf-after--p">Because our original event did not define additional attributes, only the id. Well, it is necessary to modify the original implementation to add new features.</p><h3 name="4995" id="4995" class="graf graf--h3 graf-after--p">Add metadata in events</h3><p name="104f" id="104f" class="graf graf--p graf-after--h3">Let’s add the job to the original event. When the user is viewing, in addition to sending the event with the id, the job must also be attached.</p><pre name="853e" id="853e" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">{<br>    eventType: &quot;PageView&quot;,<br>    timestamp: 1660270009,<br>    viewerId: 1234,<br>    viewedId: 5678,<br>    viewerJob: &quot;Google&quot;<br>}</code></pre><p name="d0f7" id="d0f7" class="graf graf--p graf-after--pre">The problem seems to be solved, but is it really so?</p><p name="5bba" id="5bba" class="graf graf--p graf-after--p">There are several obvious issues with such a solution. Firstly, modifying the event format directly affects all downstream consumers. Under an event-driven architecture, the producer would not know the consumer’s use cases because the two are decoupled.</p><p name="6758" id="6758" class="graf graf--p graf-after--p">Secondly, events become larger, and each original event must add this new field, whether the consumer needs it or not. In other words, the overhead has gotten bigger, not just in terms of storage overhead, but also transmission overhead.</p><p name="5626" id="5626" class="graf graf--p graf-after--p">Moreover, what to do if we want to add new features? In addition to the job, the feature requires a new title, age, and so on. Then the issues mentioned above will happen again and again.</p><p name="eec3" id="eec3" class="graf graf--p graf-after--p">Therefore, we know this is not a good approach.</p><h3 name="bde2" id="bde2" class="graf graf--h3 graf-after--p">Query from external datastores</h3><p name="a874" id="a874" class="graf graf--p graf-after--h3">Since modifying the original event is not a good approach, we will query the required data from elsewhere as soon as we receive the event.</p><figure name="9bea" id="9bea" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*RO4y1Z5g8mZWnMY4.png" data-width="674" data-height="548" src="https://cdn-images-1.medium.com/max/800/0*RO4y1Z5g8mZWnMY4.png"></figure><p name="f28a" id="f28a" class="graf graf--p graf-after--figure">Although it is stated in the diagram as a database, it can also be a microservice or any platform that can provide information.</p><p name="4c79" id="4c79" class="graf graf--p graf-after--p">Basically, this is the most typical implementation of an event-driven architecture. When workers take events from the message queue, they process the data, either by getting the necessary information from other data sources or by storing the results in a data store, and finally by sending the enriched events to the next one.</p><p name="58cd" id="58cd" class="graf graf--p graf-after--p">This implementation is fine in a message queue architecture. However, in a streaming framework, such an implementation creates a performance bottleneck. Let’s say a streaming framework has an average throughput of more than ten times of a database. If every event had to rely on external data sources, the overall throughput would become <code class="markup--code markup--p-code">1/10</code>.</p><p name="1836" id="1836" class="graf graf--p graf-after--p">In addition, there is an existing issue with such an architecture.</p><p name="f7c3" id="f7c3" class="graf graf--p graf-after--p">When a worker cluster or streaming processing cluster crashes, this is very likely to happen, after all, errors are everywhere. At this point, events will continue to accumulate because no consumer will be able to handle them. This is still the normal situation.</p><p name="3a76" id="3a76" class="graf graf--p graf-after--p">Once the worker cluster is repaired and all workers are online, all workers will start digesting the message at full speed and a spike will hit the data source and most likely shut it down.</p><p name="0eec" id="0eec" class="graf graf--p graf-after--p">Own failure affects other services in a cascading manner. This tight coupling is to be avoided in the system design. Therefore, such a solution is not good enough.</p><h3 name="733d" id="733d" class="graf graf--h3 graf-after--p">Merge events</h3><p name="2b74" id="2b74" class="graf graf--p graf-after--h3">No new metadata into the event and can not be queried from external sources, then how to deal with the enrichment? This is the streaming framework to deliver the advantages.</p><figure name="fcf6" id="fcf6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*Ap2LAwIOIrq_r3Ob.png" data-width="674" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*Ap2LAwIOIrq_r3Ob.png"></figure><p name="1df0" id="1df0" class="graf graf--p graf-after--figure">In this example, we have chosen Apache Samza as an illustration, but in fact there are many good alternatives, such as Apache Flink.</p><p name="a9c7" id="a9c7" class="graf graf--p graf-after--p">In addition to changing the handler mentioned in the previous section to a stream processing framework, there is a new event source, <code class="markup--code markup--p-code">ProfileEdit</code>.</p><p name="c447" id="c447" class="graf graf--p graf-after--p">This modification event can either come from the Change Data Capture (CDC) of the database, or the modification event can be sent from the user service, but the details are not the focus of this article.</p><p name="4fa1" id="4fa1" class="graf graf--p graf-after--p">The database from the previous section becomes the state in the stream processing framework. This state can be considered as a memory space for each worker, and is therefore very efficient. In addition, each worker shares the state, so the capacity is much larger than a single instance’s memory.</p><p name="30b7" id="30b7" class="graf graf--p graf-after--p">When Samza receives <code class="markup--code markup--p-code">ProfileEdit</code>, it can save the latest state of each user. Once <code class="markup--code markup--p-code">PageView</code> is received, it can pull out the required information from the saved state, and assemble new events.</p><p name="dd5a" id="dd5a" class="graf graf--p graf-after--p">This approach solves the problem of tight coupling and significantly improves processing performance. More importantly, Samza provides an exactly-once guarantee to avoid duplication of events due to failure of external data sources.</p><p name="2a49" id="2a49" class="graf graf--p graf-after--p">Although the state is shared by multiple instances, it is still possible to hit the upper limit. How to solve the scalability issue?</p><p name="389f" id="389f" class="graf graf--p graf-after--p">In Kafka, a message partitioning mechanism is provided, where messages with the same key are assigned to the same partition and processed by the same consumer group. In the streaming framework, the partitioning mechanism still exists and has been abstracted to a higher level. Different streams can share the same key space, i.e., as long as <code class="markup--code markup--p-code">PageView</code> and <code class="markup--code markup--p-code">ProfileEdit</code> have the same key, they can be processed by the same workers.</p><p name="4bec" id="4bec" class="graf graf--p graf-after--p">In this way, the state can be stored by horizontal scalability.</p><h3 name="7bd2" id="7bd2" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="1d3d" id="1d3d" class="graf graf--p graf-after--h3">In this article, we introduce a common design pattern that both traditional message queue architecture and modern stream processing architecture encounter the same issue, i. e., event enrichment.</p><p name="9fb7" id="9fb7" class="graf graf--p graf-after--p">When designing a system, it is important to take into account the robustness and performance of the system in addition to the feature implementation. This is why streaming frameworks are on the rise. Streaming offers the possibility to handle real-time heavy traffic, while streaming frameworks additionally provide a variety of useful tools to make development easy.</p><p name="e976" id="e976" class="graf graf--p graf-after--p graf--trailing">As mentioned in the <a href="https://lazypro.medium.com/stream-processing-introduction-796f15061880" data-href="https://lazypro.medium.com/stream-processing-introduction-796f15061880" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">previous article on streaming architecture</a>, the streaming architecture has the ability to collapse many technology stacks into two core components: Kafka and the streaming processing framework. Therefore, I recommend that every developer, even if you are not a data engineer, should learn about the streaming framework. I believe having more insight will lead to a more reliable system design.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/17a9eb065eca"><time class="dt-published" datetime="2022-08-29T01:15:34.967Z">August 29, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/design-pattern-of-streaming-enrichment-17a9eb065eca" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>