<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Consistency between Cache and Database, Part 1</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Consistency between Cache and Database, Part 1</h1>
</header>
<section data-field="subtitle" class="p-summary">
Part 1: Read Aside Caching
</section>
<section data-field="body" class="e-content">
<section name="0099" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1d7a" id="1d7a" class="graf graf--h3 graf--leading graf--title">Consistency between Cache and Database, Part 1</h3><figure name="cd65" id="cd65" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*wfvcwb8VGPW7N1ZH.png" data-width="1770" data-height="1180" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*wfvcwb8VGPW7N1ZH.png"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@jtc" data-href="https://unsplash.com/@jtc" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Jesse Collins</a> on <a href="https://unsplash.com/photos/5sCQ4-t6p38" data-href="https://unsplash.com/photos/5sCQ4-t6p38" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><ul class="postList"><li name="b39e" id="b39e" class="graf graf--li graf-after--figure">Part 1: <a href="https://lazypro.medium.com/consistency-between-cache-and-database-part-1-f64f4a76720" data-href="https://lazypro.medium.com/consistency-between-cache-and-database-part-1-f64f4a76720" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Read Aside Caching</a></li><li name="6ace" id="6ace" class="graf graf--li graf-after--li">Part 2: <a href="https://lazypro.medium.com/consistency-between-cache-and-database-part-2-e28fc7f8a7c3" data-href="https://lazypro.medium.com/consistency-between-cache-and-database-part-2-e28fc7f8a7c3" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Enhanced Approaches</a></li></ul><p name="70b4" id="70b4" class="graf graf--p graf-after--li">Today we are going to talk about consistency, especially the consistency of data between cache and database. This is actually an important topic, particularly as the size of an organization increases, the requirements for consistency will grow and so will the implementation of consistency.</p><p name="6fc5" id="6fc5" class="graf graf--p graf-after--p">For example, a startup service will not have a higher Service Level Agreement, aka SLA, than a mature service. For a startup service, a data consistency SLA of four nines (99.99%) might be considered high, but for a mature service like <a href="https://aws.amazon.com/s3/storage-classes/?nc1=h_ls" data-href="https://aws.amazon.com/s3/storage-classes/?nc1=h_ls" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">AWS S3</a>, the data SLA is as high as 11 nines.</p><p name="aef3" id="aef3" class="graf graf--p graf-after--p">We all know that for every nine, the difficulty and complexity of the implementation will increase in an exponential way, so for a startup service, there are basically no resources to maintain a very high SLA.</p><p name="e210" id="e210" class="graf graf--p graf-after--p">Thus, how can we use the resources as effectively as possible to improve consistency? That’s what this article will introduce. Again, the consistency mentioned here refers specifically to the consistency between cache and database data.</p><h3 name="0fe5" id="0fe5" class="graf graf--h3 graf-after--p">Why Caching?</h3><p name="9f10" id="9f10" class="graf graf--p graf-after--h3">I believe we all agree that inconsistencies are inevitable when we put data in two different storages. So what makes us put data into cache rather than risking inconsistency?</p><ol class="postList"><li name="a744" id="a744" class="graf graf--li graf-after--p">The price of databases is high. In order to provide data persistence and as high availability as possible, even the relational database provides ACID guarantee, which makes the database implementation complex and also consumes hardware resources. Regardless of hard drives, memory or CPU, the database must be supported by good hardware specifications in order to work well, which also leads to the high price of the database itself.</li><li name="b3bc" id="b3bc" class="graf graf--li graf-after--li">The performance of the database is limited. In order to persist the data, the data written to the database must be written to the hard drives, which also causes the performance bottleneck of the database, after all, the read and write efficiency of hard drives is much worse than memory.</li><li name="fb37" id="fb37" class="graf graf--li graf-after--li">The database is far away from the user. Here, the far means the physical distance. As mentioned in the first point, because of the high cost of databases and the need to centralize data as much as possible for further analysis and utilization, a global service database is not placed in all over the world. The most common practice is to choose a fixed location. In Asia, for example, because AWS’s Singapore data center is lower priced, it is often chosen for Asian users, but for Japanese users, the network distance increases and the transfer rate decreases.</li></ol><p name="44eb" id="44eb" class="graf graf--p graf-after--li">For the above three reasons, the need for caching arises.</p><p name="776f" id="776f" class="graf graf--p graf-after--p">Because a cache does not need to be persistent, it can use memory as the storage medium, so it is inexpensive and has excellent performance. Because of the low price, caches can be placed as close to the user as possible, for instance, caches can be placed in Tokyo so that users in Japan can use them nearby.</p><h3 name="299b" id="299b" class="graf graf--h3 graf-after--p">Caching Patterns</h3><p name="2f9a" id="2f9a" class="graf graf--p graf-after--h3">It seems that caching is necessary, so how do we use caching for the consistency as much as possible?</p><p name="3ca2" id="3ca2" class="graf graf--p graf-after--p">To keep this article from losing focus, the caches mentioned are all based on Redis and the database is MySQL, and our goal is to improve consistency as much as possible with limited resources, both hardware and manpower, so the complex architectures of many large organizations are out of our scope, such as Meta’s <a href="https://engineering.fb.com/2013/06/25/core-data/tao-the-power-of-the-graph/" data-href="https://engineering.fb.com/2013/06/25/core-data/tao-the-power-of-the-graph/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">TAO</a>.</p><p name="0ed4" id="0ed4" class="graf graf--p graf-after--p">TAO is a distributed cache and has a very high SLA (10 nines). However, to operate such a service, there is a very complex architecture behind it, and even the monitoring of caching is extremely large, which is not affordable for an ordinary organization.</p><p name="f8f7" id="f8f7" class="graf graf--p graf-after--p">Therefore, we will focus on the following patterns, highlighting their problems and how to avoid them as much as possible.</p><ul class="postList"><li name="de57" id="de57" class="graf graf--li graf-after--p">Cache Expiry</li><li name="8483" id="8483" class="graf graf--li graf-after--li">Read Aside</li><li name="71b3" id="71b3" class="graf graf--li graf-after--li">Read Through</li><li name="dce2" id="dce2" class="graf graf--li graf-after--li">Write Through</li><li name="72c5" id="72c5" class="graf graf--li graf-after--li">Write Ahead (Write Behind)</li><li name="e780" id="e780" class="graf graf--li graf-after--li">Double Delete</li></ul><p name="93b8" id="93b8" class="graf graf--p graf-after--li">The following sections will follow the below procedure.</p><ol class="postList"><li name="d36c" id="d36c" class="graf graf--li graf-after--p">read path</li><li name="6120" id="6120" class="graf graf--li graf-after--li">write path</li><li name="51cf" id="51cf" class="graf graf--li graf-after--li">potential problems</li><li name="4ae3" id="4ae3" class="graf graf--li graf-after--li">how to improve</li></ol><h3 name="63ab" id="63ab" class="graf graf--h3 graf-after--li">Cache Expiry</h3><p name="af47" id="af47" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Read Path</strong></p><ul class="postList"><li name="0118" id="0118" class="graf graf--li graf-after--p">Reading data from cache</li><li name="7a43" id="7a43" class="graf graf--li graf-after--li">If the cache data does not exist</li><li name="3ba4" id="3ba4" class="graf graf--li graf-after--li">Read from the database instead</li><li name="6a36" id="6a36" class="graf graf--li graf-after--li">and write back to the cache</li></ul><p name="74a1" id="74a1" class="graf graf--p graf-after--li">We add a TTL to each data when writing back to the cache.</p><blockquote name="5869" id="5869" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">EXPIRE key seconds [ NX | XX | GT | LT]</em></blockquote><p name="a6a5" id="a6a5" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Write Path</strong></p><ul class="postList"><li name="c7f0" id="c7f0" class="graf graf--li graf-after--p">Write data to the database only</li></ul><p name="bc3b" id="bc3b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Potential Problems</strong></p><p name="a53d" id="a53d" class="graf graf--p graf-after--p">When updating data, inconsistencies occur because the data is only written back to the database. The inconsistency time depends on the TTL settings, nevertheless, it is difficult to choose a suitable value for the TTL.</p><p name="97e9" id="97e9" class="graf graf--p graf-after--p">If the TTL is set too long, the inconsistency time will be increased and, on the contrary, the cache will not be effective.</p><p name="36ed" id="36ed" class="graf graf--p graf-after--p">It is worth mentioning that caching is built to reduce the load on the database and to provide performance, and a very short TTL will make caching useless. For example, if the TTL of a certain data is set to 1 second, but no one reads it within 1 second, then the cached data will be no value at all.</p><p name="4742" id="4742" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How to Improve</strong></p><p name="3cd3" id="3cd3" class="graf graf--p graf-after--p">The read path seems to be the usual practice, but when the database is updated, there should also be a mechanism for updating the cached data. And this is also the concept of <em class="markup--em markup--p-em">Read Aside</em>.</p><h3 name="78a7" id="78a7" class="graf graf--h3 graf-after--p">Read Aside</h3><p name="6969" id="6969" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Read Path</strong></p><ul class="postList"><li name="39fd" id="39fd" class="graf graf--li graf-after--p">Reading data from cache</li><li name="1f52" id="1f52" class="graf graf--li graf-after--li">If the cache data does not exist</li><li name="40e5" id="40e5" class="graf graf--li graf-after--li">Read from the database instead</li><li name="03b2" id="03b2" class="graf graf--li graf-after--li">and write back to the cache</li></ul><p name="4bcc" id="4bcc" class="graf graf--p graf-after--li">This process is the same as <em class="markup--em markup--p-em">Cache Expiry</em>, but the TTL can be set long enough. This allows the cache to have as much play time as possible.</p><p name="d8c4" id="d8c4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Write Path</strong></p><ul class="postList"><li name="e906" id="e906" class="graf graf--li graf-after--p">Write the data into the database first</li><li name="6817" id="6817" class="graf graf--li graf-after--li">Then clean cache.</li></ul><p name="7201" id="7201" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Potential Problems</strong></p><p name="c191" id="c191" class="graf graf--p graf-after--p">Such read and write paths look fine, but there are a few corner cases that can’t be avoided.</p><figure name="44f8" id="44f8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dPnVCTxrsXgsJdOtXUN3IA.png" data-width="1046" data-height="598" src="https://cdn-images-1.medium.com/max/800/1*dPnVCTxrsXgsJdOtXUN3IA.png"><figcaption class="imageCaption">Corner Case 1</figcaption></figure><p name="5da1" id="5da1" class="graf graf--p graf-after--figure graf--trailing"><code class="markup--code markup--p-code">A</code> wants to update the data, but <code class="markup--code markup--p-code">B</code> wants to read the data at the same time. Individually, both <code class="markup--code markup--p-code">A</code> and <code class="markup--code markup--p-code">B</code> have the right process, but when both of them happen together, there may be a problem. In the above example, <code class="markup--code markup--p-code">B</code> has already read the data from the cache before <code class="markup--code markup--p-code">A</code> clears the cache, so the data that <code class="markup--code markup--p-code">B</code> gets at that moment will be old.</p></div></div></section><section name="db3c" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><figure name="0485" id="0485" class="graf graf--figure graf--leading"><img class="graf-image" data-image-id="1*yyq6QF-JhPSQxxjVUWrn4A.png" data-width="1016" data-height="650" src="https://cdn-images-1.medium.com/max/800/1*yyq6QF-JhPSQxxjVUWrn4A.png"><figcaption class="imageCaption">Corner Case 2</figcaption></figure><p name="143c" id="143c" class="graf graf--p graf-after--figure">When <code class="markup--code markup--p-code">A</code> is updating the data, the database is already finished updating, but it is killed due to “some reason”. At this moment, the data in the cache will remain inconsistent for a while until the next time the database is updated or a TTL occurs.</p><p name="eba6" id="eba6" class="graf graf--p graf-after--p">Getting killed may sound serious and rare, but it’s actually more likely to happen than you might think. There are several scenarios where a kill can occur.</p><ol class="postList"><li name="6a63" id="6a63" class="graf graf--li graf-after--p">When changing versions, either through containers or VMs, the old version of the application must be replaced with the new version, and the old version will be killed.</li><li name="e395" id="e395" class="graf graf--li graf-after--li">When scale-in, the redundant application will be recycled and will also be killed.</li><li name="2a68" id="2a68" class="graf graf--li graf-after--li graf--trailing">Lastly, it is the most common, when the application crashes, it will inevitably be killed.</li></ol></div></div></section><section name="e122" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><figure name="b3e4" id="b3e4" class="graf graf--figure graf--leading"><img class="graf-image" data-image-id="1*68BT1_-j09AlAkx-PqNYpw.png" data-width="1040" data-height="808" src="https://cdn-images-1.medium.com/max/800/1*68BT1_-j09AlAkx-PqNYpw.png"><figcaption class="imageCaption">Corner Case 3</figcaption></figure><p name="88d4" id="88d4" class="graf graf--p graf-after--figure">When <code class="markup--code markup--p-code">A</code> wants to read the data and <code class="markup--code markup--p-code">B</code> wants to update the data, again, both of them have the right individual process, but the error occurs.</p><p name="c79d" id="c79d" class="graf graf--p graf-after--p">First <code class="markup--code markup--p-code">A</code> is trying to read data because no corresponding result is found in the cache, so he reads from the database; at the same time, <code class="markup--code markup--p-code">B</code> is trying to update the data so he clears the cache after the database operation. Then, <code class="markup--code markup--p-code">A</code> writes the data to the cache, and the inconsistency occurs, and the inconsistency will remain for a while.</p><p name="267b" id="267b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How to Improve</strong></p><p name="ef37" id="ef37" class="graf graf--p graf-after--p">Case 1 and Case 3 can be minimized when the application manipulates data correctly. Take Case 1 as an example, don’t do anything extra after updating the database and clean up the cache right away, while in Case 3, after reading data from the database, don’t do too much format conversion and write the result to the cache as soon as possible. In this way, the chance of occurrence can be reduced, but even so, there are still some unavoidable situations, such as the stop-the-world generated by garbage collection.</p><p name="c3ed" id="c3ed" class="graf graf--p graf-after--p">Case 2, on the other hand, can reduce the chance of artificial occurrences by implementing a graceful shutdown, but there is nothing that can be done for an application crash.</p><h3 name="a990" id="a990" class="graf graf--h3 graf-after--p">Read Aside Variant</h3><p name="cac8" id="cac8" class="graf graf--p graf-after--h3">In order to solve Case 1 and Case 2, some people will try to modify the original process.</p><p name="afb9" id="afb9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Read Path</strong></p><ul class="postList"><li name="50e8" id="50e8" class="graf graf--li graf-after--p">Reading data from cache</li><li name="098b" id="098b" class="graf graf--li graf-after--li">If the cache data does not exist</li><li name="4400" id="4400" class="graf graf--li graf-after--li">Read from the database instead</li><li name="10cc" id="10cc" class="graf graf--li graf-after--li">and write back to the cache</li></ul><p name="5274" id="5274" class="graf graf--p graf-after--li">This process is exactly the same as the original <em class="markup--em markup--p-em">Read Aside</em>.</p><p name="a5ea" id="a5ea" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Write Path</strong></p><ul class="postList"><li name="fca4" id="fca4" class="graf graf--li graf-after--p">Clean cache first</li><li name="01d2" id="01d2" class="graf graf--li graf-after--li">Then write the data into the database.</li></ul><p name="12b7" id="12b7" class="graf graf--p graf-after--li">This process is the opposite of the original <em class="markup--em markup--p-em">Read Aside</em>.</p><p name="2c8b" id="2c8b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Potential Problems</strong></p><figure name="3e62" id="3e62" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*TwDOLUw9pRSgpgNFfLuDJw.png" data-width="1040" data-height="752" src="https://cdn-images-1.medium.com/max/800/1*TwDOLUw9pRSgpgNFfLuDJw.png"></figure><p name="40a4" id="40a4" class="graf graf--p graf-after--figure">Although the original Case 1 and Case 2 are solved, a new problem is created.</p><p name="27ff" id="27ff" class="graf graf--p graf-after--p">When <code class="markup--code markup--p-code">A</code> tries to update the data, and <code class="markup--code markup--p-code">B</code> wants to read the data, <code class="markup--code markup--p-code">A</code> clears the cache first; then <code class="markup--code markup--p-code">B</code> cannot read the data, so it reads from the database instead, and <code class="markup--code markup--p-code">A</code> continues to update the database. Finally, <code class="markup--code markup--p-code">B</code> writes the read data back to the cache. The inconsistency is occurred.</p><p name="7533" id="7533" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How to Improve</strong></p><p name="3e2e" id="3e2e" class="graf graf--p graf-after--p">In fact, Case 1 and Case 2 are much less likely to occur than the corner cases of this variant, especially when the correct implementation of <em class="markup--em markup--p-em">Read Aside</em> has significantly reduced the occurrence of Case 1 and Case 2. On the other hand, the corner cases of the variant cannot be effectively improved.</p><blockquote name="d55d" id="d55d" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Therefore, it is not recommended to use such a variant.</em></blockquote><h3 name="7529" id="7529" class="graf graf--h3 graf-after--blockquote">Conclusion</h3><p name="7709" id="7709" class="graf graf--p graf-after--h3">In general, a relatively high level of consistency can be achieved by <em class="markup--em markup--p-em">Read Aside</em>, even if it is only a simple implementation, but it can also have a very good reliability.</p><p name="cad0" id="cad0" class="graf graf--p graf-after--p">Nevertheless, if you would like to improve consistency further, <em class="markup--em markup--p-em">Read Aside</em> alone is not enough, and a more complex approach is required, but also at a higher cost. Therefore, I will leave these approaches for the next article. In the next article, I will describe how to make the best use of the resources at hand to achieve as much consistency as possible.</p><p name="7c06" id="7c06" class="graf graf--p graf-after--p graf--trailing">To emphasize again, although <em class="markup--em markup--p-em">Read Aside</em> is very simple, it is reliable enough as long as it is implemented correctly.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/f64f4a76720"><time class="dt-published" datetime="2022-07-03T23:36:56.068Z">July 3, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/consistency-between-cache-and-database-part-1-f64f4a76720" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>