<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Explaining Pagination in ElasticSearch</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Explaining Pagination in ElasticSearch</h1>
</header>
<section data-field="subtitle" class="p-summary">
Three Pagination Approaches with SQL and ElasticSearch Demonstration
</section>
<section data-field="body" class="e-content">
<section name="a203" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="fdd5" id="fdd5" class="graf graf--h3 graf--leading graf--title">Explaining Pagination in ElasticSearch</h3><h4 name="53cd" id="53cd" class="graf graf--h4 graf-after--h3 graf--subtitle">Three Pagination Approaches with SQL and ElasticSearch Demonstration</h4><figure name="ea8d" id="ea8d" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*z_KdwaWl6y2DMX6w" data-width="1000" data-height="666" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*z_KdwaWl6y2DMX6w"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@benceboros" data-href="https://unsplash.com/@benceboros" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">BENCE BOROS</a> on <a href="https://unsplash.com/photos/KnVUtC5bl_A" data-href="https://unsplash.com/photos/KnVUtC5bl_A" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="a42f" id="a42f" class="graf graf--p graf-after--figure">Pagination is a common technique for web page presentation. When there is a lot of returned data, either to reduce the load on the backend or to improve the user experience, it is usually a good idea to limit the amount of presentation and keep the option to continue browsing.</p><p name="f24d" id="f24d" class="graf graf--p graf-after--p">Here’s a quick look at the most common appearance.</p><p name="cb70" id="cb70" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&lt; [1] | 2 | 3 | 4 | ... &gt;</code></p><p name="5e97" id="5e97" class="graf graf--p graf-after--p">The user can know the current page number, choose the previous or next page, or even jump directly to the specified page. There are three types of pagination approaches as follows.</p><ul class="postList"><li name="2d0e" id="2d0e" class="graf graf--li graf-after--p">Offset Pagination</li><li name="5834" id="5834" class="graf graf--li graf-after--li">Keyset Pagination</li><li name="0ed5" id="0ed5" class="graf graf--li graf-after--li">Cursor-based Pagination</li></ul><p name="88f5" id="88f5" class="graf graf--p graf-after--li">But this article is to introduce ElasticSearch pagination, so I will briefly describe these three.</p><h3 name="91dc" id="91dc" class="graf graf--h3 graf-after--p">Offset Pagination</h3><p name="35e6" id="35e6" class="graf graf--p graf-after--h3">This is the most common pagination pattern, and let’s represent it in SQL.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="f1f4" id="f1f4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br /><span class="hljs-keyword">FROM</span> table_name<br />LIMIT <span class="hljs-number">10</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">20</span>;</span></pre><p name="0af9" id="0af9" class="graf graf--p graf-after--pre">Suppose there are 10 records on one page, then we can get the result of the third page by this command. Use <code class="markup--code markup--p-code">LIMIT</code> to limit the number of records per page and use <code class="markup--code markup--p-code">OFFSET</code> to jump to the specified page.</p><p name="17a3" id="17a3" class="graf graf--p graf-after--p">There are many advantages of such a pagination.</p><ol class="postList"><li name="2169" id="2169" class="graf graf--li graf-after--p">It is very easy to implement, as well as very intuitive.</li><li name="7cc5" id="7cc5" class="graf graf--li graf-after--li">It is possible to jump to a random page.</li></ol><p name="b5d6" id="b5d6" class="graf graf--p graf-after--li">But the disadvantages are also obvious.</p><ol class="postList"><li name="9505" id="9505" class="graf graf--li graf-after--p">Performance is a problem.</li></ol><p name="67c0" id="67c0" class="graf graf--p graf-after--li">Why is there a performance problem?</p><p name="a274" id="a274" class="graf graf--p graf-after--p">In the above example, it looks like we only need to take 10 records from the database, but in fact, the database will take 30 records and discard the first 20 records. When <code class="markup--code markup--p-code">OFFSET</code> is very large then the database will still take all the records and create a lot of overhead.</p><h3 name="3c6b" id="3c6b" class="graf graf--h3 graf-after--p">Keyset Pagination</h3><p name="aa33" id="aa33" class="graf graf--p graf-after--h3">In order to solve the performance problem, we have the keyset pagination approach.</p><p name="b0d3" id="b0d3" class="graf graf--p graf-after--p">We still use SQL as an example, following the above scenario, we limit the number of records per page to 10 and take the third page.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="vbnet" name="6db0" id="6db0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> *<br /><span class="hljs-keyword">FROM</span> table_name<br /><span class="hljs-keyword">WHERE</span> id &gt; <span class="hljs-number">20</span><br /><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id<br />LIMIT <span class="hljs-number">10</span>;</span></pre><p name="b42c" id="b42c" class="graf graf--p graf-after--pre">Using <code class="markup--code markup--p-code">LIMIT</code> to limit the number of records per page is the same as above, except that we first sort by <code class="markup--code markup--p-code">ORDER BY</code> and then set the starting position by <code class="markup--code markup--p-code">WHERE</code> instead of <code class="markup--code markup--p-code">OFFSET</code>. In this way, we can get the third page without taking 30 records.</p><p name="ab95" id="ab95" class="graf graf--p graf-after--p">There are several implementation details that must be paid attention.</p><ol class="postList"><li name="3f30" id="3f30" class="graf graf--li graf-after--p">Must be able to sort quickly, in the case of relational databases, the columns to be sorted must have indexes.</li><li name="f5a6" id="f5a6" class="graf graf--li graf-after--li">Where do the <code class="markup--code markup--li-code">WHERE</code> clause come from? It can be from the frontend with the last position of pages, or it can be the backend through some storage mechanism.</li></ol><p name="9b36" id="9b36" class="graf graf--p graf-after--li">Of course, there are advantages and disadvantages to such a pagination. The advantages are as follows.</p><ol class="postList"><li name="0622" id="0622" class="graf graf--li graf-after--p">It works well when implemented correctly, e.g., on index columns.</li><li name="518f" id="518f" class="graf graf--li graf-after--li">It can run on very large data sets.</li></ol><p name="5e44" id="5e44" class="graf graf--p graf-after--li">But these advantages come at a price.</p><ol class="postList"><li name="1317" id="1317" class="graf graf--li graf-after--p">difficult to implement</li><li name="1f9f" id="1f9f" class="graf graf--li graf-after--li">no way to jump to random pages</li></ol><p name="87f5" id="87f5" class="graf graf--p graf-after--li">I believe the first drawback is easy to understand, after all, it is not a very intuitive approach, the <code class="markup--code markup--p-code">WHERE</code> clause is determined by engineering methods.</p><p name="e4ae" id="e4ae" class="graf graf--p graf-after--p">The second drawback is to jump to a specific page, there must be a correct <code class="markup--code markup--p-code">WHERE</code> clause, but this <code class="markup--code markup--p-code">WHERE</code> clause depends on the last page jump result, whether it is frontend or backend processing. Therefore, users cannot jump pages as they wish.</p><h3 name="1449" id="1449" class="graf graf--h3 graf-after--p">Cursor-based Pagination</h3><p name="7c3d" id="7c3d" class="graf graf--p graf-after--h3">This is an advanced version of keyset pagination, which is actually a special case of cursor-based pagination.</p><p name="50a3" id="50a3" class="graf graf--p graf-after--p">A cursor is an object defined by the engineering side to mark where the pagination starts. There are several common types of cursors.</p><ol class="postList"><li name="c6e1" id="c6e1" class="graf graf--li graf-after--p">Encoded cursor, such as base64. Suppose the cursor is <code class="markup--code markup--li-code">eyJpZCI6IDIwfQ==</code>, then we will find out it is a JSON format string and the specified <code class="markup--code markup--li-code">id</code> is 20.</li><li name="50d5" id="50d5" class="graf graf--li graf-after--li">Token cursor, the backend generates a token for each search result and stores the token, the frontend can use the token to specify the jump page, the backend can know where to start from based on the token.</li></ol><p name="d5ff" id="d5ff" class="graf graf--p graf-after--li">No matter which cursor is used, the backend still uses the keyset pagination mechanism for pagination.</p><p name="3059" id="3059" class="graf graf--p graf-after--p">The advantages and disadvantages of cursor-based pagination are fully inherited from keyset pagination, but cursor has the extra advantage that cursor can store more information, such as session timeout, user privilege, etc.</p><h3 name="a121" id="a121" class="graf graf--h3 graf-after--p">How about ElasticSearch</h3><p name="f3b4" id="f3b4" class="graf graf--p graf-after--h3">The examples above use SQL as an example, but in fact ElasticSearch supports these methods as well.</p><p name="ca5f" id="ca5f" class="graf graf--p graf-after--p">Here is an example of offset pagination.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="ff5a" id="ff5a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">GET /index_name/_search<br />{<br />  <span class="hljs-string">&quot;from&quot;</span>: 20,<br />  <span class="hljs-string">&quot;size&quot;</span>: 10,<br />  <span class="hljs-string">&quot;query&quot;</span>: {<br />    <span class="hljs-string">&quot;match_all&quot;</span>: {}<br />  }<br />}</span></pre><p name="b748" id="b748" class="graf graf--p graf-after--pre">Similar to the principle of SQL, <code class="markup--code markup--p-code">from</code> is used to specify where to start, and <code class="markup--code markup--p-code">size</code> is used to limit the number of records per page. Then, of course, there are also scalability limitations, and moreover, ElasticSearch directly limits the maximum amount of <code class="markup--code markup--p-code">from</code> and <code class="markup--code markup--p-code">size</code> in order to avoid poorly performing queries from affecting the health of the cluster.</p><ul class="postList"><li name="cf74" id="cf74" class="graf graf--li graf-after--p">max_result_window: The maximum amount of data that can be searched at once, the default is 10000. If <code class="markup--code markup--li-code">from + size &gt; 10000</code>, it will directly return an error.</li></ul><p name="70d5" id="70d5" class="graf graf--p graf-after--li">How to solve it? Use the keyword <code class="markup--code markup--p-code">search_after</code> for keyset pagination.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="e33e" id="e33e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">GET index_name/_search<br />{<br />  <span class="hljs-string">&quot;size&quot;</span>: 10,<br />  <span class="hljs-string">&quot;sort&quot;</span>: [<br />    {<br />      <span class="hljs-string">&quot;id&quot;</span>: {<br />        <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span><br />      }<br />    },<br />  ],<br />  <span class="hljs-string">&quot;query&quot;</span>: {<br />    <span class="hljs-string">&quot;match_all&quot;</span>: {}<br />  },<br />  <span class="hljs-string">&quot;search_after&quot;</span>: [<br />    20<br />  ]<br />}</span></pre><p name="d2e3" id="d2e3" class="graf graf--p graf-after--pre">This is a typical implementation of keyset pagination on ElasticSearch.</p><p name="0776" id="0776" class="graf graf--p graf-after--p">So does ElasticSearch have support for cursor-based pagination? Yes, and unlike SQL, you have to implement your own cursor in the application. ElasticSearch already has its own cursor mechanism, called the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/scroll-api.html" data-href="https://www.elastic.co/guide/en/elasticsearch/reference/current/scroll-api.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Scroll API</a>.</p><p name="92be" id="92be" class="graf graf--p graf-after--p">The principle is to create a snapshot of the current query and jump to the next page by calling <code class="markup--code markup--p-code">scroll</code> every time. A practical example would look like the following one.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="4d7f" id="4d7f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">POST index_name/_search?scroll=1m<br />{<br />  <span class="hljs-string">&quot;size&quot;</span>: 10,<br />  <span class="hljs-string">&quot;sort&quot;</span>: [<br />    {<br />      <span class="hljs-string">&quot;id&quot;</span>: {<br />        <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span><br />      }<br />    },<br />  ],<br />  <span class="hljs-string">&quot;query&quot;</span>: {<br />    <span class="hljs-string">&quot;match_all&quot;</span>: {}<br />  }<br />}</span></pre><p name="618c" id="618c" class="graf graf--p graf-after--pre">This will get a response with <code class="markup--code markup--p-code">_scroll_id</code>, and then we can jump to the next page just by using this <code class="markup--code markup--p-code">_scroll_id</code>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="5584" id="5584" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">POST /_search/scroll<br />{<br />  <span class="hljs-string">&quot;scroll&quot;</span>: <span class="hljs-string">&quot;1m&quot;</span>,<br />  <span class="hljs-string">&quot;scroll_id&quot;</span>: <span class="hljs-string">&quot;OXOXQQ==&quot;</span><br />}</span></pre><p name="e354" id="e354" class="graf graf--p graf-after--pre">Since it is a cursor-based pagination, we cannot specify which page we want to jump to, we can only keep going to the next page until there is no result.</p><p name="0c01" id="0c01" class="graf graf--p graf-after--p">Because <code class="markup--code markup--p-code">Scroll API</code> is a snapshot of the current query result, so we must carefully choose the TTL or delete the snapshot after finishing, otherwise it will occupy the hard drive space.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="fa64" id="fa64" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">DELETE /_search/scroll<br />{<br />  <span class="hljs-string">&quot;scroll_id&quot;</span> : <span class="hljs-string">&quot;OXOXQQ==&quot;</span><br />}</span></pre><p name="1bc0" id="1bc0" class="graf graf--p graf-after--pre">In the new version of ElasticSearch, it is no longer recommended to use Scroll API for deep pagination, instead, another new mechanism (released after 7.10), <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/point-in-time-api.html" data-href="https://www.elastic.co/guide/en/elasticsearch/reference/current/point-in-time-api.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">PIT (Point In Time)</a>.</p><p name="cc65" id="cc65" class="graf graf--p graf-after--p">PIT works similarly to Scroll API, but is more flexible and better optimized for performance.</p><p name="3e9d" id="3e9d" class="graf graf--p graf-after--p">Scroll API takes a snapshot of a single query and can only jump pages on that snapshot, but PIT takes a snapshot of the current data set and can do anything after getting the snapshot, not just jump pages.</p><p name="0ccd" id="0ccd" class="graf graf--p graf-after--p">However, this is not related to the pagination, so I will not dive into PIT in this article.</p><h3 name="ec1d" id="ec1d" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="c289" id="c289" class="graf graf--p graf-after--h3">In general, there are two major types of pagination, offset pagination and keyset pagination, and only keyset pagination can run on big data, but if you want to jump pages randomly, only offset pagination can, which is a trade-off.</p><p name="057b" id="057b" class="graf graf--p graf-after--p">In fact, in a big data scenario, if the feature requirements strictly define the maximum number of pages, then even using offset pagination will not affect performance.</p><p name="2c0c" id="2c0c" class="graf graf--p graf-after--p graf--trailing">Therefore, it is not just a technical decision to choose the implementation method, but more often a trade-off in terms of feature requirements. Nevertheless, engineers should know if there is a requirement for random page jumping on big data without page limit, it is time to say no, please clearly reject.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/3ac59656fdd2"><time class="dt-published" datetime="2022-12-19T01:53:08.731Z">December 19, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/explaining-pagination-in-elasticsearch-3ac59656fdd2" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>