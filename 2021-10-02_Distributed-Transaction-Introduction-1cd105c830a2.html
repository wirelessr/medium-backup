<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Distributed Transaction Introduction</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Distributed Transaction Introduction</h1>
</header>
<section data-field="subtitle" class="p-summary">
This article will:
</section>
<section data-field="body" class="e-content">
<section name="1e16" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0403" id="0403" class="graf graf--h3 graf--leading graf--title">Distributed Transaction Introduction</h3><p name="00fd" id="00fd" class="graf graf--p graf-after--h3">This article will:</p><ol class="postList"><li name="a0e3" id="a0e3" class="graf graf--li graf-after--p">explain what is the distributed transaction.</li><li name="40d4" id="40d4" class="graf graf--li graf-after--li">introduce how to resolve the distributed problem.</li><li name="9660" id="9660" class="graf graf--li graf-after--li">provide a real-world example to demonstrate how dose the proper solution look like.</li></ol><p name="bf8a" id="bf8a" class="graf graf--p graf-after--li">To discuss the distributed transaction, we should talk about the transaction first. We will enter the world of the distributed system design step by step. So, let’s begin.</p><h3 name="46cb" id="46cb" class="graf graf--h3 graf-after--p">What is Transaction</h3><p name="4792" id="4792" class="graf graf--p graf-after--h3">The traditional transaction system provide 4 guarantees by the definition. They are known as ACID:</p><ul class="postList"><li name="4f12" id="4f12" class="graf graf--li graf-after--p">Atomicity: All tasks in a transaction either all have been done or done with nothing. In this premise, we can ensure our database modifications will be all or nothing.</li><li name="d826" id="d826" class="graf graf--li graf-after--li">Consistency: The operation in a transaction still follows the constraint. In addition, once it is committed, the changes can be read by others correctly.</li><li name="d774" id="d774" class="graf graf--li graf-after--li">Isolation: The isolation is defined as 4 isolation levels. They are <code class="markup--code markup--li-code">Read Uncommitted</code>, <code class="markup--code markup--li-code">Read Committed</code>, <code class="markup--code markup--li-code">Repeatable Read</code>, and <code class="markup--code markup--li-code">Serializable</code>. Different isolation levels can solve different user scenarios. The <code class="markup--code markup--li-code">Seriablizable</code> treats all operations are in order; therefore, he will not encounter the racing conditions anymore.</li><li name="cd25" id="cd25" class="graf graf--li graf-after--li">Durability: Once the data changes are committed, they will not be lost even the database crashes.</li></ul><h3 name="7094" id="7094" class="graf graf--h3 graf-after--li">Who has Transaction</h3><p name="d5ce" id="d5ce" class="graf graf--p graf-after--h3">After describing ACID briefly, let’s see who can support them. I pick 3 very common targets, <code class="markup--code markup--p-code">MySQL</code>, <code class="markup--code markup--p-code">Mongo</code> and <code class="markup--code markup--p-code">Redis</code>.</p><ul class="postList"><li name="e50f" id="e50f" class="graf graf--li graf-after--p">MySQL: Of course, yes. As a representative of OLTP(Online Transactional Processing), MySQL supports the transaction very well, and it is widely used to the transaction scheme. Although, the transaction level is usually set to <code class="markup--code markup--li-code">Repeatable Read</code>, MySQL is still the most appropriate solution.</li><li name="56b1" id="56b1" class="graf graf--li graf-after--li">Mongo: Since v4.0 released, Mongo has supports the transaction. As long as the correct use <code class="markup--code markup--li-code">Write Concern</code> and <code class="markup--code markup--li-code">Read Concern</code> can ensure <code class="markup--code markup--li-code">Consistency</code> of the transaction. In my opinion, Mongo is very suitable for the de-normalized user scenario.</li><li name="1a09" id="1a09" class="graf graf--li graf-after--li">Redis: Well, not really. We know Redis has the atomical operation due to the single-thread design. In addition, Redis has <code class="markup--code markup--li-code">MULTI</code> to execute multiple commands or <code class="markup--code markup--li-code">EVAL</code> to call the <code class="markup--code markup--li-code">Lua</code> script, so that Redis can perform lots of data changes at once. Moreover, Redis can use AOF to accomplish the data persistence. I have to say that Redis cannot support the transaction. Redis may leverage those mechanisms to solve part of the transaction stories; as a consequence, it does still not fully provide ACID.</li></ul><p name="8e3a" id="8e3a" class="graf graf--p graf-after--li">Let me summarize in a table:</p><figure name="4f4e" id="4f4e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CguLyqdZJ8lNVqmxg-8xdA.png" data-width="341" data-height="153" src="https://cdn-images-1.medium.com/max/800/1*CguLyqdZJ8lNVqmxg-8xdA.png"></figure><h3 name="70bf" id="70bf" class="graf graf--h3 graf-after--figure">How about Distributed Transaction</h3><p name="4920" id="4920" class="graf graf--p graf-after--h3">Alright, we have gone through the traditional transaction. Now, we can talk about the distributed transaction. In order to ease the problem scope, I will give a simple definition to the distributed transaction, that is, provide ACID across multiple homogeneous/heterogeneous data sources. Here are few examples:</p><ol class="postList"><li name="82a6" id="82a6" class="graf graf--li graf-after--p">Insert a row in one MySQL database, and insert another row into another MySQL database.</li><li name="76a3" id="76a3" class="graf graf--li graf-after--li">Insert a row in a MySQL database, and insert a document into a Mongo database.</li><li name="3d88" id="3d88" class="graf graf--li graf-after--li">Insert a document in one of Mongo shards, and insert another document into another Mongo shards.</li></ol><blockquote name="85c6" id="85c6" class="graf graf--blockquote graf-after--li"><em class="markup--em markup--blockquote-em">The third example can be solved by native Mongo’s transaction after Mongo v4.2 released; therefore, we can skip this example.</em></blockquote><h3 name="3916" id="3916" class="graf graf--h3 graf-after--blockquote">Simple Design but Incorrect</h3><p name="450e" id="450e" class="graf graf--p graf-after--h3">Okay, let’s quick look a basic design concept. We perform the transaction on each data source, if there is one of them failed, we rollback the previous tasks.</p><p name="c167" id="c167" class="graf graf--p graf-after--p">Based on our simple design, there is an implementation on data source A, B and C like this:</p><figure name="64d8" id="64d8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dYiSTnbVAO3P8caAVQVf1A.png" data-width="179" data-height="254" src="https://cdn-images-1.medium.com/max/800/1*dYiSTnbVAO3P8caAVQVf1A.png"><figcaption class="imageCaption">figure 1: incorrect design</figcaption></figure><p name="13ef" id="13ef" class="graf graf--p graf-after--figure">The problem here is: after we commit the result to A, we are hard to perform rollback on A if B is failed.</p><p name="106e" id="106e" class="graf graf--p graf-after--p">Even if we adopt the nested transaction, the problem is still not resolved like the following diagram:</p><figure name="882b" id="882b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3ilS7E-5m3G370vJU2V2TA.png" data-width="192" data-height="274" src="https://cdn-images-1.medium.com/max/800/1*3ilS7E-5m3G370vJU2V2TA.png"><figcaption class="imageCaption">figure 2: incorrect too</figcaption></figure><p name="023c" id="023c" class="graf graf--p graf-after--figure">According to the diagram below, we can see the same problem as the figure 1. We cannot rollback on C easily.</p><h3 name="2c48" id="2c48" class="graf graf--h3 graf-after--p">Two-phase Commit Protocol</h3><p name="3dfa" id="3dfa" class="graf graf--p graf-after--h3">In the field of Microservice, this kind of problems are becoming common; hence, many protocols have been proposed to figure out the solution like <code class="markup--code markup--p-code">XA</code> and <code class="markup--code markup--p-code">SAGA</code>. Both <code class="markup--code markup--p-code">XA</code> and <code class="markup--code markup--p-code">SAGA</code> are based on the same theory, <code class="markup--code markup--p-code">2PC</code>, aka the two-phase commit protocol. I won’t dive into <code class="markup--code markup--p-code">2PC</code>, I will provide an introduction to explain its concept.</p><p name="c5de" id="c5de" class="graf graf--p graf-after--p">There is a coordinator in the story, everyone want to perform the distributed transaction has to register(first commit) with it. The coordinator will poll every data source who participates in this transaction to get the permission. If there is any participant says no, the coordinator will reject the transaction request and perform rollback to every participant. If fortunately all data sources reply yes, the coordinator will response okay to the client. The client is able to perform the real commit(second commit) to the coordinator to proceed the process.</p><figure name="8d6b" id="8d6b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZsbogH53HuWUItiktCP1fA.png" data-width="272" data-height="370" src="https://cdn-images-1.medium.com/max/800/1*ZsbogH53HuWUItiktCP1fA.png"></figure><p name="c2a4" id="c2a4" class="graf graf--p graf-after--figure">See this, we can find out three problems:</p><ol class="postList"><li name="a642" id="a642" class="graf graf--li graf-after--p">It is very time consuming. Client must wait for every data source agree his request, and then submit the real commit to them. Although this synchronization can ensure the strong consistency on data changes, we have to invest more time.</li><li name="7434" id="7434" class="graf graf--li graf-after--li">SPOF(Single point of failure) is on the coordinator. If the coordinator crashes, all the distributed transactions do not work anymore.</li><li name="2df5" id="2df5" class="graf graf--li graf-after--li">If the coordinator’s commit is failed due to the network loss or other reasons, the data will be inconsistent on those participated data sources.</li></ol><h3 name="653e" id="653e" class="graf graf--h3 graf-after--li">Eventually Consistency</h3><p name="0910" id="0910" class="graf graf--p graf-after--h3">It seems that multi-phase commit protocol is not feasible, we should try to find out a light weight approach called eventually consistency. Literally we know that we give up the strong consistency to reduce the implementation overhead. In other words, we hope the data can be consistent in the end. To achieve the eventually consistency approach, there are two keywords should keep in mind.</p><ol class="postList"><li name="cb39" id="cb39" class="graf graf--li graf-after--p">Event sourcing: To make this term simple, it means we record the status changes instead of the status itself. For instance, the bank passbook records every transaction not only the balance.</li><li name="b9a9" id="b9a9" class="graf graf--li graf-after--li">Idempotence: The idempotence is quite intuitive. We can perform a tasks many times, and the result is the same as we performed once.</li></ol><p name="2eb1" id="2eb1" class="graf graf--p graf-after--li">Combine these two concepts, we can design our system now. We make every transaction be an event, if a client want to perform a distributed transaction which means the client emit an event to the event processor. The event processor receives a event and start to do transaction on those multiple data sources. After all tasks finish, the event can be mark as <code class="markup--code markup--p-code">DONE</code>, and the event processor can handle the next one. If there is a transaction cannot succeed on one of the data sources, we don’t mark this event <code class="markup--code markup--p-code">DONE</code>, so that the event processor will retry later. Due to the idempotence, the event can be processed more than once. Nevertheless, putting a retry limit is recommended.</p><p name="664a" id="664a" class="graf graf--p graf-after--p">Let’s see the diagram to show the design flow:</p><figure name="b9b2" id="b9b2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*X--IGPY5ARQRsOG9oTwu3A.png" data-width="331" data-height="531" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*X--IGPY5ARQRsOG9oTwu3A.png"></figure><p name="ef3b" id="ef3b" class="graf graf--p graf-after--figure">Perfect, as a result of the design concept, we can handle the distributed transaction correctly, and the data consistency will be kept eventually.</p><p name="ea14" id="ea14" class="graf graf--p graf-after--p graf--trailing">Even though there is a queue in our design, in fact, you don’t need invoke a real queue in your system. There are many alternatives, e.g., store all events in a MySQL table having a column be the status. The core of this design is the event sourcing and the idempotence, you can accomplish them in what way you preferred.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/1cd105c830a2"><time class="dt-published" datetime="2021-10-02T03:37:42.309Z">October 2, 2021</time></a>.</p><p><a href="https://medium.com/@lazypro/distributed-transaction-introduction-1cd105c830a2" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>