<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Original Sin of Microservices, Part 1</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Original Sin of Microservices, Part 1</h1>
</header>
<section data-field="subtitle" class="p-summary">
8 fallacies of distributed computing.
</section>
<section data-field="body" class="e-content">
<section name="3535" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="f0f8" id="f0f8" class="graf graf--h3 graf--leading graf--title">Original Sin of Microservices, Part 1</h3><ul class="postList"><li name="91e8" id="91e8" class="graf graf--li graf-after--h3">Part 1, 8 fallacies of distributed computing</li><li name="97e3" id="97e3" class="graf graf--li graf-after--li"><a href="https://lazypro.medium.com/original-sin-of-microservices-part-2-8856c0e8426d" data-href="https://lazypro.medium.com/original-sin-of-microservices-part-2-8856c0e8426d" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Part 2, 9 challenges of distributed architecture</a></li></ul><p name="d8d8" id="d8d8" class="graf graf--p graf-after--li">This series of articles is a summary of <code class="markup--code markup--p-code">Worldwide Software Architecture Summit&#39;22</code>, thus most of the contents are coming from the seminar. Of course, there are also some insights from my understanding.</p><p name="59cb" id="59cb" class="graf graf--p graf-after--p">Microservice architecture had been a popular topic for several years, and there were various sessions to talk about how to deploy, manage and implement microservices at every seminar about software architecture. However, such a trend in the last six months to a year of time sharply frozen, more and more people noticed that although microservices is a good approach, but not a total solution.</p><p name="8517" id="8517" class="graf graf--p graf-after--p">It is beneficial to use microservices, but it also comes at a cost, such as complexity.</p><h3 name="d03d" id="d03d" class="graf graf--h3 graf-after--p">What’s the ideal microservice?</h3><p name="b336" id="b336" class="graf graf--p graf-after--h3">Before talking about the original sin of microservices, let’s define what the ideal microservice would look like.</p><p name="6794" id="6794" class="graf graf--p graf-after--p">Ideally,</p><ul class="postList"><li name="7c21" id="7c21" class="graf graf--li graf-after--p">Non-shared code</li><li name="ede8" id="ede8" class="graf graf--li graf-after--li">Non-shared data</li><li name="cb26" id="cb26" class="graf graf--li graf-after--li">With bounded context in a specific domain</li><li name="d152" id="d152" class="graf graf--li graf-after--li">Deployment separately</li><li name="39ec" id="39ec" class="graf graf--li graf-after--li">Single responsibility principle</li></ul><p name="11c6" id="11c6" class="graf graf--p graf-after--li">It may look like as follows in an architecture diagram.</p><figure name="517e" id="517e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*E-YJ9HTcDZSOcN_eg7E-Gw.png" data-width="788" data-height="726" src="https://cdn-images-1.medium.com/max/800/1*E-YJ9HTcDZSOcN_eg7E-Gw.png"><figcaption class="imageCaption">Ideal microservice architecture</figcaption></figure><p name="47fb" id="47fb" class="graf graf--p graf-after--figure">When clients communicate with backend services, backend usually routes the request to the corresponding microservice through a <code class="markup--code markup--p-code">API gateway</code>. And, this microservice is able to process this request correctly by its own data and response to the clients.</p><h3 name="61f4" id="61f4" class="graf graf--h3 graf-after--p">What’s the real world?</h3><p name="d459" id="d459" class="graf graf--p graf-after--h3">But the real world is often not as rosy as we think.</p><figure name="b679" id="b679" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*opqk8tbPJg1HfF1s.jpg" data-width="2500" data-height="1666" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*opqk8tbPJg1HfF1s.jpg"></figure><p name="b15a" id="b15a" class="graf graf--p graf-after--figure">Do you know what kind of animal this is?</p><p name="317d" id="317d" class="graf graf--p graf-after--p">As far as I know, there are at least three possibilities, which could be a horse, a donkey or a mule.</p><p name="aa10" id="aa10" class="graf graf--p graf-after--p">Why is it painted like this?</p><p name="79d1" id="79d1" class="graf graf--p graf-after--p">At first, we designed the whole architecture according to our ideal or textbook style and started to implement it, and everything looked so perfect. But as time went on, more and more requirements were added and we were forced to make it work in a limited time frame, even if there were mistakes to be fixed. In the end, the horse-like animal became more and more sketchy.</p><p name="f459" id="f459" class="graf graf--p graf-after--p">If there was a good design and planning, we can at least tell from the back half that it might have been a horse. On the other hand, if there was no design at all, no one would probably know what you were trying to draw.</p><p name="891f" id="891f" class="graf graf--p graf-after--p">If we represent it in an architecture diagram, it would probably look something like this. Welcome to the real world.</p><figure name="0055" id="0055" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qCGHy6219nV_w97fzztK7g.png" data-width="454" data-height="888" src="https://cdn-images-1.medium.com/max/800/1*qCGHy6219nV_w97fzztK7g.png"><figcaption class="imageCaption">Real-world microservice architecture</figcaption></figure><p name="d201" id="d201" class="graf graf--p graf-after--figure">A, B and C all have their own responsibility to handle their own bounded context, but as the requirement grows, A finds that it needs B’s data, and B needs C’s cooperation, and even C has to call A. Finally, it becomes a big ball of mud.</p><p name="e622" id="e622" class="graf graf--p graf-after--p">There are several reasons.</p><ol class="postList"><li name="6304" id="6304" class="graf graf--li graf-after--p">Usually, there are no architects. So there is no way to evolve the system correctly with each requirement.</li><li name="ecbd" id="ecbd" class="graf graf--li graf-after--li">Even because there was no architect, architecture is not clearly defined.</li><li name="5c9a" id="5c9a" class="graf graf--li graf-after--li">Focus on fast delivery of features, and ignore non-functional requirements.</li><li name="599d" id="599d" class="graf graf--li graf-after--li">Feedback cycle is very short, and we must respond to requests or incidents within a short period of time.</li><li name="9753" id="9753" class="graf graf--li graf-after--li">It’s all online and real-time without any downtime until the requirements are eliminated.</li></ol><h3 name="e34f" id="e34f" class="graf graf--h3 graf-after--li">8 fallacies of distributed computing</h3><p name="74c9" id="74c9" class="graf graf--p graf-after--h3">After understanding why systems, in reality, are the way they are, let’s look at 8 fallacies of distributed computing. These are the most commonly overlooked pitfalls of microservice architecture.</p><h3 name="b898" id="b898" class="graf graf--h3 graf-after--p">The network is reliable</h3><p name="c109" id="c109" class="graf graf--p graf-after--h3">People wishfully assume that the network between two endpoints is reliable. But the truth is that packets may drop and connections may be broken. Therefore, there should be a retry mechanism between the two endpoints to improve the reliability as much as possible.</p><h3 name="40e3" id="40e3" class="graf graf--h3 graf-after--p">Latency is zero</h3><p name="e380" id="e380" class="graf graf--p graf-after--h3">There is an unconscious belief that the latency between two endpoints is zero, and this leads to many simple functions being spread out to other endpoints. Unfortunately, the latency between any endpoints is never zero, even on an intranet. So when making remote calls, it is always important to consider setting a timeout, even for connections to internal databases.</p><p name="9ada" id="9ada" class="graf graf--p graf-after--p">In addition, when frequent operations are required on Redis, mechanisms such as Redis pipeline are always used to reduce the round trip time (RTT) between endpoints.</p><h3 name="e081" id="e081" class="graf graf--h3 graf-after--p">Bandwidth is infinite</h3><p name="518c" id="518c" class="graf graf--p graf-after--h3">People usually feel that the network bandwidth between two endpoints is unlimited, so there is no restraint when transferring data. In fact, the bandwidth is much smaller than you think.</p><p name="a3cc" id="a3cc" class="graf graf--p graf-after--p">In particular, if you use MySQL’s <code class="markup--code markup--p-code">select *</code> often, you may run out of bandwidth without realizing it. As a MySQL table grows with requirements, there may be many more costs you don’t realize, such as BLOB or TEXT, and such data structures often store huge amounts of data to further consume bandwidth.</p><h3 name="455d" id="455d" class="graf graf--h3 graf-after--p">The network is secure</h3><p name="0693" id="0693" class="graf graf--p graf-after--h3">This is a very common pitfall, people always believe that the intranet is secure. But this is absolutely unrealistic, and this is why the concept of zero trust has been proposed in recent years.</p><h3 name="bb4b" id="bb4b" class="graf graf--h3 graf-after--p">Topology doesn’t change</h3><p name="1b44" id="1b44" class="graf graf--p graf-after--h3">This fallacy is a bit interesting. People feel that the topology of a network does not change, meaning that the two endpoints are always written to each other’s location, whether it is FQDN or IP, but in reality, network topology changes for many reasons, such as VPC segmentation, public cloud migration, and even system evolution.</p><h3 name="b4cb" id="b4cb" class="graf graf--h3 graf-after--p">There is one administrator</h3><p name="1698" id="1698" class="graf graf--p graf-after--h3">You would expect that there would be at least one administrator maintaining each service, right? Usually, in every organization, there is an operation role that is responsible for maintaining the system. Therefore, operation plays the role of an administrator, and if there is a problem with the system, operation is definitely the first to know.</p><p name="1930" id="1930" class="graf graf--p graf-after--p">Wrong, absolutely wrong.</p><p name="217a" id="217a" class="graf graf--p graf-after--p">Any system must implement its own observability, and system developers must have the ability to identify potential problems from these observabilities. There are four most common types of observability.</p><ol class="postList"><li name="bfe0" id="bfe0" class="graf graf--li graf-after--p">Logging: The logs left by system execution are usually related to system behavior.</li><li name="710c" id="710c" class="graf graf--li graf-after--li">Tracing: The execution cycle of a task. If it is a distributed system, you must be able to track the telemetries on each system, e.g., jaeger or OpenTracing.</li><li name="59e9" id="59e9" class="graf graf--li graf-after--li">Metrics: The measurable status left by the system run, such as the number of API executions, the number of failures, etc.</li><li name="1c2e" id="1c2e" class="graf graf--li graf-after--li">Profiling: Resource consumption behind the system like CPU and memory, etc.</li></ol><h3 name="2aa9" id="2aa9" class="graf graf--h3 graf-after--li">Transport cost is zero</h3><p name="9084" id="9084" class="graf graf--p graf-after--h3">This is absolutely the most serious fallacy. You have to understand that any remote call has a cost, especially on a public cloud, which is even more pricey. Even if it’s a database access or an outbound HTTP call, these all cost money.</p><p name="857e" id="857e" class="graf graf--p graf-after--p">So, no matter what the remote call is, it must always be optimized, both in terms of frequency and data size.</p><h3 name="877f" id="877f" class="graf graf--h3 graf-after--p">The network is homogeneous</h3><p name="7d41" id="7d41" class="graf graf--p graf-after--h3">This is an easy pitfall to overlook. The network is absolutely heterogeneous, so when one endpoint calls another endpoint in series, you cannot guarantee that the order of arrival is the same as the order you sent it. In other words, any assumptions about order should not exist.</p><h3 name="0ca6" id="0ca6" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="c876" id="c876" class="graf graf--p graf-after--h3">Alright, after this discussion, I believe we can all agree that distributed systems are really complex. There are so many factors that must be considered for just two endpoints, not to mention microservices.</p><p name="f5a2" id="f5a2" class="graf graf--p graf-after--p">Microservices are composed of countless endpoints, and each endpoint has to consider just those factors, and at the same time, microservice architectures have their own issues to face, such as data consistency, system scalability, and so on.</p><p name="08ec" id="08ec" class="graf graf--p graf-after--p graf--trailing">Since this article is already a bit overloaded, I will schedule the challenges of microservices for the next article. In that time, we will discuss how difficult it is to design a microservice correctly, and we will also recognize why the recent seminars are emphasizing the shortcomings of microservices.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/90461ddcefb"><time class="dt-published" datetime="2022-03-21T00:51:37.786Z">March 21, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/original-sin-of-microservices-part-1-90461ddcefb" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>