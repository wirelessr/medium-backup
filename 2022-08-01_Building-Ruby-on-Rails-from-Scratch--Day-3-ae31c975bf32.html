<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Building Ruby on Rails from Scratch, Day 3</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Building Ruby on Rails from Scratch, Day 3</h1>
</header>
<section data-field="subtitle" class="p-summary">
Pros and Cons of Rails
</section>
<section data-field="body" class="e-content">
<section name="f829" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3ae0" id="3ae0" class="graf graf--h3 graf--leading graf--title">Building Ruby on Rails from Scratch, Day 3</h3><h4 name="31cf" id="31cf" class="graf graf--h4 graf-after--h3 graf--subtitle">Pros and Cons of Rails</h4><figure name="5c13" id="5c13" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*i2LpIPr9CdH4ax-V.png" data-width="500" data-height="700" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*i2LpIPr9CdH4ax-V.png"><figcaption class="imageCaption"><a href="https://dev.to/rly" data-href="https://dev.to/rly" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://dev.to/rly</a></figcaption></figure><ul class="postList"><li name="3f2c" id="3f2c" class="graf graf--li graf-after--figure">Day 1: <a href="https://lazypro.medium.com/building-ruby-on-rails-from-scratch-b855584ff4f8" data-href="https://lazypro.medium.com/building-ruby-on-rails-from-scratch-b855584ff4f8" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">From Nothing to Something</a></li><li name="a6ba" id="a6ba" class="graf graf--li graf-after--li">Day 2: <a href="https://lazypro.medium.com/building-ruby-on-rails-from-scratch-day-2-d609fce59811" data-href="https://lazypro.medium.com/building-ruby-on-rails-from-scratch-day-2-d609fce59811" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">More Things about Relations, Tests, etc.</a></li><li name="aa9f" id="aa9f" class="graf graf--li graf-after--li">Day 3: My Thoughts on Ruby</li></ul><p name="ce08" id="ce08" class="graf graf--p graf-after--li">This is the last article in this series. Instead of building an application from scratch, in this article I’d like to talk about some of my thoughts on Ruby on Rails over the past few weeks.</p><p name="4c52" id="4c52" class="graf graf--p graf-after--p">First, I’ll start with a brief ranking of the programming languages I’ve experienced on multiple aspects, including <em class="markup--em markup--p-em">C++</em>, Python, Node, Golang, and Rails, and since I haven’t worked with Java or <em class="markup--em markup--p-em">.NET Core</em>, perhaps you can consider <em class="markup--em markup--p-em">C++</em> as an alternative.</p><p name="5ca8" id="5ca8" class="graf graf--p graf-after--p">These language comparisons are mainly qualitative rather than quantitative. After all, I don’t really measure anything, it’s mostly “how I feel”.</p><p name="63c7" id="63c7" class="graf graf--p graf-after--p">Next, I’ll describe the benefits I’ve experienced in Rails. I’ll give a reasonable rating for both extensibility and ease of use.</p><p name="6960" id="6960" class="graf graf--p graf-after--p">Finally, of course, there will be the shortcomings that I feel.</p><p name="8f4c" id="8f4c" class="graf graf--p graf-after--p">But what I feel is not the same as what you feel is a pain point. The size of the application, the amount of organizational resources, and other factors can affect how you feel. So I’m only commenting on Rails based on my own experience and understanding of the evolution of the system.</p><h3 name="79c3" id="79c3" class="graf graf--h3 graf-after--p">Ranking</h3><p name="5729" id="5729" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Performance</em></strong></p><p name="ba14" id="ba14" class="graf graf--p graf-after--p">First, let’s compare performance. As I said earlier, I didn’t do any measurements, I simply did some comparisons based on the nature of the language and my feelings.</p><blockquote name="4165" id="4165" class="graf graf--blockquote graf-after--p"><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">C++</em></code><em class="markup--em markup--blockquote-em"> &gt; Golang &gt; Node &gt; Python = Rails</em></blockquote><p name="64b1" id="64b1" class="graf graf--p graf-after--blockquote">Ruby and Python are the slowest, I believe, no doubt, because of GIL, which makes these two languages less efficient. I want to emphasize that Python here means CPython, and in fact, GIL-removed implementations like <code class="markup--code markup--p-code">pypy</code> or <code class="markup--code markup--p-code">IronPython</code> perform very well.</p><p name="3a4c" id="3a4c" class="graf graf--p graf-after--p">Although Node does not have GIL implementation and is event-driven by nature, Node can still only execute all events through a single process, which is still a gap compared to Golang’s <code class="markup--code markup--p-code">goroutine</code>. <code class="markup--code markup--p-code">C++</code> has a natural advantage due to its closer implementation to the kernel.</p><p name="4c71" id="4c71" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Portability</em></strong></p><p name="b57e" id="b57e" class="graf graf--p graf-after--p">The portability here is not about cross-platform porting, after all, these languages are cross-platform, and <code class="markup--code markup--p-code">C++</code> can also be cross-platform as long as it has a corresponding toolchain.</p><p name="4eed" id="4eed" class="graf graf--p graf-after--p">So what is the comparison here? I think we can compete in terms of how easy it is to run an application. For example, Python requires the installation of an interpreter, not to mention the dependency on packages like <code class="markup--code markup--p-code">pip install</code>, and the same applies to Node. But Rails, in addition to Ruby itself, sometimes even Node is part of the dependency, and that’s where it loses out.</p><p name="0e2d" id="0e2d" class="graf graf--p graf-after--p">Therefore,</p><blockquote name="0fc5" id="0fc5" class="graf graf--blockquote graf-after--p"><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">C++</em></code><em class="markup--em markup--blockquote-em"> &gt; Golang &gt; Node = Python &gt; Rails</em></blockquote><p name="a178" id="a178" class="graf graf--p graf-after--blockquote">In addition to judging by the number of package dependencies, we can also compare the container image sizes created with best practices, and the results are the same.</p><p name="ad11" id="ad11" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Ease of coding</em></strong></p><p name="624b" id="624b" class="graf graf--p graf-after--p">The first two comparisons I feel there should be no debate about the results, not much difference with the facts, but the next one is more subjective, the ease of coding.</p><blockquote name="d4bb" id="d4bb" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Python = Rails &gt; Node &gt; Golang &gt; </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">C++</em></code></blockquote><p name="04c7" id="04c7" class="graf graf--p graf-after--blockquote">First of all, I am a fan of weak typed languages, so Golang and <code class="markup--code markup--p-code">C++</code> must be at the bottom of the list. Golang is a bit easier than <code class="markup--code markup--p-code">C++</code>, with fewer keywords.</p><p name="c7b3" id="c7b3" class="graf graf--p graf-after--p">Although Node is a weak typed language, its event-driven nature makes it a bit difficult for people who are new to it to understand when to <code class="markup--code markup--p-code">async/await</code> and when to synchronize, which takes time to get used to. In addition, Node has a lot of difficulties with object-oriented implementation, and honestly, Node is not easy to get objects right.</p><p name="5aea" id="5aea" class="graf graf--p graf-after--p">As for Python and Rails, they are really easy to code, with a procedural language base and rich syntactic sugar that makes everything possible. If I had to decide between the two, I’d probably vote for Python!</p><p name="cd39" id="cd39" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Extensibility (including packages and ecosystems)</em></strong></p><p name="fb54" id="fb54" class="graf graf--p graf-after--p">Excluding <code class="markup--code markup--p-code">C++</code>, all the other languages have relatively good package management tools, and all have active ecosystems, so it’s a little hard to tell the difference.</p><p name="11b0" id="11b0" class="graf graf--p graf-after--p">But if I have to say so, Python can do a little more than the other languages, so Python is in the front of my list.</p><blockquote name="3d7d" id="3d7d" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Python &gt; Rails = Node = Golang &gt; </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">C++</em></code></blockquote><h3 name="ab8e" id="ab8e" class="graf graf--h3 graf-after--blockquote">Benefits of Rails</h3><p name="77d6" id="77d6" class="graf graf--p graf-after--h3">The above comparison is mostly based on my experience, which may not be the same as yours, but in general Rails is still outstanding.</p><p name="0ed4" id="0ed4" class="graf graf--p graf-after--p">In particular, as you can see from the descriptions in my first two articles, it can be really fast to build an application with Rails.</p><p name="176e" id="176e" class="graf graf--p graf-after--p">Especially since Rails provides excellent <em class="markup--em markup--p-em">ERb templates</em> that make frontend pages easy to develop, and there are many helpers in Rails that integrate well with the frontend to make things even easier.</p><p name="0a90" id="0a90" class="graf graf--p graf-after--p">Furthermore, one of the most amazing features of Rails is the <code class="markup--code markup--p-code">ActiveRecord</code> and resource-based routing paradigms that are developed in accordance with the <em class="markup--em markup--p-em">Active Record Pattern</em> mentioned in <em class="markup--em markup--p-em">Patterns of Enterprise Application Architecture</em>, which shows the author’s ingenuity.</p><p name="2f48" id="2f48" class="graf graf--p graf-after--p">In Rails, you don’t need to care about the database underlying the <code class="markup--code markup--p-code">ActiveRecord</code>. The application is basically written the same way, whether it’s MySQL or MongoDB. More importantly, <code class="markup--code markup--p-code">ActiveRecord</code> can also automatically generate schema for database migration, both in whole and in part, and it can be both up and down, which is really convenient.</p><p name="4390" id="4390" class="graf graf--p graf-after--p">Even when we were developing Node, we used Rails to create the schema for the database migration.</p><p name="ec1b" id="ec1b" class="graf graf--p graf-after--p">Finally, Rails has a lot of built-in features that are necessary for the backend development, such as caching through <code class="markup--code markup--p-code">CacheStore</code>, messaging through <code class="markup--code markup--p-code">ActiveMailer</code>, and job scheduling through <code class="markup--code markup--p-code">ActiveJob</code>. Basically, all the tools for backend development are available, and the underlying infrastructure can be modified with a simple setup, without the need to modify the application.</p><p name="feb9" id="feb9" class="graf graf--p graf-after--p">All of these advantages make Rails the best candidate for a fast development and quick launch.</p><h3 name="cbc8" id="cbc8" class="graf graf--h3 graf-after--p">Shortcomings of Rails</h3><p name="4928" id="4928" class="graf graf--p graf-after--h3">Nevertheless, Rails has some shortcomings.</p><p name="3ebb" id="3ebb" class="graf graf--p graf-after--p">First, due to the resource-based routing design, all domain knowledge is built around resources. This may not be a problem in a small to medium-sized application, but when the application becomes large, the resource-to-resource constraints increase significantly and resource-based routing is obviously not sufficient.</p><p name="9f2c" id="9f2c" class="graf graf--p graf-after--p">Let me use the most common e-commerce website as an example.</p><p name="46d8" id="46d8" class="graf graf--p graf-after--p">Suppose there are three resources, order, payment, and transaction history. A typical Rails routing design would generate three routes, all with CRUD capabilities.</p><blockquote name="cd77" id="cd77" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">/api/orders/{oid}<br>/api/payments/{pid}<br>/api/transactions/{tid}</em></blockquote><p name="c16f" id="c16f" class="graf graf--p graf-after--blockquote">When a user places an order, the operation is performed through <code class="markup--code markup--p-code">/api/orders/{oid}</code>, either to update the status or to get the status. The user then proceeds to make a payment, so a transaction is created and managed through <code class="markup--code markup--p-code">/api/transactions/{tid}</code>. But at the same time, the status of the order will need to be changed to in progress, and a payment will need to be inserted but indicated as unconfirmed.</p><p name="97ac" id="97ac" class="graf graf--p graf-after--p">Based on the above description, we need three API calls.</p><blockquote name="92f6" id="92f6" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">POST /api/transactions<br>PUT /api/orders/{oid}<br>POST /api/payments</em></blockquote><p name="664b" id="664b" class="graf graf--p graf-after--blockquote">Question, how do we ensure that all API calls are correct in such a situation? This is a typical distributed transaction, and I have already written several articles on the difficulties of distributed transactions.</p><ul class="postList"><li name="351b" id="351b" class="graf graf--li graf-after--p"><a href="https://medium.com/interviewnoodle/distributed-transaction-introduction-1cd105c830a2" data-href="https://medium.com/interviewnoodle/distributed-transaction-introduction-1cd105c830a2" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Distributed Transaction Introduction</a></li><li name="63d6" id="63d6" class="graf graf--li graf-after--li"><a href="https://betterprogramming.pub/design-distributed-transaction-with-practical-examples-7b1d93fddb63" data-href="https://betterprogramming.pub/design-distributed-transaction-with-practical-examples-7b1d93fddb63" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Design Distributed Transaction With Practical Examples</a></li></ul><p name="8cb2" id="8cb2" class="graf graf--p graf-after--li">As resource-to-resource connectivity grows with the complexity of the domain, it becomes obvious that Rails’ most classic routing design is overburdened. In addition, all the domain knowledge is fragmented by the resources, which is a common problem in system design, the anemic model.</p><p name="eaff" id="eaff" class="graf graf--p graf-after--p">Moreover, when actually doing a code review, I found that Rails was not as readable as I expected. Even though it’s a resource-based routing design, I often couldn’t find a specific route, especially in a <code class="markup--code markup--p-code">config/routes.rb</code> with thousands of lines. I was always confused by the various combinations of <code class="markup--code markup--p-code">concern</code>, <code class="markup--code markup--p-code">resource</code> and <code class="markup--code markup--p-code">namespace</code>.</p><p name="d593" id="d593" class="graf graf--p graf-after--p">In addition to not finding routes, method calls are often not found. Because a class can get the ability of other modules by <code class="markup--code markup--p-code">include</code>, but this <code class="markup--code markup--p-code">include</code> doesn’t require any “declaration” at all. Here the declaration refers to <code class="markup--code markup--p-code">from x import y</code> in Python or <code class="markup--code markup--p-code">import { y } from x</code> in Node, but in Rails there is no need, you can just <code class="markup--code markup--p-code">include y</code>.</p><p name="6a4f" id="6a4f" class="graf graf--p graf-after--p">So when a method is used in a class, I have to look through <code class="markup--code markup--p-code">include</code>, <code class="markup--code markup--p-code">extend</code> and <code class="markup--code markup--p-code">pretend</code>, and again, when the application is huge, this process really kills me. When there are methods with the same name, it can be several times worse.</p><p name="ee07" id="ee07" class="graf graf--p graf-after--p">One more point is that Rails wraps a lot of implementation behind a layer of objects, making the whole thing feel like a black box. Without a clear understanding of the underlying implementation, it’s easy to code something that seems to work, but actually performs horribly, like <em class="markup--em markup--p-em">N + 1 queries</em>.</p><p name="104b" id="104b" class="graf graf--p graf-after--p">If it is a simple object this can save a lot of implementation efforts, such as <code class="markup--code markup--p-code">CacheStore</code>.</p><p name="6bcd" id="6bcd" class="graf graf--p graf-after--p">I like Rails’ <code class="markup--code markup--p-code">CacheStore</code>, because it provides a lot of common functionality for caching. But when it comes to <code class="markup--code markup--p-code">ActiveRecord</code>, I honestly don’t have confidence that it will work very well. I’d rather write my own database queries, at least I can be sure that the performance of the queries will be good enough.</p><h3 name="5d7a" id="5d7a" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="697a" id="697a" class="graf graf--p graf-after--h3">Although Rails can quickly generate an application skeleton through <code class="markup--code markup--p-code">scaffold</code>, it is very adaptable to fast launch requirements. But I have to say that this advantage can be replaced very easily, especially nowadays when the ecosystems of various languages are so well organized that it is not difficult to do so.</p><p name="93f4" id="93f4" class="graf graf--p graf-after--p">In the case of Node, there are now many MERN generators that can do similar or even better things.</p><p name="d279" id="d279" class="graf graf--p graf-after--p">For example,</p><blockquote name="2b5f" id="2b5f" class="graf graf--blockquote graf-after--p"><a href="https://docs.dhiwise.com/knowledgehub/build-node.js-app/Build-app" data-href="https://docs.dhiwise.com/knowledgehub/build-node.js-app/Build-app" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank"><em class="markup--em markup--blockquote-em">https://docs.dhiwise.com/knowledgehub/build-node.js-app/Build-app</em></a></blockquote><p name="e617" id="e617" class="graf graf--p graf-after--blockquote">An e-commerce site can be built at a mouse click and is production ready. So there are few advantages left in Rails, and the design of <code class="markup--code markup--p-code">ActiveRecord</code>, as mentioned in the previous section, is not an advantage but a disadvantage when the application becomes large.</p><p name="d93c" id="d93c" class="graf graf--p graf-after--p">Even so, I would rate <code class="markup--code markup--p-code">ActiveRecord</code> very highly. For those who want to move from procedural languages into the object-oriented world, the design offers plenty of perspective, and once you get used to <code class="markup--code markup--p-code">ActiveRecord</code>, I believe that anyone can build elegant objects.</p><p name="83e0" id="83e0" class="graf graf--p graf-after--p">Besides, I personally like the design of the <code class="markup--code markup--p-code">CacheStore</code>. In addition to the built-in expiration mechanism <code class="markup--code markup--p-code">:expires_in</code>, there is also the elegant <code class="markup--code markup--p-code">:race_condition_ttl</code> to avoid <em class="markup--em markup--p-em">Dog-pile Effect</em>, which is definitely a benefit for people who used to build their own wheels. But I haven’t been in Rails long enough to study what the underlying implementation is, so I’ll leave that for later.</p><p name="161c" id="161c" class="graf graf--p graf-after--p">Overall, I feel that Rails is amazing, has a lot of design wisdom in it, and is very classic.</p><p name="931d" id="931d" class="graf graf--p graf-after--p">But maybe Rails was originally intended for people who wanted to build applications quickly, and when applications became large, most of the original design became useless and ineffective. This takes us back to the basics of Ruby as a language. For Ruby, the ecosystem is complete and the syntax is flexible enough to build large applications.</p><p name="fdab" id="fdab" class="graf graf--p graf-after--p">But if Rails has to rely on Ruby in the end, why don’t I just use Python? The ecosystem is more complete and the syntax is more flexible.</p><p name="f2d1" id="f2d1" class="graf graf--p graf-after--p graf--trailing">Anyway, these are my thoughts on Ruby on Rails, and my next goal is to decompose these legacy large Rails applications into microservices. The next article will introduce the classic approach to decompose microservices.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/ae31c975bf32"><time class="dt-published" datetime="2022-08-01T01:46:17.272Z">August 1, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/building-ruby-on-rails-from-scratch-day-3-ae31c975bf32" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>