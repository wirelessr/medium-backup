<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Don’t be Afraid of MongoDB Cross-shard Queries</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Don’t be Afraid of MongoDB Cross-shard Queries</h1>
</header>
<section data-field="subtitle" class="p-summary">
Empower Sharding Strategy to Handle Cross-Shard Queries with Confidence
</section>
<section data-field="body" class="e-content">
<section name="d1eb" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4e3a" id="4e3a" class="graf graf--h3 graf--leading graf--title">Don’t be Afraid of MongoDB Cross-shard Queries</h3><h4 name="c90f" id="c90f" class="graf graf--h4 graf-after--h3 graf--subtitle">Empower Sharding Strategy to Handle Cross-Shard Queries with Confidence</h4><figure name="feb7" id="feb7" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*QoHaVDd5TEP3YrNY" data-width="1000" data-height="667" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*QoHaVDd5TEP3YrNY"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@eric_sun" data-href="https://unsplash.com/@eric_sun" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Hanlin Sun</a> on <a href="https://unsplash.com/photos/dF3kGsbJJgE" data-href="https://unsplash.com/photos/dF3kGsbJJgE" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="ed44" id="ed44" class="graf graf--p graf-after--figure">Before discussing sharding, let’s first talk about scaling. We all know that there are two types of scaling, one is vertical scaling, also known as scale-up, and the other is horizontal scaling, aka scale-out.</p><p name="c578" id="c578" class="graf graf--p graf-after--p">As for scaling, there are different ways for different purposes. For MongoDB, if we want to improve query performance, then vertical scaling is to improve the machine specs, while horizontal scaling is to increase the number of replicas so that the query can be executed on the idle replicas.</p><p name="66af" id="66af" class="graf graf--p graf-after--p">On the other hand, to increase the amount of data stored, for MongoDB, vertical scaling is still about improving the specs of the machine (in this case, the size of the hard drives), while horizontal scaling is about sharding, which is the main topic of this article.</p><p name="e748" id="e748" class="graf graf--p graf-after--p">Therefore, we have to understand that the purpose of sharding is to make the data evenly distributed so that MongoDB can store more data, not to improve the query performance. In other words, query performance will be improved by sharding as an extra, but not the main purpose.</p><h3 name="495a" id="495a" class="graf graf--h3 graf-after--p">Why specifically mention cross-shard queries in the title?</h3><p name="b5e3" id="b5e3" class="graf graf--p graf-after--h3">When we consider doing sharding, we will always consider carefully how to choose the shard key, choose the shard key and worry it will affect the production of the query performance, and consider rewrite all the query drastically. These concerns are actually unnecessary.</p><p name="3976" id="3976" class="graf graf--p graf-after--p">Let me conclude that if migrating to a sharded cluster from no sharding, as long as the shard key is chosen correctly, then it will only be better, not worse, because it’s a WORST case now.</p><blockquote name="40a1" id="40a1" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Why so sure?</em></blockquote><p name="1e50" id="1e50" class="graf graf--p graf-after--blockquote">The formula for query time in database is as follows.</p><figure name="ace2" id="ace2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fwXYJlWF33j83fwDEzK0uw.png" data-width="1182" data-height="1082" src="https://cdn-images-1.medium.com/max/800/1*fwXYJlWF33j83fwDEzK0uw.png"></figure><p name="ca5a" id="ca5a" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">T</em>total = <em class="markup--em markup--p-em">T</em>s + <em class="markup--em markup--p-em">T</em>x</p><p name="a42c" id="a42c" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">T</em>s is the retrieval time of the database itself, either by index or by scanning the full collection.<br><em class="markup--em markup--p-em">T</em>x is the return time of the query result.</p><p name="4045" id="4045" class="graf graf--p graf-after--p">In addition, <em class="markup--em markup--p-em">T</em>s and <em class="markup--em markup--p-em">T</em>x have the following properties.<br><em class="markup--em markup--p-em">T</em>s ∝ total data volume<br><em class="markup--em markup--p-em">T</em>x ∝ result size</p><p name="359b" id="359b" class="graf graf--p graf-after--p">When we migrate this collection to a sharded cluster, then the above diagram will change a bit.</p><figure name="941b" id="941b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BwtktGWTYoPm7YD_i9MemQ.png" data-width="1182" data-height="906" src="https://cdn-images-1.medium.com/max/800/1*BwtktGWTYoPm7YD_i9MemQ.png"></figure><p name="78f2" id="78f2" class="graf graf--p graf-after--figure">The formula will also change a little bit, but the principle is the same.</p><p name="3f6c" id="3f6c" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">T</em>clusteredTotal = Max( <em class="markup--em markup--p-em">T</em>1s + <em class="markup--em markup--p-em">T</em>1x , <em class="markup--em markup--p-em">T</em>2s + <em class="markup--em markup--p-em">T</em>2x )</p><p name="d6b0" id="d6b0" class="graf graf--p graf-after--p">Even if there is data skew happening, I believe we all agree the following conditions are true.</p><ul class="postList"><li name="0d1d" id="0d1d" class="graf graf--li graf-after--p"><em class="markup--em markup--li-em">T</em>ns &lt; <em class="markup--em markup--li-em">T</em>s</li><li name="7d4d" id="7d4d" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">T</em>nx &lt; <em class="markup--em markup--li-em">T</em>x</li></ul><p name="9703" id="9703" class="graf graf--p graf-after--li">Therefore, a conclusion can be deduced.</p><p name="b19e" id="b19e" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">T</em>clusteredTotal &lt; <em class="markup--em markup--p-em">T</em>total</p><p name="3bb2" id="3bb2" class="graf graf--p graf-after--p">Nevertheless, there are still some worst cases, for example, sharding is based on the data size rather than the frequency of data access, if there is busy collection(s) originally distributed in two shards without sharding, so they can consume all the resources of their respective machines individually. However, because of sharding, most of the data is distributed to the same shard, which competes for resources.</p><p name="dc41" id="dc41" class="graf graf--p graf-after--p">In other words, the precondition for the problem is the original MongoDB is nearly full and resources are almost exhausted.</p><h3 name="ba54" id="ba54" class="graf graf--h3 graf-after--p">How to choose shard key?</h3><p name="52f5" id="52f5" class="graf graf--p graf-after--h3">From the above introduction, we know as long as the shard key is chosen correctly, then we don’t need to worry about the performance of queries decreasing after sharding. Therefore, how to choose the shard key is pretty important.</p><p name="87f2" id="87f2" class="graf graf--p graf-after--p">I have already provided the ideal formula and described the details in my previous article.</p><div name="7686" id="7686" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://interviewnoodle.com/how-to-choose-a-mongodb-shard-key-e4063b636c26" data-href="https://interviewnoodle.com/how-to-choose-a-mongodb-shard-key-e4063b636c26" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://interviewnoodle.com/how-to-choose-a-mongodb-shard-key-e4063b636c26"><strong class="markup--strong markup--mixtapeEmbed-strong">How to choose a MongoDB shard key</strong><br><em class="markup--em markup--mixtapeEmbed-em">I will show you what is the ideal pattern of a MongoDB shard key and the concepts behind it.</em>interviewnoodle.com</a><a href="https://interviewnoodle.com/how-to-choose-a-mongodb-shard-key-e4063b636c26" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="fb12cbe92712470989e95becba072178" data-thumbnail-img-id="0*huNV3uOmTLrTv1Z0.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*huNV3uOmTLrTv1Z0.png);"></a></div><p name="7dab" id="7dab" class="graf graf--p graf-after--mixtapeEmbed">Therefore, in this article, I will only outline which three types of bad cases must be avoided.</p><h3 name="703b" id="703b" class="graf graf--h3 graf-after--p">Low Cardinality</h3><p name="0079" id="0079" class="graf graf--p graf-after--h3">Suppose we choose an enum field as the shard key, and the range is fixed to [1, 2, 3].</p><figure name="b166" id="b166" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*DPQxL-Q556v-sQs5nxrHNQ.png" data-width="1182" data-height="710" src="https://cdn-images-1.medium.com/max/800/1*DPQxL-Q556v-sQs5nxrHNQ.png"></figure><p name="5ce3" id="5ce3" class="graf graf--p graf-after--figure">Then even if we write 2 to the max, we still can’t start rebalance, and the maximum number of shards is 3.</p><h3 name="6fd0" id="6fd0" class="graf graf--h3 graf-after--p">Ascending</h3><p name="acbd" id="acbd" class="graf graf--p graf-after--h3">If we use a continuously incrementing field as the shard key, then we can ensure the chunks are evenly distributed, but it will continuously trigger a rebalance, and the performance will be horrible.</p><figure name="6776" id="6776" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*77cfvZBiI__SSyfmmq-Sng.png" data-width="1182" data-height="250" src="https://cdn-images-1.medium.com/max/800/1*77cfvZBiI__SSyfmmq-Sng.png"></figure><p name="1f9c" id="1f9c" class="graf graf--p graf-after--figure">Furthermore, the data we need to query frequently is usually new, in other words, the query and the rebalance will often mix together, making the situation even worse.</p><h3 name="94fc" id="94fc" class="graf graf--h3 graf-after--p">Random or Hash Value</h3><p name="1355" id="1355" class="graf graf--p graf-after--h3">Another common choice is to use a random field (or hashing) as the shard key, which also ensures the chunks are evenly distributed and does not trigger frequent rebalances, but the rebalance overhead is increased.</p><p name="9dbd" id="9dbd" class="graf graf--p graf-after--p">MongoDB’s storage engine, WiredTiger, uses a storage distribution similar to MySQL’s InnoDB, i.e., the primary key (<code class="markup--code markup--p-code">_id</code>) is used as the storage unit (block), and similar primary keys are placed in the same block.</p><p name="1967" id="1967" class="graf graf--p graf-after--p">If we use random shard key, it will trigger random access instead of sequential access when we do rebalance.</p><figure name="59cf" id="59cf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*bFbHcivvKbOf4_9qoEiFxw.png" data-width="1182" data-height="396" src="https://cdn-images-1.medium.com/max/800/1*bFbHcivvKbOf4_9qoEiFxw.png"></figure><p name="ab56" id="ab56" class="graf graf--p graf-after--figure">For instance, when a chunk is full and needs to be rebalanced, the data needs to be migrated across three blocks, and the entire rebalance time will be longer. This is far worse than the performance of a single block to complete the rebalance, as shown in the following diagram.</p><figure name="bf84" id="bf84" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*nKH8OXMX0LGnjPNe8b8tBg.png" data-width="1182" data-height="396" src="https://cdn-images-1.medium.com/max/800/1*nKH8OXMX0LGnjPNe8b8tBg.png"></figure><h3 name="8b8b" id="8b8b" class="graf graf--h3 graf-after--figure">Conclusion</h3><p name="c07c" id="c07c" class="graf graf--p graf-after--h3">When we encounter a new problem, we often feel hesitant or even scared because it is unfamiliar.</p><p name="e110" id="e110" class="graf graf--p graf-after--p">What we need to do is to take a deep breath and return to the nature of the problem, analyze the core of the problem, and don’t be confused by the external appearance. Taking cross-shard queries as an example, when we use the database perspective instead of MongoDB to unpack the problem, the answer will be obvious.</p><p name="d25e" id="d25e" class="graf graf--p graf-after--p graf--trailing">Software engineering is already a stable field, most of the problems are similar in nature, so don’t panic, think carefully, most of the answers are not complicated.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/2a7797a96528"><time class="dt-published" datetime="2023-08-14T01:50:58.280Z">August 14, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/dont-be-afraid-of-mongodb-cross-shard-queries-2a7797a96528" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>