<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Flink SQL Performance Tuning, Part 2</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Flink SQL Performance Tuning, Part 2</h1>
</header>
<section data-field="subtitle" class="p-summary">
Explaining the concept of Split Distinct aggregation and JOIN optimizations
</section>
<section data-field="body" class="e-content">
<section name="ebd2" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7588" id="7588" class="graf graf--h3 graf--leading graf--title">Flink SQL Performance Tuning, Part 2</h3><h4 name="4667" id="4667" class="graf graf--h4 graf-after--h3 graf--subtitle">Explaining the concept of Split Distinct aggregation and JOIN optimizations</h4><figure name="c495" id="c495" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*uAPs3J29Z3WeqDhS" data-width="1000" data-height="673" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*uAPs3J29Z3WeqDhS"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@sth0315" data-href="https://unsplash.com/@sth0315" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Jason Song</a> on <a href="https://unsplash.com/photos/fpoyFPKB7y4" data-href="https://unsplash.com/photos/fpoyFPKB7y4" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><ul class="postList"><li name="dbd4" id="dbd4" class="graf graf--li graf-after--figure"><a href="https://lazypro.medium.com/flink-sql-performance-tuning-part-1-f71a0a0ee91" data-href="https://lazypro.medium.com/flink-sql-performance-tuning-part-1-f71a0a0ee91" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Flink SQL Performance Tuning, Part 1</a></li><li name="3e24" id="3e24" class="graf graf--li graf-after--li"><a href="https://lazypro.medium.com/flink-sql-performance-tuning-part-2-c102177b1ce1" data-href="https://lazypro.medium.com/flink-sql-performance-tuning-part-2-c102177b1ce1" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Flink SQL Performance Tuning, Part 2</a></li></ul><p name="b9a1" id="b9a1" class="graf graf--p graf-after--li">In the previous article, we introduced three kinds of optimization mechanisms for Flink SQL as follows.</p><ol class="postList"><li name="1e56" id="1e56" class="graf graf--li graf-after--p">Reduce sub plan</li><li name="816f" id="816f" class="graf graf--li graf-after--li">Mini batch</li><li name="8f0f" id="8f0f" class="graf graf--li graf-after--li">Local-Global aggregation</li></ol><p name="bd0d" id="bd0d" class="graf graf--p graf-after--li">These mechanisms correspond to some use cases individually. Among them, mini batch and Local-Global aggregation are both optimized for <code class="markup--code markup--p-code">GROUP BY</code> operations. However, in the previous article, we mentioned that even though both mechanisms can improve the performance of <code class="markup--code markup--p-code">GROUP BY</code>, they are not applicable to <code class="markup--code markup--p-code">DISTINCT</code>.</p><p name="4e11" id="4e11" class="graf graf--p graf-after--p">Therefore, in these articles, we will start by explaining the reason for this problem, and then we will introduce more optimization mechanisms.</p><h3 name="581a" id="581a" class="graf graf--h3 graf-after--p"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/tuning/#split-distinct-aggregation" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/tuning/#split-distinct-aggregation" class="markup--anchor markup--h3-anchor" rel="noopener" target="_blank">Split Distinct Aggregation</a></h3><p name="af73" id="af73" class="graf graf--p graf-after--h3">Before explaining the problems encountered by <code class="markup--code markup--p-code">DISTINCT</code>, let’s review Local-Global aggregation with an example.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="e27b" id="e27b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> color, <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> id)<br /><span class="hljs-keyword">FROM</span> T<br /><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> color</span></pre><p name="bc8a" id="bc8a" class="graf graf--p graf-after--pre">This SQL command is a little different from the previous one, i.e., it uses <code class="markup--code markup--p-code">DISTINCT</code>, but it is similar to the previous one.</p><p name="3ed6" id="3ed6" class="graf graf--p graf-after--p">In Local-Global aggregation, we will do a first aggregation in the mini batch according to the color, and then we will do a second aggregation in the next operator with the results of the mini batch pre-aggregation.</p><figure name="86ec" id="86ec" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*stpDIGZoctvkUaU0G4JHQw.png" data-width="1144" data-height="1012" src="https://cdn-images-1.medium.com/max/800/1*stpDIGZoctvkUaU0G4JHQw.png"><figcaption class="imageCaption"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/distinct_split.png" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/distinct_split.png" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/distinct_split.png</a></figcaption></figure><p name="3272" id="3272" class="graf graf--p graf-after--figure">As we can see above, even though we did the pre-aggregation in the mini batch, the effect is not significant because the operation <code class="markup--code markup--p-code">DISTINCT</code> is not able to merge. This also results in a lot of data in the final aggregation, and the data skew is not solved.</p><p name="f147" id="f147" class="graf graf--p graf-after--p">Since so, can we use <code class="markup--code markup--p-code">id</code> to group the data again during local aggregation? By splitting again, we can collect data with the same <code class="markup--code markup--p-code">id</code> together, and then we can merge them.</p><p name="1376" id="1376" class="graf graf--p graf-after--p">This is exactly the concept of Split Distinct aggregation.</p><p name="e9d9" id="e9d9" class="graf graf--p graf-after--p">Let’s use pseudocode to explain.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="vbnet" name="3107" id="3107" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> color, SUM(cnt)<br /><span class="hljs-keyword">FROM</span> (<br />    <span class="hljs-keyword">SELECT</span> color, COUNT(<span class="hljs-keyword">DISTINCT</span> id) <span class="hljs-keyword">as</span> cnt<br />    <span class="hljs-keyword">FROM</span> T<br />    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> color, <span class="hljs-built_in">MOD</span>(HASH_CODE(id), <span class="hljs-number">4</span>)<br />)<br /><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> color</span></pre><p name="1618" id="1618" class="graf graf--p graf-after--pre">Split Distinct aggregation rewrites the original <code class="markup--code markup--p-code">COUNT(DISTINCT id)</code> into the above code. By first splitting the group with <code class="markup--code markup--p-code">id</code>, in this case into 4 groups, the pre-aggregation can be done.</p><p name="ce9b" id="ce9b" class="graf graf--p graf-after--p">Therefore, the actual operator will look like the following diagram.</p><figure name="0744" id="0744" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lxuBynfRQT6dnQcPmVvPIA.png" data-width="1164" data-height="1152" src="https://cdn-images-1.medium.com/max/800/1*lxuBynfRQT6dnQcPmVvPIA.png"><figcaption class="imageCaption"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/distinct_split.png" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/distinct_split.png" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/distinct_split.png</a></figcaption></figure><p name="76b4" id="76b4" class="graf graf--p graf-after--figure">We can see in the final aggregation stage that each operator needs to process the data more evenly, in other words, the data skew is solved.</p><p name="08be" id="08be" class="graf graf--p graf-after--p">There are two settings to enable Split Distinct aggregation.</p><ul class="postList"><li name="4220" id="4220" class="graf graf--li graf-after--p">table.optimizer.distinct-agg.split.enabled</li><li name="61f2" id="61f2" class="graf graf--li graf-after--li">table.optimizer.distinct-agg.split.bucket-num</li></ul><p name="00a7" id="00a7" class="graf graf--p graf-after--li">The first setting is the feature toggle, and the second setting is the number of groups. Although we use <code class="markup--code markup--p-code">COUNT</code> as an example, any operation that is able to be merged can be split.</p><p name="9360" id="9360" class="graf graf--p graf-after--p">Nevertheless, one of the problems with Split Distinct aggregation is the significantly larger state and the increased state access. This is because the result of the split operation relies on the state to be persistent.</p><p name="d405" id="d405" class="graf graf--p graf-after--p">How to solve it?</p><p name="9bea" id="9bea" class="graf graf--p graf-after--p">Well, it’s as simple as a Local-Global aggregation after splitting the group. So the complete settings are as follows.</p><ul class="postList"><li name="f06d" id="f06d" class="graf graf--li graf-after--p">table.exec.mini-batch.enabled</li><li name="2371" id="2371" class="graf graf--li graf-after--li">table.exec.mini-batch.allow-latency</li><li name="be85" id="be85" class="graf graf--li graf-after--li">table.exec.mini-batch.size</li><li name="881a" id="881a" class="graf graf--li graf-after--li">table.optimizer.agg-phase-strategy: “TWO_PHASE”</li><li name="d84a" id="d84a" class="graf graf--li graf-after--li">table.optimizer.distinct-agg.split.enabled</li><li name="23ec" id="23ec" class="graf graf--li graf-after--li">table.optimizer.distinct-agg.split.bucket-num</li></ul><p name="f500" id="f500" class="graf graf--p graf-after--li">We have turned on all the optimization settings related to <code class="markup--code markup--p-code">GROUP BY</code>. Be sure to remember that these come at a price, the most obvious of them is the increased use of computing resources.</p><h3 name="a89b" id="a89b" class="graf graf--h3 graf-after--p">JOIN Optimization</h3><p name="079f" id="079f" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">JOIN</code> is a common practice for enrichment. In a normal SQL <code class="markup--code markup--p-code">JOIN</code>, it’s to find the same columns in the left and right tables and join the remaining columns together, but in streaming, it’s far from simple.</p><p name="5a9d" id="5a9d" class="graf graf--p graf-after--p">Because, there is no physical table in streaming.</p><p name="fb38" id="fb38" class="graf graf--p graf-after--p">So, in order to make the table concept, Flink will store the data in the state, and when there is an event input, the corresponding data can be taken out from the state immediately. However, there is a big problem with this approach, that is, the state will grow infinitely.</p><p name="3117" id="3117" class="graf graf--p graf-after--p">For example, suppose Flink has two streams, order and product. The order stream will keep append once there is a new order, and the product stream will have events for product creation, update and deletion.</p><p name="1926" id="1926" class="graf graf--p graf-after--p">Therefore, we write the following Flink SQL.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="4cdb" id="4cdb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Orders<br /><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Product<br /><span class="hljs-keyword">ON</span> Orders.productId <span class="hljs-operator">=</span> Product.id</span></pre><p name="34cc" id="34cc" class="graf graf--p graf-after--pre">In the implementation behind Flink, all changes to the product are stored by the state, so that the corresponding result can be found as soon as the order event is generated, even if the product does not have any orders at all.</p><p name="5a3b" id="5a3b" class="graf graf--p graf-after--p">When there are a lot of products and the operator is running for a long time, this state can become very huge.</p><p name="1e0a" id="1e0a" class="graf graf--p graf-after--p">The most straightforward solution to reduce the unused state is to <a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/config/#table-exec-state-ttl" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/config/#table-exec-state-ttl" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">set TTL</a> as follows.</p><ul class="postList"><li name="1d62" id="1d62" class="graf graf--li graf-after--p">table.exec.state.ttl</li></ul><p name="c1d7" id="c1d7" class="graf graf--p graf-after--li">Nevertheless, when a product’s state is deleted, it can lead to unexpected results. In the above example, when the state of a product is deleted, if the order event of the same product comes in, the corresponding product information will not be found.</p><p name="e83c" id="e83c" class="graf graf--p graf-after--p">In addition to this simple and brutal approach, Flink also provides three alternatives to <code class="markup--code markup--p-code">JOIN</code> optimization.</p><p name="c89c" id="c89c" class="graf graf--p graf-after--p"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/joins/#interval-joins" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/joins/#interval-joins" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Interval Join</strong></a></p><p name="0e28" id="0e28" class="graf graf--p graf-after--p">It has a similar purpose to setting the TTL directly above, except that it allows the user to decide which field to use as the basis for time judgments.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="a7fa" id="a7fa" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br /><span class="hljs-keyword">FROM</span> Orders o, Shipments s<br /><span class="hljs-keyword">WHERE</span> o.id <span class="hljs-operator">=</span> s.order_id<br /><span class="hljs-keyword">AND</span> o.order_time <span class="hljs-keyword">BETWEEN</span> s.ship_time <span class="hljs-operator">-</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-string">&#x27;4&#x27;</span> <span class="hljs-keyword">HOUR</span> <span class="hljs-keyword">AND</span> s.ship_time</span></pre><p name="9213" id="9213" class="graf graf--p graf-after--pre">Through this SQL, we can specify <code class="markup--code markup--p-code">order_time</code> and <code class="markup--code markup--p-code">shipment_time</code> as the basis of TTL, then Flink can know not to keep the state of the difference between <code class="markup--code markup--p-code">order_time</code> and <code class="markup--code markup--p-code">shipment_time</code> for more than 4 hours.</p><p name="7fe1" id="7fe1" class="graf graf--p graf-after--p">However, there is a limitation in this approach, in addition to the fact table on the left is append only, the dimension table on the right must also be append only, otherwise the time interval will be inconsistent.</p><p name="2209" id="2209" class="graf graf--p graf-after--p"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/joins/#temporal-joins" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/joins/#temporal-joins" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Temporal Join</strong></a></p><p name="ea1c" id="ea1c" class="graf graf--p graf-after--p">Before we explain Temporal Join, let’s look at another example.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="0abc" id="0abc" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders<br /><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> currency_rates<br /><span class="hljs-keyword">ON</span> orders.currency <span class="hljs-operator">=</span> currency_rates.currency</span></pre><p name="5d8a" id="5d8a" class="graf graf--p graf-after--pre">Assuming this is an international order, we need to know what the currency rate is for the order in order to calculate the sales performance of the product.</p><p name="f1aa" id="f1aa" class="graf graf--p graf-after--p">In order to keep the currency rates available at all times, Flink keeps a complete history of the currency rates. For example.</p><figure name="76b3" id="76b3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*4uJI9j1hxPTexp_SCEFKZg.png" data-width="728" data-height="324" src="https://cdn-images-1.medium.com/max/800/1*4uJI9j1hxPTexp_SCEFKZg.png"></figure><p name="8c08" id="8c08" class="graf graf--p graf-after--figure">Therefore, the correct result can be obtained regardless of whether the order is placed at 12:00 or 12:01. However, we don’t really need this historical data, because we only need the current currency of the order, and the past history can be cleared out.</p><p name="7774" id="7774" class="graf graf--p graf-after--p">This is the concept of Temporal Join, only keep a latest mapping.</p><blockquote name="d347" id="d347" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">currency: conversion_rate</em></blockquote><p name="c405" id="c405" class="graf graf--p graf-after--blockquote">How to use this approach?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="553d" id="553d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders<br /><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> currency_rates <span class="hljs-keyword">FOR</span> <span class="hljs-built_in">SYSTEM_TIME</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">OF</span> orders.order_time<br /><span class="hljs-keyword">ON</span> orders.currency <span class="hljs-operator">=</span> currency_rates.currency;</span></pre><p name="6aa6" id="6aa6" class="graf graf--p graf-after--pre">One of the most special is <code class="markup--code markup--p-code">FOR SYSTEM_TIME AS OF</code>, this usage can be referred to <a href="https://en.wikipedia.org/wiki/SQL:2011" data-href="https://en.wikipedia.org/wiki/SQL:2011" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">SQL:2011 standard</a>, this article will not dive into it.</p><p name="a92b" id="a92b" class="graf graf--p graf-after--p"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/joins/#lookup-join" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/joins/#lookup-join" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Lookup Join</strong></a></p><p name="a501" id="a501" class="graf graf--p graf-after--p">The concept of Lookup Join is even more simple, since the state of Flink is so big and difficult to manage, it is better to go directly to the external data source, such as MySQL, for every event at the moment.</p><blockquote name="9d77" id="9d77" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Time for space.</em></blockquote><p name="95be" id="95be" class="graf graf--p graf-after--blockquote">The entire syntax is written in the same way as the previous Temporal Join, using <code class="markup--code markup--p-code">FOR SYSTEM_TIME AS OF</code>, the only thing worth noting is the usage of <code class="markup--code markup--p-code">proc_time</code>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="vbnet" name="a90b" id="a90b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> o.order_id, o.total, c.country, c.zip<br /><span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">AS</span> o<br /><span class="hljs-keyword">JOIN</span> Customers <span class="hljs-keyword">FOR</span> SYSTEM_TIME <span class="hljs-keyword">AS</span> <span class="hljs-keyword">OF</span> o.proc_time <span class="hljs-keyword">AS</span> c<br /><span class="hljs-keyword">ON</span> o.customer_id = c.id;</span></pre><p name="ab78" id="ab78" class="graf graf--p graf-after--pre">Because it is accessing external storage, Flink also provides some built-in optimization features.</p><p name="3174" id="3174" class="graf graf--p graf-after--p">In general, the process of accessing external storage is synchronous, sending a request and waiting for a response before moving on to the next one. However, Flink offers to send all requests at once and then wait for responses asynchronously, and it is turned on by default.</p><p name="309f" id="309f" class="graf graf--p graf-after--p">If we want to adjust it manually, we can refer to the <a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/hints/#lookup" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/hints/#lookup" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Hints</a> mentioned in the official document.</p><p name="2d52" id="2d52" class="graf graf--p graf-after--p">In addition, even if the external storage is accessed asynchronously, the actual operation will wait for the correct order of the responses after receiving them. If the order of the responses is not that important, then we can tell Flink not to wait for the responses to be in order.</p><p name="e5de" id="e5de" class="graf graf--p graf-after--p">Use the SQL command mentioned earlier as an example.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="8d4e" id="8d4e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">SELECT /*+ LOOKUP(<span class="hljs-string">&#x27;table&#x27;</span>=<span class="hljs-string">&#x27;Customers&#x27;</span>, <span class="hljs-string">&#x27;async&#x27;</span>=<span class="hljs-string">&#x27;true&#x27;</span>. <span class="hljs-string">&#x27;output-mode&#x27;</span>=<span class="hljs-string">&#x27;allow_unordered&#x27;</span>, <span class="hljs-string">&#x27;capacity&#x27;</span>=<span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-string">&#x27;timeout&#x27;</span>=<span class="hljs-string">&#x27;180s&#x27;</span>) */<br />    o.order_id, o.total, c.country, c.<span class="hljs-built_in">zip</span><br />FROM Orders AS o<br />JOIN Customers FOR SYSTEM_TIME AS OF o.proc_time AS c<br />ON o.customer_id = c.<span class="hljs-built_in">id</span>;</span></pre><p name="a67e" id="a67e" class="graf graf--p graf-after--pre">It is most intuitive to tell the Flink optimizer what to do through Hints, so that it can be adjusted according to each command, but it is also possible to enable the global setting directly.</p><ul class="postList"><li name="dbb1" id="dbb1" class="graf graf--li graf-after--p">table.exec.async-lookup.output-mode</li><li name="9925" id="9925" class="graf graf--li graf-after--li">table.exec.async-lookup.buffer-capacity</li><li name="0567" id="0567" class="graf graf--li graf-after--li">table.exec.async-lookup.timeout</li></ul><p name="0974" id="0974" class="graf graf--p graf-after--li">Mode and timeout are considered simple, as for capacity refers to how many IO command will trigger the actual <code class="markup--code markup--p-code">JOIN</code> operation. But I feel this is a bit abstract, set how much is appropriate is difficult to tell, it still needs to rely on experiments.</p><p name="915e" id="915e" class="graf graf--p graf-after--p"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/window-join/" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/window-join/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Window Join</strong></a></p><p name="83d3" id="83d3" class="graf graf--p graf-after--p">The last one is Window Join, which is similar to the concept of Interval Join mentioned earlier, and only retains a specific time range of states instead of all historical states. However, the window mechanism is very complicated and not required, so we will directly attach the example of the official document here without further explanation.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="d297" id="d297" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> L.num <span class="hljs-keyword">as</span> L_Num, L.id <span class="hljs-keyword">as</span> L_Id, R.num <span class="hljs-keyword">as</span> R_Num, R.id <span class="hljs-keyword">as</span> R_Id,<br />    <span class="hljs-built_in">COALESCE</span>(L.window_start, R.window_start) <span class="hljs-keyword">as</span> window_start,<br />    <span class="hljs-built_in">COALESCE</span>(L.window_end, R.window_end) <span class="hljs-keyword">as</span> window_end<br /><span class="hljs-keyword">FROM</span> (<br />    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span>(<br />        TUMBLE(<span class="hljs-keyword">TABLE</span> LeftTable, DESCRIPTOR(row_time), <span class="hljs-type">INTERVAL</span> <span class="hljs-string">&#x27;5&#x27;</span> MINUTES)<br />    )<br />) L<br /><span class="hljs-keyword">FULL</span> <span class="hljs-keyword">JOIN</span> (<br />    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span>(<br />        TUMBLE(<span class="hljs-keyword">TABLE</span> RightTable, DESCRIPTOR(row_time), <span class="hljs-type">INTERVAL</span> <span class="hljs-string">&#x27;5&#x27;</span> MINUTES)<br />    )<br />) R<br /><span class="hljs-keyword">ON</span> L.num <span class="hljs-operator">=</span> R.num <span class="hljs-keyword">AND</span> L.window_start <span class="hljs-operator">=</span> R.window_start <span class="hljs-keyword">AND</span> L.window_end <span class="hljs-operator">=</span> R.window_end;</span></pre><p name="428d" id="428d" class="graf graf--p graf-after--pre">To sum up, all kinds of JOIN rewriting are aimed at reducing the size of state.</p><p name="4fb3" id="4fb3" class="graf graf--p graf-after--p">The original JOIN will generate extremely large state, which will consume a lot of hardware resources if stored in memory, or generate a lot of hard disk IO if stored on persistent storage such as RocksDB, either of which will have a huge impact on performance.</p><p name="4f10" id="4f10" class="graf graf--p graf-after--p">Therefore, these four JOIN optimizations are all aimed at reducing the size of the state, but the exact solution to be used depends on the use case. The following is a brief list of the applicable scenarios.</p><ul class="postList"><li name="e98e" id="e98e" class="graf graf--li graf-after--p">Interval Join: Both the fact table and dimension table are append-only.</li><li name="d4f7" id="d4f7" class="graf graf--li graf-after--li">Temporal Join: Only the latest dimension is required.</li><li name="84ee" id="84ee" class="graf graf--li graf-after--li">Lookup Join: The dimension table is stored externally and does not care about dimension changes.</li><li name="21fd" id="21fd" class="graf graf--li graf-after--li">Window Join: Both fact and dimension tables have the window function enabled.</li></ul><h3 name="48eb" id="48eb" class="graf graf--h3 graf-after--li">Conclusion</h3><p name="0651" id="0651" class="graf graf--p graf-after--h3">In the previous article, we introduced how to optimize general SQL commands and how to make <code class="markup--code markup--p-code">GROUP BY</code> more efficient. In this article, we introduced <code class="markup--code markup--p-code">DISTINCT</code> and <code class="markup--code markup--p-code">JOIN</code>.</p><p name="19f2" id="19f2" class="graf graf--p graf-after--p">I believe these two articles should have covered most of the Flink SQL scenarios, in fact, it is not hard to find that there are the following ways to make Flink SQL perform better.</p><ul class="postList"><li name="8385" id="8385" class="graf graf--li graf-after--p">Reducing invalid ( repeated ) commands</li><li name="e7f1" id="e7f1" class="graf graf--li graf-after--li">Reducing state access</li><li name="aa49" id="aa49" class="graf graf--li graf-after--li">Reducing the size of state</li><li name="bb0d" id="bb0d" class="graf graf--li graf-after--li">Reducing data skew</li></ul><p name="95fe" id="95fe" class="graf graf--p graf-after--li">Every optimization has a proper scenario and a price to pay, and how to make Flink SQL perform better is a balance between these tradeoffs. Most of the optimizations are case-by-case and require understanding of Flink implementation before they can be applied.</p><p name="d8ea" id="d8ea" class="graf graf--p graf-after--p graf--trailing">These two articles are based on the latest stable version of Flink 1.17, maybe the URL of the attached reference will change, but I have explained the core concepts, so the new or old version of Flink should also be used as a reference.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/c102177b1ce1"><time class="dt-published" datetime="2023-07-03T02:00:15.565Z">July 3, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/flink-sql-performance-tuning-part-2-c102177b1ce1" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>