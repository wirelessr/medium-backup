<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Flink SQL Performance Tuning, Part 1</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Flink SQL Performance Tuning, Part 1</h1>
</header>
<section data-field="subtitle" class="p-summary">
Explaining the concept of reduce sub plan, mini batch and Local-Global aggregation
</section>
<section data-field="body" class="e-content">
<section name="1677" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e6fe" id="e6fe" class="graf graf--h3 graf--leading graf--title">Flink SQL Performance Tuning, Part 1</h3><h4 name="d01c" id="d01c" class="graf graf--h4 graf-after--h3 graf--subtitle">Explaining the concept of reduce sub plan, mini batch and Local-Global aggregation</h4><figure name="f60e" id="f60e" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*3omIjk3XZOlpX8Z8" data-width="1000" data-height="673" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*3omIjk3XZOlpX8Z8"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@sth0315" data-href="https://unsplash.com/@sth0315" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Jason Song</a> on <a href="https://unsplash.com/photos/fpoyFPKB7y4" data-href="https://unsplash.com/photos/fpoyFPKB7y4" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><ul class="postList"><li name="d859" id="d859" class="graf graf--li graf-after--figure"><a href="https://lazypro.medium.com/flink-sql-performance-tuning-part-1-f71a0a0ee91" data-href="https://lazypro.medium.com/flink-sql-performance-tuning-part-1-f71a0a0ee91" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Flink SQL Performance Tuning, Part 1</a></li><li name="a170" id="a170" class="graf graf--li graf-after--li"><a href="https://lazypro.medium.com/flink-sql-performance-tuning-part-2-c102177b1ce1" data-href="https://lazypro.medium.com/flink-sql-performance-tuning-part-2-c102177b1ce1" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Flink SQL Performance Tuning, Part 2</a></li></ul><p name="85f5" id="85f5" class="graf graf--p graf-after--li">Before talking about the tuning, we have to understand how Flink SQL works. In general, there are several steps as follows.</p><figure name="8616" id="8616" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fb2k2PK_Lkm1-Ykm9iPuhg.png" data-width="1150" data-height="104" src="https://cdn-images-1.medium.com/max/800/1*fb2k2PK_Lkm1-Ykm9iPuhg.png"></figure><p name="e1e9" id="e1e9" class="graf graf--p graf-after--figure">After receiving a SQL command, it is first parsed into a logical plan, and then the execution plan is generated by the optimizer. With the execution plan, the actual code for execution can be generated and finally turned into a job.</p><p name="aea8" id="aea8" class="graf graf--p graf-after--p">The only step we can control on the whole process is the optimizer.</p><p name="6450" id="6450" class="graf graf--p graf-after--p">And, the following are factors affecting Optimizer.</p><figure name="2098" id="2098" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*212V1L7af9jC2-VrjrimZw.png" data-width="1088" data-height="308" src="https://cdn-images-1.medium.com/max/800/1*212V1L7af9jC2-VrjrimZw.png"></figure><ul class="postList"><li name="8089" id="8089" class="graf graf--li graf-after--figure">LogicalPlan: Generated from SQL parser, it can be said that a good writing style basically solves most of the performance problems.</li><li name="a33d" id="a33d" class="graf graf--li graf-after--li">FlinkConf: In Flink, there are many optimizer-related <a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/config/" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/config/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">settings</a> that can be adjusted.</li><li name="bade" id="bade" class="graf graf--li graf-after--li">SchemaDesign: Of course, the schema design also determines some of the performance, such as the primary key.</li><li name="5b72" id="5b72" class="graf graf--li graf-after--li">Hints: Although the optimizer will try to cover as many scenarios as possible, sometimes we still need to “tell” the optimizer what to do, and that can be done through <a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/hints/" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/sql/queries/hints/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">hints</a>.</li></ul><p name="6793" id="6793" class="graf graf--p graf-after--li">Thus, this article will introduce a few common scenarios on how to tune.</p><h3 name="ea55" id="ea55" class="graf graf--h3 graf-after--p">Reuse Sub Plan</h3><p name="2909" id="2909" class="graf graf--p graf-after--h3">In Flink’s settings, <code class="markup--code markup--p-code">table.optimizer.reuse-sub-plan-enabled</code> is turned on by default. The functionality of this setting can be explained by a simple example.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="cbb3" id="cbb3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> sink1 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>;<br /><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> sink2 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AND</span> b <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span>;</span></pre><p name="ad49" id="ad49" class="graf graf--p graf-after--pre">First, convert the above two SQL commands into a logical plan.</p><figure name="603f" id="603f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Xvf-gmBSO_norc8CTjr21Q.png" data-width="744" data-height="490" src="https://cdn-images-1.medium.com/max/800/1*Xvf-gmBSO_norc8CTjr21Q.png"></figure><p name="8b26" id="8b26" class="graf graf--p graf-after--figure">Then, after the <code class="markup--code markup--p-code">reuse-sub-plan</code> of the optimizer, the following execution plan will be generated.</p><figure name="b80b" id="b80b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zeWnVE-AoEBqZVYwKbuCBg.png" data-width="744" data-height="490" src="https://cdn-images-1.medium.com/max/800/1*zeWnVE-AoEBqZVYwKbuCBg.png"></figure><p name="3c93" id="3c93" class="graf graf--p graf-after--figure">What the optimizer does is to merge the same parts, so that there is no need to repeat the process. But from our naked eyes, we can still see one identical part can be merged.</p><blockquote name="01e5" id="01e5" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">WHERE a &gt; 0</em></blockquote><p name="628c" id="628c" class="graf graf--p graf-after--blockquote">However, the optimizer does not recognize this clause, so we need to rewrite the original SQL to make the optimizer understand the merging rules for this filter.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="6667" id="6667" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CREATE</span> TEMPORARY <span class="hljs-keyword">VIEW</span> v <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>;<br /><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> sink1 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> v;<br /><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> sink2 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> v <span class="hljs-keyword">WHERE</span> b <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span>;</span></pre><p name="ce3b" id="ce3b" class="graf graf--p graf-after--pre">By creating a temporary view, the optimizer can generate a more efficient execution plan.</p><figure name="1fa4" id="1fa4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Afp6IrI5T5PM721my6GEog.png" data-width="494" data-height="678" src="https://cdn-images-1.medium.com/max/800/1*Afp6IrI5T5PM721my6GEog.png"></figure><h3 name="c93f" id="c93f" class="graf graf--h3 graf-after--figure"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/tuning/#minibatch-aggregation" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/tuning/#minibatch-aggregation" class="markup--anchor markup--h3-anchor" rel="noopener" target="_blank">MiniBatch Aggregation</a></h3><p name="570b" id="570b" class="graf graf--p graf-after--h3">Mini batch is a built-in performance optimization mechanism for Flink. The mechanism behind is explained in the <a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/tuning/#minibatch-aggregation" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/tuning/#minibatch-aggregation" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">official document</a>.</p><figure name="9f2d" id="9f2d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*QA_kV30-7fPG745x.png" data-width="2188" data-height="1776" src="https://cdn-images-1.medium.com/max/800/0*QA_kV30-7fPG745x.png"><figcaption class="imageCaption"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/minibatch_agg.png" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/minibatch_agg.png" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/minibatch_agg.png</a></figcaption></figure><p name="0132" id="0132" class="graf graf--p graf-after--figure">The above diagram shows an overview of a mini batch, in plain English, mini batch drastically reduces the number of accesses to the state.</p><p name="a354" id="a354" class="graf graf--p graf-after--p">Let’s use a practical example to explain this.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="e9b2" id="e9b2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> color, <span class="hljs-built_in">SUM</span>(id)<br /><span class="hljs-keyword">FROM</span> T<br /><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> color</span></pre><p name="7c95" id="7c95" class="graf graf--p graf-after--pre">This is a typical SQL aggregation operation, in fact, the internal operation of Flink is each event must access the state once, so it can be summed up.</p><p name="edec" id="edec" class="graf graf--p graf-after--p">It is written in Python as pseudocode as follows.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="97aa" id="97aa" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):<br />    color, <span class="hljs-built_in">id</span> = extract(<span class="hljs-built_in">input</span>)<br />    ret = state.get(color)<br />    ret += <span class="hljs-built_in">id</span><br />    state.update(color, ret)<br />    <span class="hljs-keyword">yield</span> ret</span></pre><p name="d4b3" id="d4b3" class="graf graf--p graf-after--pre">When inputting an event, first of all we find its <code class="markup--code markup--p-code">color</code>, then we take out the previous summation result, then we add the <code class="markup--code markup--p-code">id</code> to it, and finally we write the result back to the state. The next event comes in and repeats the process.</p><p name="7b41" id="7b41" class="graf graf--p graf-after--p">Such a iteration will be extremely frequent to access the state, resulting in performance impact. So mini batch collects events and accesses the state only once for each specific <code class="markup--code markup--p-code">color</code>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="4a5d" id="4a5d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mini_batch_process</span>(<span class="hljs-params">batch</span>):<br />    <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> batch:<br />        ret = state.get(color)<br />        <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> batch[color]:<br />            ret += <span class="hljs-built_in">id</span><br />        state.update(color, ret)<br />        <span class="hljs-keyword">yield</span> ret</span></pre><p name="5be9" id="5be9" class="graf graf--p graf-after--pre">As you can see from the code above, the process of mini batch is to collect the events of the same <code class="markup--code markup--p-code">color</code>, so the sum of the same <code class="markup--code markup--p-code">color</code> can be done at once, without the need to access the state frequently.</p><p name="9fb6" id="9fb6" class="graf graf--p graf-after--p">To enable mini batch is as simple as turning on the settings of the optimizer.</p><ul class="postList"><li name="b30e" id="b30e" class="graf graf--li graf-after--p">table.exec.mini-batch.enabled</li><li name="c0be" id="c0be" class="graf graf--li graf-after--li">table.exec.mini-batch.allow-latency</li><li name="ab20" id="ab20" class="graf graf--li graf-after--li">table.exec.mini-batch.size</li></ul><p name="5def" id="5def" class="graf graf--p graf-after--li">The first setting is on/off, the rest is to determine the size of the batch, which can be based on the amount or duration.</p><h3 name="6907" id="6907" class="graf graf--h3 graf-after--p"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/tuning/#local-global-aggregation" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/dev/table/tuning/#local-global-aggregation" class="markup--anchor markup--h3-anchor" rel="noopener" target="_blank">Local-Global Aggregation</a></h3><p name="c6d6" id="c6d6" class="graf graf--p graf-after--h3">There is a further optimization approach to <code class="markup--code markup--p-code">GROUP BY</code>, called Local-Global aggregation, which is an extension of mini batch.</p><p name="ec9a" id="ec9a" class="graf graf--p graf-after--p">The biggest problem of mini batch is that it will be grouped by <code class="markup--code markup--p-code">color</code>. If a particular <code class="markup--code markup--p-code">color</code> is especially large, then the downstream operator assigned to this <code class="markup--code markup--p-code">color</code> will have to process much more data, which is also called data skew. Therefore, Flink provides a mechanism to perform pre-aggregation in the mini batch in order to reduce the downstream load.</p><figure name="19bf" id="19bf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*URiwZKU1iTrr7Ds0.png" data-width="1945" data-height="870" src="https://cdn-images-1.medium.com/max/800/0*URiwZKU1iTrr7Ds0.png"><figcaption class="imageCaption"><a href="https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/local_agg.png" data-href="https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/local_agg.png" class="markup--anchor markup--figure-anchor" rel="nofollow noopener noopener" target="_blank">https://nightlies.apache.org/flink/flink-docs-release-1.17/fig/table-streaming/local_agg.png</a></figcaption></figure><p name="1c1c" id="1c1c" class="graf graf--p graf-after--figure">From the above diagram, we can see that after turning on Local-Global aggregation, the summation operation will be done inside the mini batch, and the last data aggregation will be done with a small amount of data. In the example red <em class="markup--em markup--p-em">Agg</em>, the amount of processed data will be changed from 12 to 3, i.e., the data skewing problem is solved.</p><p name="ea41" id="ea41" class="graf graf--p graf-after--p">To enable Local-Global aggregation, it is necessary to use the following settings in addition to the mini batch already enabled.</p><blockquote name="c786" id="c786" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">table.optimizer.agg-phase-strategy: “TWO_PHASE”</em></blockquote><h3 name="111b" id="111b" class="graf graf--h3 graf-after--blockquote">Conclusion</h3><p name="6f41" id="6f41" class="graf graf--p graf-after--h3">This article first introduces three of Flink’s built-in optimization mechanisms:</p><ul class="postList"><li name="1360" id="1360" class="graf graf--li graf-after--p">Reduce sub plan</li><li name="b115" id="b115" class="graf graf--li graf-after--li">MiniBatch aggregation</li><li name="012c" id="012c" class="graf graf--li graf-after--li">Local-Global aggregation</li></ul><p name="e674" id="e674" class="graf graf--p graf-after--li">Only the first one is enabled by default, but there is still room for manual optimization. The other two are turned off by default, especially the Local-Global aggregation, which requires an additional mini batch to be enabled in addition to the two phases.</p><p name="2949" id="2949" class="graf graf--p graf-after--p">Since these mechanisms look so good, why are they not turned on by default?</p><p name="1921" id="1921" class="graf graf--p graf-after--p">Because, these mechanisms are not without cost.</p><p name="ebbd" id="ebbd" class="graf graf--p graf-after--p">In the case of mini batch, when mini batch is turned on, it means the freshness of data will be affected, depending on the mini batch settings.</p><p name="42d5" id="42d5" class="graf graf--p graf-after--p">In addition, Local-Global aggregation is not available for all operations. It is only used for aggregations that can be merged, such as <code class="markup--code markup--p-code">SUM</code>, <code class="markup--code markup--p-code">MAX</code>, <code class="markup--code markup--p-code">COUNT</code>, etc., and not for <code class="markup--code markup--p-code">DISTINCT</code>. Moreover, Local-Global aggregation increases the computation complexity and therefore consumes additional computing resources, which is not always reasonable if the data skew is not large.</p><p name="05d8" id="05d8" class="graf graf--p graf-after--p">These optimization mechanisms must be understood before using in order to use them correctly, and turning them all on unconditionally may lead to counterproductive results.</p><p name="c4aa" id="c4aa" class="graf graf--p graf-after--p graf--trailing">Of course, Flink’s optimization mechanism is not just these, next time we will talk about <code class="markup--code markup--p-code">DISTINCT</code> and <code class="markup--code markup--p-code">JOIN</code> which are not covered in this article.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/f71a0a0ee91"><time class="dt-published" datetime="2023-06-26T01:51:42.000Z">June 26, 2023</time></a>.</p><p><a href="https://medium.com/@lazypro/flink-sql-performance-tuning-part-1-f71a0a0ee91" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>