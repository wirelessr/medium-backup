<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Original Sin of Microservices, Part 2</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Original Sin of Microservices, Part 2</h1>
</header>
<section data-field="subtitle" class="p-summary">
9 challenges of distributed architecture.
</section>
<section data-field="body" class="e-content">
<section name="dc7a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="646c" id="646c" class="graf graf--h3 graf--leading graf--title">Original Sin of Microservices, Part 2</h3><figure name="2810" id="2810" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*HO6bSdlPnOyQgZtl.jpg" data-width="2500" data-height="1666" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*HO6bSdlPnOyQgZtl.jpg"></figure><p name="31c7" id="31c7" class="graf graf--p graf-after--figure">Last time, we talked about <a href="https://lazypro.medium.com/original-sin-of-microservices-part-1-90461ddcefb" data-href="https://lazypro.medium.com/original-sin-of-microservices-part-1-90461ddcefb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">8 fallacies of distributed computing</a> and why our systems end up being more complex than we ever imagined. In our last conclusion, we mentioned that two nodes already have a lot of aspects to consider, let alone a microservice architecture.</p><p name="be60" id="be60" class="graf graf--p graf-after--p">Microservice architectures have many additional dilemmas to face. Therefore, in this article, we will introduce what are the challenges of designing a microservice architecture.</p><h3 name="6d7f" id="6d7f" class="graf graf--h3 graf-after--p">9 challenges of distributed architecture</h3><p name="4d17" id="4d17" class="graf graf--p graf-after--h3">When designing a microservice architecture, there are 9 things that must be carefully considered, and these 9 things are the source of the complexity of microservice architecture. In order to design a microservice architecture correctly, there are many factors that must be aware, such as data consistency, architecture scalability, system availability, etc., in addition to avoiding the fallacies mentioned in the previous article.</p><h3 name="39df" id="39df" class="graf graf--h3 graf-after--p">Service Granularity</h3><figure name="2f58" id="2f58" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*MhLAkdIGogY4Nn0pF2Ymwg.png" data-width="732" data-height="230" src="https://cdn-images-1.medium.com/max/800/1*MhLAkdIGogY4Nn0pF2Ymwg.png"><figcaption class="imageCaption">Macroservice</figcaption></figure><figure name="e859" id="e859" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*6dKuJfhSY-YkwizM95a13g.png" data-width="732" data-height="230" src="https://cdn-images-1.medium.com/max/800/1*6dKuJfhSY-YkwizM95a13g.png"><figcaption class="imageCaption">Microservice</figcaption></figure><p name="85a7" id="85a7" class="graf graf--p graf-after--figure">When we want to implement a notification service, suppose that there are three types of notifications, email, sms and mobile notifications. So should the granularity of this microservice include all three types of notifications, or should the three types of notifications be separated into a standalone microservice? How to make the right choice?</p><p name="e141" id="e141" class="graf graf--p graf-after--p">There are several points to deliberate. First, will these codes need to be changed very often? If not, then it seems feasible to put all notifications into the same notification service. On the contrary, if the content of emails needs to be changed very often, then perhaps emails can be separated out into a standalone microservice.</p><p name="2f85" id="2f85" class="graf graf--p graf-after--p">In addition, if sms has a large number of notifications, then sms may need to be horizontally scaled independently, i.e., sms can be a separate microservice.</p><p name="2c42" id="2c42" class="graf graf--p graf-after--p">How do you determine the correct granularity of microservices? It’s hard, isn’t it? This is the first challenge.</p><h3 name="4cbb" id="4cbb" class="graf graf--h3 graf-after--p">Shard Functionality</h3><blockquote name="18ef" id="18ef" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">Shared service vs. Shared code</em></blockquote><figure name="936e" id="936e" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*fIMu7U0_uedYNTKM5wG2qw.png" data-width="580" data-height="502" src="https://cdn-images-1.medium.com/max/800/1*fIMu7U0_uedYNTKM5wG2qw.png"><figcaption class="imageCaption">Shared service</figcaption></figure><figure name="1aef" id="1aef" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*FNeS9KgPX1Sr4trKWbGweg.png" data-width="1224" data-height="232" src="https://cdn-images-1.medium.com/max/800/1*FNeS9KgPX1Sr4trKWbGweg.png"><figcaption class="imageCaption">Shared code</figcaption></figure><p name="19c4" id="19c4" class="graf graf--p graf-after--figure">When there are shared functions, how do you decide where to place them? For example, when A, B and C all have an authentication function, should there be a microservice for authentication or should the authentication code be replicated in each microservice?</p><p name="88da" id="88da" class="graf graf--p graf-after--p">There are also some aspects to think about here. If there is a shared authentication service, who will authenticate the authentication service? When the authentication service goes down, will it result in a single point of failure (SPOF)? What happens when more and more services need to be authenticated and the authentication service can’t hold up?</p><p name="2b10" id="2b10" class="graf graf--p graf-after--p">On the other hand, if the code is copied to each service, how can we make online improvements if the logic of authentication has changed? In fact, the same problem can happen to data. When there is data needed by three microservices, should the data be shared with each other in a separate database or duplicated to each service?</p><p name="d22c" id="d22c" class="graf graf--p graf-after--p">Remember the ideal microservice mentioned at the beginning? No sharing of data. So here, I prefer to use the second approach, replicating the code instead of sharing the service.</p><h3 name="8ca8" id="8ca8" class="graf graf--h3 graf-after--p">Communication Protocols</h3><blockquote name="ab84" id="ab84" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">Synchronous vs. Asynchronous</em></blockquote><figure name="2ef5" id="2ef5" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*XcZ70vpfF-9et2gj90H8-A.png" data-width="500" data-height="138" src="https://cdn-images-1.medium.com/max/800/1*XcZ70vpfF-9et2gj90H8-A.png"><figcaption class="imageCaption">Synchronous</figcaption></figure><figure name="4e47" id="4e47" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*k0_P1Rl4nR1vlww7THFZQw.png" data-width="500" data-height="138" src="https://cdn-images-1.medium.com/max/800/1*k0_P1Rl4nR1vlww7THFZQw.png"><figcaption class="imageCaption">Asynchronous</figcaption></figure><p name="9ccd" id="9ccd" class="graf graf--p graf-after--figure">Should the communication between two services be synchronous or asynchronous? There are many factors to consider.</p><p name="27c2" id="27c2" class="graf graf--p graf-after--p">Asynchronous has the obvious benefit of being more efficient and less coupled with each other. When there is a need to scale horizontally, each microservice can also scale according to its own needs.</p><p name="4b57" id="4b57" class="graf graf--p graf-after--p">But synchronization also has the advantage that <code class="markup--code markup--p-code">Service A</code> can respond more quickly when <code class="markup--code markup--p-code">Service B</code> fails. In other words, synchronization can have higher consistency.</p><p name="89b3" id="89b3" class="graf graf--p graf-after--p">There is no standard answer between synchronous and asynchronous, it depends on the context.</p><h3 name="a88f" id="a88f" class="graf graf--h3 graf-after--p">Workflow Management</h3><blockquote name="ad8f" id="ad8f" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">Orchestration vs. Choreography</em></blockquote><figure name="c31a" id="c31a" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*gtD2WVw8lmfabO_oHtcgLw.png" data-width="774" data-height="308" src="https://cdn-images-1.medium.com/max/800/1*gtD2WVw8lmfabO_oHtcgLw.png"><figcaption class="imageCaption">Orchestration</figcaption></figure><figure name="fa64" id="fa64" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*xR_gawaJknn8I-wl0mfy-w.png" data-width="1058" data-height="206" src="https://cdn-images-1.medium.com/max/800/1*xR_gawaJknn8I-wl0mfy-w.png"><figcaption class="imageCaption">Choreography</figcaption></figure><p name="ab0b" id="ab0b" class="graf graf--p graf-after--figure">Again, these are two very different types of workflow management. Similar to synchronous and asynchronous above, when orchestration is chosen, it is easier to control the entire workflow, and when any task fails, the top <code class="markup--code markup--p-code">Service A</code> has a way to know and take the correct action, i.e., orchestration makes it easier to get higher data consistency.</p><p name="39ab" id="39ab" class="graf graf--p graf-after--p">On the other hand, choreography can have better scalability and availability because of the low coupling between each other. Even when there are functions that need to be implemented, choreography is more productive because it does not need to be initiated by <code class="markup--code markup--p-code">Service A</code>. Each microservice communicates with each other through messages and only needs to implement new message processors.</p><h3 name="cbcd" id="cbcd" class="graf graf--h3 graf-after--p">Monolithic Decomposition</h3><blockquote name="a3a2" id="a3a2" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">Component-based vs. Tactical forking</em></blockquote><p name="c880" id="c880" class="graf graf--p graf-after--blockquote">When we want to decompose a monolith to microservices, there are two different strategies that can be used. Component-based decomposition is a traditional domain-driven development that first correctly recognizes the function and size of each component, then analyzes the dependencies between the components, and finally tries to decompose the components according to a domain-based manner and generate domain-sized microservices.</p><p name="4178" id="4178" class="graf graf--p graf-after--p">In contrast, tactical forking is a completely different process.</p><figure name="0669" id="0669" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rwte3OBqsYpQ8FkM5JMlXw.png" data-width="1396" data-height="450" src="https://cdn-images-1.medium.com/max/800/1*rwte3OBqsYpQ8FkM5JMlXw.png"><figcaption class="imageCaption">Technical forking</figcaption></figure><p name="3569" id="3569" class="graf graf--p graf-after--figure">First insert a proxy between the original client and the monolith. Have you noticed? The topology is not immutable, in order to compose the microservice, the topology is changed. Then, the original monolith is replicated exactly, and the two different functions are pointed to different targets in the proxy. Finally, according to the characteristics of the two functions, the original monolith is individually reduced to produce two different microservices.</p><p name="0cd4" id="0cd4" class="graf graf--p graf-after--p">Similarly, the two different strategies also have their own advantages and disadvantages. If component-based decomposition is used, there is a longer lead time, but the whole system can be decomposed with the right domain perspective, and in fact, the process must involve refactoring. In opposite, tactical forking does not have this refactoring process, but in return it is a much faster modification process.</p><h3 name="7549" id="7549" class="graf graf--h3 graf-after--p">Contract Management</h3><blockquote name="96ca" id="96ca" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">Strict vs. Loose</em></blockquote><p name="c56d" id="c56d" class="graf graf--p graf-after--blockquote">Contract management refers to what kind of data format should be used to communicate between two services? If you use a loose contract, such as JSON or XML, the coupling between the services will be tighter, and it will not be easy to manage the versioning and achieve forward-backward compatibility. But the advantage is that it is easier to develop, especially since JSON is already the main data format for frontend and backend communication, so JSON will also work more naturally with the service.</p><p name="e83d" id="e83d" class="graf graf--p graf-after--p">On the other hand, using a strict contract, such as Avro or protocol buffer, then the services only need to understand each other through the schema. The old and new versions of the service can also coexist easily.</p><h3 name="ac18" id="ac18" class="graf graf--h3 graf-after--p">Database Style</h3><p name="e56f" id="e56f" class="graf graf--p graf-after--h3">This is also a very popular topic. First you have to choose from PACELC, then ACID or BASE, and finally there are various options depending on the storage structure, such as K-V, columnar, row-based or graph.</p><p name="78d5" id="78d5" class="graf graf--p graf-after--p">The biggest drawback of choosing a relational database in the past was its lack of horizontal scalability, but recently there has been a new breakthrough with more distributed SQL options. But again, there is no perfect solution, you still need to understand what distributed SQL can do and what it lacks.</p><p name="d514" id="d514" class="graf graf--p graf-after--p">Behind each of these choices is a lot of experience and domain knowledge, and it’s really hard.</p><h3 name="9a14" id="9a14" class="graf graf--h3 graf-after--p">Architecture Style</h3><p name="295d" id="295d" class="graf graf--p graf-after--h3">Choosing the architecture type is interesting. There are many types of architectures alone, such as service-oriented architectures, microservice architectures, event-driven architectures, and so on.</p><p name="2350" id="2350" class="graf graf--p graf-after--p">In fact, a system does not have only one architecture style, but usually a hybrid system. There are many aspects to determine when choosing event-driven and when choosing microservices for a “function”.</p><h3 name="c951" id="c951" class="graf graf--h3 graf-after--p">Distributed Transaction</h3><p name="879b" id="879b" class="graf graf--p graf-after--h3">The last challenge is distributed transactions. I mentioned in <a href="https://betterprogramming.pub/design-distributed-transaction-with-practical-examples-7b1d93fddb63" data-href="https://betterprogramming.pub/design-distributed-transaction-with-practical-examples-7b1d93fddb63" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">my previous article</a> that there are 3 factors should be considered when designing a distributed transaction.</p><ul class="postList"><li name="ef7e" id="ef7e" class="graf graf--li graf-after--p">Consistency: Atomic vs. Eventual Consistency</li><li name="05ce" id="05ce" class="graf graf--li graf-after--li">Communication: Synchronous vs. Asynchronous</li><li name="6d25" id="6d25" class="graf graf--li graf-after--li">Coordination: Orchestration vs. Choreography</li></ul><p name="2865" id="2865" class="graf graf--p graf-after--li">Therefore, there are 8 combinations, each of which has a different structure also pros and cons. According to the conclusion of <a href="https://medium.com/interviewnoodle/distributed-transaction-introduction-1cd105c830a2" data-href="https://medium.com/interviewnoodle/distributed-transaction-introduction-1cd105c830a2" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">distributed transaction introduction</a>, we should choose between eventual consistency and asynchronous, but then we still have to choose between orchestration and choreography.</p><figure name="540a" id="540a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_pxrC5YVDm5FEmp1SYGPUw.png" data-width="1004" data-height="502" src="https://cdn-images-1.medium.com/max/800/1*_pxrC5YVDm5FEmp1SYGPUw.png"><figcaption class="imageCaption">Parallel saga</figcaption></figure><figure name="8684" id="8684" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*aYjvID-xwNRRmKjykJHwVg.png" data-width="1290" data-height="146" src="https://cdn-images-1.medium.com/max/800/1*aYjvID-xwNRRmKjykJHwVg.png"><figcaption class="imageCaption">Anthology saga</figcaption></figure><p name="968b" id="968b" class="graf graf--p graf-after--figure">In the conclusion of the last article, it was stated that if you choose choreography you can get a better decouple and better scalability, but there will be a higher complexity of implementation. This is because it is very difficult to maintain the workflow of the whole transaction in choreography.</p><h3 name="8a2b" id="8a2b" class="graf graf--h3 graf-after--p"><a href="https://www.infoworld.com/article/3639050/complexity-is-killing-software-developers.html" data-href="https://www.infoworld.com/article/3639050/complexity-is-killing-software-developers.html" class="markup--anchor markup--h3-anchor" rel="noopener" target="_blank">Complexity is killing software developers</a></h3><p name="ed3c" id="ed3c" class="graf graf--p graf-after--h3">After discussing so many challenges and fallacies, I’m sure you’ll agree how difficult and complex it is to design a microservice system correctly, right? So, in recent seminars, the topic has slowly shifted from microservices implementation to microservices challenges.</p><p name="9b32" id="9b32" class="graf graf--p graf-after--p">Complexity is the pitfall of modern software architectures. But how do we evaluate complexity? We’ve talked about a lot of complex stuff today, so I’ll just offer a simple suggestion to measure it from my own experience.</p><blockquote name="3be6" id="3be6" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">When you want to make a change but are very hesitant because you don’t know the consequences of doing so.</em></blockquote><p name="0328" id="0328" class="graf graf--p graf-after--blockquote">Then, the complexity is pretty high.</p><p name="ee07" id="ee07" class="graf graf--p graf-after--p">Are there any specific evaluation criteria? Yes, there are. One of the methods is to analyze the degree of coupling. I have introduced instability in <a href="https://betterprogramming.pub/how-to-prepare-a-design-review-like-an-expert-85d2ab85d7f5" data-href="https://betterprogramming.pub/how-to-prepare-a-design-review-like-an-expert-85d2ab85d7f5" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a previous article</a>. This is one of the formulas to evaluate the coupling degree.</p><figure name="7946" id="7946" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vPqm1fbneYU-V42WcnepHw.png" data-width="386" data-height="162" src="https://cdn-images-1.medium.com/max/800/1*vPqm1fbneYU-V42WcnepHw.png"><figcaption class="imageCaption">Instability</figcaption></figure><h3 name="88d9" id="88d9" class="graf graf--h3 graf-after--figure">Conclusion</h3><p name="6bab" id="6bab" class="graf graf--p graf-after--h3">We talked a lot about the challenges and problems of designing a microservice architecture, or a distributed system. Every architect has had a journey from believing in microservices to questioning them. In order to prove the change of architect’s mindset, I list the sessions of <em class="markup--em markup--p-em">Worldwide Software Architecture Summit ’22</em> I cited in these two articles, and also provide you with a reference.</p><ul class="postList"><li name="8b42" id="8b42" class="graf graf--li graf-after--p">Software architecture in a non-enterprise world — a practical approach</li><li name="47cc" id="47cc" class="graf graf--li graf-after--li">Correctly Built Distributed Systems</li><li name="3b4e" id="3b4e" class="graf graf--li graf-after--li">What not to do on your next cloud-native architecture</li><li name="4545" id="4545" class="graf graf--li graf-after--li">Software observability: Visualize Code Quality at Scale</li><li name="97b0" id="97b0" class="graf graf--li graf-after--li">Designing Pragmatic Observability that Works: Avoiding Pitfalls</li><li name="0ee5" id="0ee5" class="graf graf--li graf-after--li">Complexity is the Problem</li><li name="6bb9" id="6bb9" class="graf graf--li graf-after--li graf--trailing">Microservices anti-patterns and pitfalls</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/8856c0e8426d"><time class="dt-published" datetime="2022-03-28T01:17:38.424Z">March 28, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/original-sin-of-microservices-part-2-8856c0e8426d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>