<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Consistency between Cache and Database, Part 2</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Consistency between Cache and Database, Part 2</h1>
</header>
<section data-field="subtitle" class="p-summary">
Part 2: Read Through, Write Through, Write Ahead and Double Delete
</section>
<section data-field="body" class="e-content">
<section name="ed3d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2ea4" id="2ea4" class="graf graf--h3 graf--leading graf--title">Consistency between Cache and Database, Part 2</h3><figure name="05fb" id="05fb" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*seDY4BgbqIgkZEBN.png" data-width="1770" data-height="1180" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*seDY4BgbqIgkZEBN.png"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@jtc" data-href="https://unsplash.com/@jtc" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Jesse Collins</a> on <a href="https://unsplash.com/photos/5sCQ4-t6p38" data-href="https://unsplash.com/photos/5sCQ4-t6p38" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><ul class="postList"><li name="7d46" id="7d46" class="graf graf--li graf-after--figure">Part 1: <a href="https://lazypro.medium.com/consistency-between-cache-and-database-part-1-f64f4a76720" data-href="https://lazypro.medium.com/consistency-between-cache-and-database-part-1-f64f4a76720" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Read Aside Caching</a></li><li name="ad85" id="ad85" class="graf graf--li graf-after--li">Part 2: Enhanced Approaches</li></ul><p name="0f4f" id="0f4f" class="graf graf--p graf-after--li">This is the last article in the series. In the previous article we introduced why caching is needed and also introduced the <em class="markup--em markup--p-em">Read Aside</em> process and potential problems, and of course explained how to improve the consistency of <em class="markup--em markup--p-em">Read Aside</em>. Nevertheless, <em class="markup--em markup--p-em">Read Aside</em> is not enough for high consistency requirements.</p><p name="d648" id="d648" class="graf graf--p graf-after--p">One of the reasons why <em class="markup--em markup--p-em">Read Aside</em> can cause problems is because all users have access to the cache and database. When users manipulate data at the same time, inconsistencies occur due to various combinations of operation order.</p><p name="bd35" id="bd35" class="graf graf--p graf-after--p">Then we can effectively avoid inconsistency by limiting the behavior of manipulating data, which is the core concept of the next few methods.</p><h3 name="eb34" id="eb34" class="graf graf--h3 graf-after--p">Read Through</h3><p name="3806" id="3806" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Read Path</strong></p><ul class="postList"><li name="95ff" id="95ff" class="graf graf--li graf-after--p">Reading data from cache</li><li name="89ec" id="89ec" class="graf graf--li graf-after--li">If the cache data does not exist</li><li name="68fb" id="68fb" class="graf graf--li graf-after--li">Read from database <strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">by cache</em></strong></li><li name="76e6" id="76e6" class="graf graf--li graf-after--li">Cache returns to the application client</li></ul><p name="2861" id="2861" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Write Path</strong></p><ul class="postList"><li name="496c" id="496c" class="graf graf--li graf-after--p">Don’t care, usually used in combination with <em class="markup--em markup--li-em">Write Through</em> or <em class="markup--em markup--li-em">Write Ahead</em>.</li></ul><p name="8c5d" id="8c5d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Potential Problems</strong></p><p name="52aa" id="52aa" class="graf graf--p graf-after--p">The biggest problem with this approach is that not all caches are supported, and the Redis example in this article does not support this approach.</p><p name="688a" id="688a" class="graf graf--p graf-after--p">Of course, some caches are supported, such as <a href="https://www.alachisoft.com/ncache/" data-href="https://www.alachisoft.com/ncache/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">NCache</a>, but NCache also has its problems.</p><p name="59f2" id="59f2" class="graf graf--p graf-after--p">First, it does not support many client-side SDKs. <em class="markup--em markup--p-em">.NET Core</em> is the native support language and there are not many options left.</p><p name="8c56" id="8c56" class="graf graf--p graf-after--p">Besides, it is divided into open source version and enterprise version, but you should know that if the open source version is not used by many people, then it is a tragedy when something goes wrong. Even so, the Enterprise version requires a license fee, not only for the infrastructure, but also for the software license.</p><p name="4f13" id="4f13" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How to Improve</strong></p><p name="7846" id="7846" class="graf graf--p graf-after--p">Since NCache has its high cost, can we implement <em class="markup--em markup--p-em">Read Through</em> ourselves? The answer is yes.</p><figure name="d1cf" id="d1cf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vSFuWlErxkcGc_AiEqccXA.png" data-width="824" data-height="440" src="https://cdn-images-1.medium.com/max/800/1*vSFuWlErxkcGc_AiEqccXA.png"><figcaption class="imageCaption">Read Through Caching</figcaption></figure><p name="b3bf" id="b3bf" class="graf graf--p graf-after--figure">For the application, we don’t really care what kind of cache is behind it, as long as it provides us with data fast enough, that’s all we need. Therefore, we can package Redis as a standalone service called Data Access Layer (DAL), with an internal API server to coordinate the cache and database.</p><p name="7ec6" id="7ec6" class="graf graf--p graf-after--p">The application only needs to use the defined API to get data from the DAL, and doesn’t need to care about how the cache works or where the database is.</p><h3 name="a262" id="a262" class="graf graf--h3 graf-after--p">Write Through</h3><p name="cec6" id="cec6" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Read Path</strong></p><ul class="postList"><li name="68db" id="68db" class="graf graf--li graf-after--p">Don’t care, the actual work is usually done through <em class="markup--em markup--li-em">Read Through</em>.</li></ul><p name="4777" id="4777" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Write Path</strong></p><ul class="postList"><li name="8010" id="8010" class="graf graf--li graf-after--p">Data only written for caching</li><li name="9ce7" id="9ce7" class="graf graf--li graf-after--li">Updated database <strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">by cache</em></strong></li></ul><p name="6c72" id="6c72" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Potential Problems</strong></p><p name="99d4" id="99d4" class="graf graf--p graf-after--p">As with <em class="markup--em markup--p-em">Read Through</em>, not every cache is supported and must be implemented on your own.</p><p name="48ae" id="48ae" class="graf graf--p graf-after--p">In addition, caching is not designed to be used for data manipulation. Many databases have capabilities that caching does not have, especially the ACID guarantee for relational databases.</p><p name="9e3d" id="9e3d" class="graf graf--p graf-after--p">More importantly, caching is not suitable for data persistence. When an application writes to a cache and considers the update to be finished, the cache may still lose the data for “some reason”. Then, the current update will never happen again.</p><p name="4d42" id="4d42" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How to Improve</strong></p><p name="2f16" id="2f16" class="graf graf--p graf-after--p">As with <em class="markup--em markup--p-em">Read Through</em>, a DAL had to be implemented, but the ACID and persistence problems were still not overcome. So, <em class="markup--em markup--p-em">Write Ahead</em> was born.</p><h3 name="e8d1" id="e8d1" class="graf graf--h3 graf-after--p">Write Ahead</h3><p name="ac10" id="ac10" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Read Path</strong></p><ul class="postList"><li name="f920" id="f920" class="graf graf--li graf-after--p">Don’t care, the actual work is usually done through <em class="markup--em markup--li-em">Read Through</em>.</li></ul><p name="c414" id="c414" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Write Path</strong></p><ul class="postList"><li name="4500" id="4500" class="graf graf--li graf-after--p">Data only written for caching</li><li name="6d4d" id="6d4d" class="graf graf--li graf-after--li">Updated database <strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">by cache</em></strong></li></ul><p name="6ae8" id="6ae8" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Potential Problems</strong></p><p name="36cb" id="36cb" class="graf graf--p graf-after--p">Similarly, <em class="markup--em markup--p-em">Write Ahead</em> is not supported by many caches. Even though the read path and write path look the same as <em class="markup--em markup--p-em">Write Through</em>, the implementation behind it is very different.</p><p name="6ecd" id="6ecd" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Write Ahead</em> was created to solve the problem of <em class="markup--em markup--p-em">Write Through</em>, so let’s introduce it first.</p><figure name="05f7" id="05f7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fJ_TtHLBMagKRiVTCuce2A.png" data-width="1140" data-height="552" src="https://cdn-images-1.medium.com/max/800/1*fJ_TtHLBMagKRiVTCuce2A.png"><figcaption class="imageCaption">Write Ahead Caching</figcaption></figure><p name="2991" id="2991" class="graf graf--p graf-after--figure">We will also implement a DAL, but unlike <em class="markup--em markup--p-em">Write Through</em>, it is actually an internal message queue rather than a cache. As you can see from the diagram above, the entire DAL architecture becomes more complex. To use the message queue correctly requires more domain knowledge and more human resources to design and implement.</p><p name="581e" id="581e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How to Improve</strong></p><p name="9dd6" id="9dd6" class="graf graf--p graf-after--p">By using message queues, the persistence of changes can be effectively ensured, and message queues also guarantee a certain degree of atomicity and isolation, which is not as complete as a relational database, but still has a basic level of reliability.</p><p name="3687" id="3687" class="graf graf--p graf-after--p">Moreover, message queues can merge fragmented updates into batches. For example, when an application wants to update three caches so it sends three messages, the DAL worker can merge the three messages into a single SQL syntax to reduce access to the database.</p><p name="e1b8" id="e1b8" class="graf graf--p graf-after--p">It is important to note the message queue must be used to ensure the order of messages, because for database updates, inserting and then deleting has a very different meaning than deleting and then inserting. The way to ensure message order is slightly different for each message queue, and in the case of Kafka it can be achieved by using the correct partition keys.</p><p name="0e75" id="0e75" class="graf graf--p graf-after--p">Nevertheless, the complexity of implementing <em class="markup--em markup--p-em">Write Ahead</em> is very high. If you cannot afford such complexity, then <em class="markup--em markup--p-em">Read Aside</em> is a better choice.</p><h3 name="b6d6" id="b6d6" class="graf graf--h3 graf-after--p">Double Delete</h3><p name="3dd0" id="3dd0" class="graf graf--p graf-after--h3">We have already talked about two major types of cache patterns, which are</p><ul class="postList"><li name="9f85" id="9f85" class="graf graf--li graf-after--p">Read Aside</li><li name="c769" id="c769" class="graf graf--li graf-after--li">Read Through, Write Through, Write Ahead</li></ul><p name="55d9" id="55d9" class="graf graf--p graf-after--li">The most fundamental difference between these two types is the complexity of implementation. In the case of <em class="markup--em markup--p-em">Read Aside</em>, it is very easy to implement, and it is also very simple to do right. However, <em class="markup--em markup--p-em">Read Aside</em> can easily generate various corner cases under many interactions.</p><p name="7a9a" id="7a9a" class="graf graf--p graf-after--p">On the other hand, corner cases can be avoided by implementing DAL, but it is very difficult to implement DAL correctly, and it requires extensive domain knowledge to implement correctly, which further makes DAL difficult to achieve.</p><p name="9fa4" id="9fa4" class="graf graf--p graf-after--p">So, is DAL the only way to reduce the number of corner cases? No, not really.</p><p name="7075" id="7075" class="graf graf--p graf-after--p">This is what the <em class="markup--em markup--p-em">Double Delete</em> pattern is trying to solve.</p><p name="434f" id="434f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Read Path</strong></p><ul class="postList"><li name="8a54" id="8a54" class="graf graf--li graf-after--p">Reading data from cache</li><li name="26f7" id="26f7" class="graf graf--li graf-after--li">If the cache data does not exist</li><li name="4b86" id="4b86" class="graf graf--li graf-after--li">Read from the database instead</li><li name="9f49" id="9f49" class="graf graf--li graf-after--li">and write back to the cache</li></ul><p name="5656" id="5656" class="graf graf--p graf-after--li">The process is exactly the same as <em class="markup--em markup--p-em">Read Aside</em>.</p><p name="b2e1" id="b2e1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Write Path</strong></p><ul class="postList"><li name="89e5" id="89e5" class="graf graf--li graf-after--p">Clear the cache first</li><li name="3c54" id="3c54" class="graf graf--li graf-after--li">Then write the data into the database</li><li name="8ecc" id="8ecc" class="graf graf--li graf-after--li">Wait for a while, then clear the cache again</li></ul><p name="14d6" id="14d6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Potential Problems</strong></p><p name="42f4" id="42f4" class="graf graf--p graf-after--p">The purpose of <em class="markup--em markup--p-em">Double Delete</em> is to minimize the time spent in disaster due to <em class="markup--em markup--p-em">Read Aside</em> corner cases.</p><p name="2349" id="2349" class="graf graf--p graf-after--p">The entire inconsistency depends entirely on the waiting time, which is equal to the maximum time waiting.</p><p name="b47d" id="b47d" class="graf graf--p graf-after--p">But how to wait is also a difficult practical problem. If we let the client originally started to deal with it, then the killed scenario in corner case 2 would still not be solved. If someone else performs it in an asynchronous way, then the communication contract and workflow control in between will be complicated.</p><p name="9183" id="9183" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How to Improve</strong></p><p name="0d9a" id="0d9a" class="graf graf--p graf-after--p">The same corner case 2 as <em class="markup--em markup--p-em">Read Aside</em>, but again, it can be reduced by a graceful shutdown.</p><h3 name="6cfe" id="6cfe" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="8d68" id="8d68" class="graf graf--p graf-after--h3">In this article, we introduce many ways to improve consistency. In general, when consistency is not a critical requirement, <em class="markup--em markup--p-em">Cache Expiry</em> is sufficient and requires a very low implementation effort. In fact, the widely used CDN is just one of the cases where <em class="markup--em markup--p-em">Cache Expiry</em> is used.</p><p name="f275" id="f275" class="graf graf--p graf-after--p">As the scenario becomes more and more critical and requires higher and higher consistency, then consider using <em class="markup--em markup--p-em">Read Aside</em> or even <em class="markup--em markup--p-em">Double Delete</em> to achieve it. The correct implementation of these two methods is sufficient for consistency to satisfy most scenarios.</p><p name="1630" id="1630" class="graf graf--p graf-after--p">However, as consistency requirements continue to increase, more complex implementations such as <em class="markup--em markup--p-em">Read Through</em> and <em class="markup--em markup--p-em">Write Through</em> or even <em class="markup--em markup--p-em">Write Ahead</em> become necessary. Although this can improve consistency, it is also costly. First, it requires sufficient manpower and domain knowledge to implement. In addition, the time cost of implementation and the maintenance cost afterwards are significantly higher. Furthermore, there are additional expenses to operate such an infrastructure.</p><p name="2dd3" id="2dd3" class="graf graf--p graf-after--p">To further improve consistency, it is necessary to use more advanced techniques, such as consensus algorithms, to ensure the consistency of cache and database content by majority consensus. This is also the concept behind TAO, but I am not going to introduce such a complex approach, after all, we are not Meta, at least, I am not.</p><p name="a811" id="a811" class="graf graf--p graf-after--p">In a general organization, the requirements for consistency are not as strict as, let’s say, 10 or more nines, and a general organization cannot operate such a complex and large architecture.</p><p name="fe8e" id="fe8e" class="graf graf--p graf-after--p graf--trailing">Therefore, in this article, I have chosen practices that we can all achieve, but even if they are simple practices, there is already a high enough level of consistency if they are implemented correctly.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/e28fc7f8a7c3"><time class="dt-published" datetime="2022-07-11T01:05:54.076Z">July 11, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/consistency-between-cache-and-database-part-2-e28fc7f8a7c3" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>