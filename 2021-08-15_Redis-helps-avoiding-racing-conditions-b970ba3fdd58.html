<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Redis helps avoiding racing conditions</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Redis helps avoiding racing conditions</h1>
</header>
<section data-field="subtitle" class="p-summary">
How to leverage Redis to solve the race condition on the lottery scheme. We ensure the integrity of data also the throughput on…
</section>
<section data-field="body" class="e-content">
<section name="4520" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="13ff" id="13ff" class="graf graf--h3 graf--leading graf--title">Redis helps avoiding racing conditions</h3><p name="7d20" id="7d20" class="graf graf--p graf-after--h3">In the <a href="https://lazypro.medium.com/how-to-avoid-the-race-condition-and-the-negative-value-3f397b2b08e4" data-href="https://lazypro.medium.com/how-to-avoid-the-race-condition-and-the-negative-value-3f397b2b08e4" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">previous article</a>, we had introduced how to ensure the integrity of transferring money. However, it’s not good enough to prevent going wrong. That approach will probably take time to retry many times to make things be done, so that it consumes client’s time as well as occupying the database resource.</p><h3 name="800b" id="800b" class="graf graf--h3 graf-after--p">User Scenario</h3><p name="04b9" id="04b9" class="graf graf--p graf-after--h3">Suppose there is a table for maintaining the lottery tickets, and each ticket has its own owner, serial number and a flag, remain, of whether it is used or not. In addition, there is another table to keep winning records.</p><figure name="e60d" id="e60d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6zJnpGt56SCgRNUyK7x_zA.png" data-width="194" data-height="193" src="https://cdn-images-1.medium.com/max/800/1*6zJnpGt56SCgRNUyK7x_zA.png"><figcaption class="imageCaption">tickets</figcaption></figure><figure name="488f" id="488f" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*bXMjPAc-2XOawumO4Db9uA.png" data-width="131" data-height="81" src="https://cdn-images-1.medium.com/max/800/1*bXMjPAc-2XOawumO4Db9uA.png"><figcaption class="imageCaption">rewards</figcaption></figure><p name="cb36" id="cb36" class="graf graf--p graf-after--figure">For instance, <em class="markup--em markup--p-em">A</em> had 3 tickets but used one. And then, <em class="markup--em markup--p-em">B</em> got one ticket. Besides, the used ticket wins 100 dollars for <em class="markup--em markup--p-em">A</em>.</p><h3 name="7fe2" id="7fe2" class="graf graf--h3 graf-after--p">Simple Design</h3><p name="e7f4" id="e7f4" class="graf graf--p graf-after--h3">According the our previous introduction, we will design the <code class="markup--code markup--p-code">remain</code> flag in an unsigned integer with the default value: 1. When consuming this ticket, we uses the atomic update to increase the remain by -1. If a user has only one ticket but wants to draw twice, the second attempt will fail due to the negative value of <code class="markup--code markup--p-code">remain</code>.</p><p name="132a" id="132a" class="graf graf--p graf-after--p">Represent in the psudo code is like:</p><pre name="2c93" id="2c93" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">`START TRANSACTION`<br>A_ticket = `select id from tickets where \<br>      remain = 1 and user = &#39;A&#39; order by id limit 1`<br>`update tickets set remain = remain - 1 where id = A_ticket`<br>reward = bingo()<br>`insert into rewards (id, reward) values (${A_ticket}, ${reward})`<br>`COMMIT`</code></pre><p name="d536" id="d536" class="graf graf--p graf-after--pre">First, <em class="markup--em markup--p-em">A</em>’s first ticket will be picked out, and the lottery will start after deduction. Finally, the result will be updated into the database.</p><p name="b661" id="b661" class="graf graf--p graf-after--p">But the problem occurs in the assumption that <em class="markup--em markup--p-em">A</em> has two tickets like the example at the beginning of this article, which means that <em class="markup--em markup--p-em">A</em> can draw twice at the same time. When <em class="markup--em markup--p-em">A</em> draws twice simultaneously, it should be successful without fail.</p><p name="81da" id="81da" class="graf graf--p graf-after--p">Run the process once with the implementation we mentioned. The first one who comes in will get a ticket number 3 and the second one who comes in will also get the same ticket. As a result, the first draw will succeed but the second attempt will be failed. If it fails, then it must try again, and then it will get the ticket number 4 and succeed.</p><p name="d8ab" id="d8ab" class="graf graf--p graf-after--p">Such a procedure would be correct after all, but it is not good enough. When you have <em class="markup--em markup--p-em">n</em> tickets, you obviously can draw <em class="markup--em markup--p-em">n</em> times at the same time within <em class="markup--em markup--p-em">O(1)</em>. However, such an implementation leads to <em class="markup--em markup--p-em">O(n)</em>. Among them, <em class="markup--em markup--p-em">O(n-1)</em> is a retry. And, the higher the <em class="markup--em markup--p-em">n</em>, the worse the user experience.</p><h3 name="3fba" id="3fba" class="graf graf--h3 graf-after--p">Random select</h3><p name="dce4" id="dce4" class="graf graf--p graf-after--h3">Here comes the second design, we don’t order by the id; instead, we pick the ticket randomly to mitigate the failure. Therefore, we modify the original <code class="markup--code markup--p-code">select</code> statement to become:</p><blockquote name="b5ad" id="b5ad" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">A_ticket = `</em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">select id from tickets where remain = 1 and user = &#39;A&#39; order by RAND() limit 1</em></code><em class="markup--em markup--blockquote-em">`</em></blockquote><p name="d959" id="d959" class="graf graf--p graf-after--blockquote">In this example, we don’t care about the drawback of <code class="markup--code markup--p-code">order by RAND()</code>; nevertheless, the random means it will sometimes go wrong. Worst of all, it may choose the ticket with a long validity period instead of the ticket is about to expire.</p><h3 name="a617" id="a617" class="graf graf--h3 graf-after--p">Requirement</h3><p name="49c4" id="49c4" class="graf graf--p graf-after--h3">Looking back at our needs, we need to draw a lottery “simultaneously” several times when the user has a few tickets, and use the tickets in order.</p><h3 name="8a1c" id="8a1c" class="graf graf--h3 graf-after--p">Final Solution</h3><p name="36f4" id="36f4" class="graf graf--p graf-after--h3">To achieve our goal, we can leverage Redis’ help. The purpose of Redis is to have a congestion control. In order to make all clients can succeed once, we have to dispatch the tickets to them correctly while highly concurrency occurs.</p><h3 name="e8fe" id="e8fe" class="graf graf--h3 graf-after--p">Bad approach</h3><p name="6a4a" id="6a4a" class="graf graf--p graf-after--h3">Usually, Redis is used to be a distributed optimistic lock to make sure the permission of a critical section, e.g.,</p><pre name="2c46" id="2c46" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">ret = `setnx lock 1`<br>if not ret:<br>    raise Locked(&quot;already locked by others&quot;)<br>else:<br>    do_something()<br>    `del lock`</code></pre><p name="390d" id="390d" class="graf graf--p graf-after--pre">If an application can set a lock in Redis, which means he can dominate this time period until he finishes his job; on the other hand, everyone must wait for him. Solving the problem in this way is still not very helpful, at most it can only speed up the client’s retry, because the client doesn’t need to go through the database operation and the lottery procedures.</p><h3 name="1c2f" id="1c2f" class="graf graf--h3 graf-after--p">Good approach</h3><p name="b8ff" id="b8ff" class="graf graf--p graf-after--h3">To solve this problem, we want to support multi-entrance by using Redis. The process is to push all the current ticket numbers through <code class="markup--code markup--p-code">LPUSH</code>, and use <code class="markup--code markup--p-code">RPOP</code> to take out the first one.</p><p name="b3ba" id="b3ba" class="graf graf--p graf-after--p">Because Redis’ single command is atomic, you can ensure that the tickets are correctly allocated to each call that comes in at the same time.</p><p name="68a5" id="68a5" class="graf graf--p graf-after--p">Let’s take a simple psudο code as an example:</p><pre name="1ee6" id="1ee6" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">do:<br>    A_owned_tickets = `select id from tickets where \<br>            remain = 1 and user = &#39;A&#39; order by id`<br>    `LPUSH A_owned_tickets ${owned_tickets}`<br>    A_ticket = `RPOP A_owned_tickets`<br>while A_ticket != nil</code></pre><pre name="106f" id="106f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">`START TRANSACTION`<br>`update tickets set remain = remain - 1 where id = A_ticket`<br>reward = bingo()<br>`insert into rewards (id, reward) values (${A_ticket}, ${reward})`<br>`COMMIT`<br>`DEL A_owned_tickets`</code></pre><p name="fb84" id="fb84" class="graf graf--p graf-after--pre">In the above example, we use uppercase to indicate Redis’ instructions. Let’s use the sequential diagram to get a deeper look at what’s going on.</p><figure name="9e63" id="9e63" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*gWVoWfWzyRm6pq8pOJPqkA.png" data-width="287" data-height="431" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*gWVoWfWzyRm6pq8pOJPqkA.png"></figure><p name="e03c" id="e03c" class="graf graf--p graf-after--figure">The above is an ideal situation. Although <em class="markup--em markup--p-em">A1</em> and <em class="markup--em markup--p-em">A2</em> occur simultaneously, <em class="markup--em markup--p-em">A1</em> is slightly earlier than <em class="markup--em markup--p-em">A2</em>, so there will be two complete sequences in Redis, <code class="markup--code markup--p-code">[4, 3, 4, 3]</code>. If <em class="markup--em markup--p-em">A1</em> and <em class="markup--em markup--p-em">A2</em> occur almost at the same time, it will be the following situation:</p><figure name="df4f" id="df4f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*J2ncLvugpOY-SyD8wKQYHw.png" data-width="286" data-height="429" src="https://cdn-images-1.medium.com/max/800/1*J2ncLvugpOY-SyD8wKQYHw.png"></figure><p name="a249" id="a249" class="graf graf--p graf-after--figure">From the above figure, even if <em class="markup--em markup--p-em">A1</em> and <em class="markup--em markup--p-em">A2</em> occur almost simultaneously, it will not affect the accuracy. So what happens if <em class="markup--em markup--p-em">A1</em> finishes its job faster, COMMIT the result and deletes the list?</p><figure name="8dda" id="8dda" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*s4kodbsn4aggopSRP1MhRQ.png" data-width="231" data-height="540" src="https://cdn-images-1.medium.com/max/800/1*s4kodbsn4aggopSRP1MhRQ.png"></figure><p name="bf1b" id="bf1b" class="graf graf--p graf-after--figure">We can see <em class="markup--em markup--p-em">A2</em> got a <code class="markup--code markup--p-code">nil</code> at the first time, so he therefore had to retrieve the tickets from MySQL and push again to proceed the process. Even so, it is more efficient than the original commit failure after all the processes are run.</p><p name="98b7" id="98b7" class="graf graf--p graf-after--p">The worst case will happen when there is high concurrency, some clients are very fast and some clients are very slow, which will cause several retries and still fail. The flow as shown below.</p><figure name="1de8" id="1de8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PhgYEVZrH6dnOdhL6GWxJQ.png" data-width="338" data-height="466" src="https://cdn-images-1.medium.com/max/800/1*PhgYEVZrH6dnOdhL6GWxJQ.png"></figure><p name="5751" id="5751" class="graf graf--p graf-after--figure">If this is the case, you can adopt an alternative approach. Do not actively <code class="markup--code markup--p-code">DEL</code> the list, but use <code class="markup--code markup--p-code">EXPIRE</code> to delete. Choosing a reasonable timeout will relieve symptoms. However, it comes another problem, the validity of expired data. This is a trade-off, you can take the approach that suits your user scenario.</p><p name="875a" id="875a" class="graf graf--p graf-after--p graf--trailing">At last, if the amount of coming requests is greater than the owned tickets, the original schema design still works to reject the invalid operations(<code class="markup--code markup--p-code">remain</code> cannot be negative).</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/b970ba3fdd58"><time class="dt-published" datetime="2021-08-15T07:33:12.717Z">August 15, 2021</time></a>.</p><p><a href="https://medium.com/@lazypro/redis-helps-avoiding-racing-conditions-b970ba3fdd58" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>