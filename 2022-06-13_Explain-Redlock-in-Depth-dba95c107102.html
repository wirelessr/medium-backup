<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Explain Redlock in Depth</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Explain Redlock in Depth</h1>
</header>
<section data-field="subtitle" class="p-summary">
Explaining why I don’t use Redlock and the potential risks of Redlock
</section>
<section data-field="body" class="e-content">
<section name="e564" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="aba0" id="aba0" class="graf graf--h3 graf--leading graf--title">Explain Redlock in Depth</h3><figure name="7e7b" id="7e7b" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*pTqqpePHil02H4_x.jpg" data-width="1708" data-height="1226" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*pTqqpePHil02H4_x.jpg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@parsoakhorsand" data-href="https://unsplash.com/@parsoakhorsand" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Parsoa Khorsand</a> on <a href="https://unsplash.com/photos/Dd6n63H9szw" data-href="https://unsplash.com/photos/Dd6n63H9szw" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="56c9" id="56c9" class="graf graf--p graf-after--figure">Previously, I <a href="https://betterprogramming.pub/redis-as-a-lock-are-you-sure-a870c9f22ad8" data-href="https://betterprogramming.pub/redis-as-a-lock-are-you-sure-a870c9f22ad8" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">introduced two types of locks</a>, mutex locks and barriers, and I used Redis as an example to explain the differences between the two types of locks. Shortly after that, I received a reply saying that if you want to implement distributed locks, the Redis approach is not enough and you should refer to Redlock.</p><p name="781c" id="781c" class="graf graf--p graf-after--p">Well, his opinion is basically right.</p><p name="0804" id="0804" class="graf graf--p graf-after--p">Although Redlock is implemented through Redis, it can achieve a very high level of consistency and is one of the best paradigms for implementing distributed locking. However, Redlock has a very high cost behind it and is not suitable for all organizations and services.</p><p name="5364" id="5364" class="graf graf--p graf-after--p">Nevertheless, I will introduce Redlock and present my thoughts on why Redlock is impractical.</p><h3 name="0c5b" id="0c5b" class="graf graf--h3 graf-after--p">Redis is not reliable</h3><p name="15d6" id="15d6" class="graf graf--p graf-after--h3">Before getting started, I should emphasize that <a href="https://towardsdev.com/data-persistence-in-redis-2780c11d1623" data-href="https://towardsdev.com/data-persistence-in-redis-2780c11d1623" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Redis persistence is unreliable, even with the most strict settings</a>.</p><p name="f009" id="f009" class="graf graf--p graf-after--p">However, in a cluster environment, a <em class="markup--em markup--p-em">Master</em> may have a number of <em class="markup--em markup--p-em">Slave</em> redundancies. Is Redis still unreliable under these conditions? The answer is yes.</p><p name="4f66" id="4f66" class="graf graf--p graf-after--p">In Redis implementation, data replication is performed by the background process, not the master thread, so when a client writes successfully, it does not mean the data is replicated successfully. One of the procedures leading to the problem is as follows.</p><figure name="1c83" id="1c83" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*q4lBE0VJECydo6Uu-qoSww.png" data-width="1292" data-height="750" src="https://cdn-images-1.medium.com/max/800/1*q4lBE0VJECydo6Uu-qoSww.png"></figure><p name="0ac6" id="0ac6" class="graf graf--p graf-after--figure">When Client 1 successfully locks via the original <em class="markup--em markup--p-em">Master</em>, but the <em class="markup--em markup--p-em">Master</em> dies before the data is replicated, then Client 2 can still successfully lock via the original <em class="markup--em markup--p-em">Slave</em> (the new <em class="markup--em markup--p-em">Master</em>).</p><p name="fe1b" id="fe1b" class="graf graf--p graf-after--p">This is the reason why Redis clusters are still unreliable.</p><h3 name="c693" id="c693" class="graf graf--h3 graf-after--p">Redlock Concept</h3><p name="8680" id="8680" class="graf graf--p graf-after--h3">As we have seen, a single Redis is not reliable, even in a cluster of multiple Redis. So how do we use Redis to implement a reliable Redlock?</p><p name="c106" id="c106" class="graf graf--p graf-after--p">The answer is through majority consensus. Since one Redis is not reliable, we form a committee of multiple Redis. If and only if more than half of the committee members agree, the lock will take effect; otherwise, the lock is invalid. The members can be single, master-slave, or even clusters, but nevertheless, they are independent of each other, in other words, they are not duplicates of each other, not to mention the same cluster.</p><blockquote name="db49" id="db49" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">According to the majority consensus algorithm, the committee should have an odd number of members and be approved when a majority of the members (</em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">N/2 + 1</em></code><em class="markup--em markup--blockquote-em">) agree. </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">N</em></code><em class="markup--em markup--blockquote-em"> indicates the total number of members.</em></blockquote><p name="4768" id="4768" class="graf graf--p graf-after--blockquote">The detailed process is written in the <a href="https://redis.io/docs/reference/patterns/distributed-locks/" data-href="https://redis.io/docs/reference/patterns/distributed-locks/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">official Redis documentation on distributed locking</a>, so I’ll briefly describe the process below.</p><p name="7700" id="7700" class="graf graf--p graf-after--p">Suppose our committee is composed of three Redis.</p><p name="0b02" id="0b02" class="graf graf--p graf-after--p">The following is the process of successfully locking up and doing the task and unlocking successfully.</p><figure name="5a18" id="5a18" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9tbZXuVgSvt7di5l91ganQ.png" data-width="862" data-height="1120" src="https://cdn-images-1.medium.com/max/800/1*9tbZXuVgSvt7di5l91ganQ.png"></figure><ol class="postList"><li name="398d" id="398d" class="graf graf--li graf-after--figure">The client who wants to obtain the lock generates a globally unique ID, and the official document selects the system time to use.</li><li name="d72b" id="d72b" class="graf graf--li graf-after--li">Try to use this ID to get the consent of all committee members. Use the command <code class="markup--code markup--li-code">SETNX</code> to do this.</li><li name="08a8" id="08a8" class="graf graf--li graf-after--li">2 members agree, then the lock is successfully in place.</li><li name="f209" id="f209" class="graf graf--li graf-after--li">After getting the lock, the user can do what desired.</li><li name="3e24" id="3e24" class="graf graf--li graf-after--li">The next step is to unlock on every member, whether or not the lock is successfully getting.</li></ol><p name="dbfe" id="dbfe" class="graf graf--p graf-after--li">The process for unsuccessful locking is similar, as long as <code class="markup--code markup--p-code">Redis1</code> or <code class="markup--code markup--p-code">Redis2</code> also fails to respond, then the lock cannot be acquired, that is to say, you cannot do anything, but you still have to perform the process of unlocking all the members.</p><h3 name="52df" id="52df" class="graf graf--h3 graf-after--p">Redlock Issues</h3><p name="5709" id="5709" class="graf graf--p graf-after--h3">After describing the Redlock process above, I’d like to explain why I rarely consider such an approach.</p><p name="e31d" id="e31d" class="graf graf--p graf-after--p">Firstly, the entire Redlock implementation process, as mentioned in the previous section, is very time-consuming. Particularly if you want to lock for 3 seconds, but actually only 2 seconds or less are left after the locking process. <strong class="markup--strong markup--p-strong">Because the application must be initiated to all Redis first, even with parallel processing, the network delay and packet loss still make the communication chaotic and complicated.</strong></p><p name="4295" id="4295" class="graf graf--p graf-after--p">Secondly, in order to make unreliable Redis reliable, many independent Redis must be launched. In the context of site reliability engineering, the maintenance effort for so many Redis is very high, and it is also a problem to make the participating clients aware of the existence of so many Redis. Such a approach is impractical in terms of cost, maintenance effort, and complexity of implementation.</p><p name="af51" id="af51" class="graf graf--p graf-after--p">Furthermore, the core of this approach is <strong class="markup--strong markup--p-strong">GUID</strong>. If IDs are duplicated, both locking and unlocking may result in false positives and unpredictable results. When this happens, the difficulty of detecting it is also significant. Nevertheless, the system time, as officially documented, is a very weak guarantee. <strong class="markup--strong markup--p-strong">In a distributed system, it is difficult to ensure that all instances have the same time</strong>, which is known as <em class="markup--em markup--p-em">clock skew</em> in system design.</p><p name="9e2b" id="9e2b" class="graf graf--p graf-after--p">To sum up, Redlock is an expensive approach with a lot of technical depth. Although many people have implemented packages in various programming languages based on official documents, does each user understand the potential risks behind the simple use of the packages?</p><h3 name="b6ae" id="b6ae" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="4bee" id="4bee" class="graf graf--p graf-after--h3">The main reason I don’t use Redlock is because making unreliable Redis reliable is putting the cart before the horse. I always tell my team members, “Data in Redis needs to be aware that it will disappear without warning”. If you want to keep the data persistent, you should consider a more persistent database rather than a cache.</p><p name="54d7" id="54d7" class="graf graf--p graf-after--p">When implementing distributed locking, instead of using Redis, we should use a more reliable database, such as MySQL, which is strongly consistent, or MongoDB, which is my personal preference. But even if we use a database, we should pay attention to the implementation details of the database. Take MongoDB as an example, if we want to implement a lock, then we need to be aware of <a href="https://towardsdev.com/read-after-write-consistency-in-mongodb-ea4cd91d0d3" data-href="https://towardsdev.com/read-after-write-consistency-in-mongodb-ea4cd91d0d3" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">read-after-write consistency</a>.</p><p name="b504" id="b504" class="graf graf--p graf-after--p">There are many aspects to consider behind the system design, and it is not enough to just make the function work. How to control the budget? How to allocate manpower? How to maintain day-to-day? How to troubleshoot? All of these factors involve the capacity of the team, which I believe is far more important than the actual functionality.</p><p name="84ef" id="84ef" class="graf graf--p graf-after--p">When considering the use of distributed locks, I first ask myself, “Do we really need locks? Is there a way to avoid possible race conditions through architecture design?” <strong class="markup--strong markup--p-strong">It is far more effective to avoid locking by improving the architecture than to seek synchronization in a distributed system.</strong> If we really have to use a distributed lock, and we need to keep the usage to a minimum, then we don’t need to use Redis but can use a relatively slow database to implement it.</p><blockquote name="dd30" id="dd30" class="graf graf--blockquote graf-after--p"><a href="https://www.infoworld.com/article/3639050/complexity-is-killing-software-developers.html" data-href="https://www.infoworld.com/article/3639050/complexity-is-killing-software-developers.html" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank"><em class="markup--em markup--blockquote-em">Complexity is killing software developers</em></a></blockquote><p name="ec7c" id="ec7c" class="graf graf--p graf-after--blockquote graf--trailing">And Redlock is one of the most complicated approaches. In my opinion, it should be avoided.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lazypro" class="p-author h-card">Chunting Wu</a> on <a href="https://medium.com/p/dba95c107102"><time class="dt-published" datetime="2022-06-13T01:39:07.178Z">June 13, 2022</time></a>.</p><p><a href="https://medium.com/@lazypro/explain-redlock-in-depth-dba95c107102" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 21, 2024.</p></footer></article></body></html>